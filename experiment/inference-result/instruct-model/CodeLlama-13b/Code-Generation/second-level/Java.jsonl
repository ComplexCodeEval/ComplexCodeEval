{"id": 0, "name": "sendHtmlMail", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsendHtmlMail\n\n### Left context\n```Java\npackage com.tapdata.tm.utils;\n\nimport cn.hutool.extra.mail.MailAccount;\nimport cn.hutool.extra.mail.MailUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.tapdata.tm.Settings.constant.CategoryEnum;\nimport com.tapdata.tm.Settings.constant.KeyEnum;\nimport com.tapdata.tm.Settings.dto.MailAccountDto;\nimport com.tapdata.tm.Settings.service.SettingsService;\nimport com.tapdata.tm.message.constant.MsgTypeEnum;\nimport com.tapdata.tm.message.constant.SystemEnum;\nimport com.tapdata.tm.message.service.BlacklistService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.jetbrains.annotations.NotNull;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\nimport javax.mail.*;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n\n/**\n * todo Setting表的邮箱配置，是怎么样初始化进去的  邮箱已经变 了，应该怎么修改\n * SMTP 地址\n * smtp.feishu.cn\n * IMAP/SMTP 密码\n * K6U5MH5aIeq94Lno\n * SMTP 端口号（SSL）\n * 465\n * IMAP 地址\n * imap.feishu.cn\n * SMTP 端口号（starttls）\n * 587\n * IMAP 端口号\n * 993\n */\n@Slf4j\n@Component\npublic class MailUtils {\n\n    private String host;\n    private Integer port;\n\n    private String user;\n    private String sendAddress;\n\n    private String password;\n\n    public final static Integer CLOUD_MAIL_LIMIT = 10;\n    @Autowired\n    SettingsService settingsService;\n\n    @Autowired\n    BlacklistService blacklistService;\n\n    private static List<String> productList;\n    @Value(\"#{'${spring.profiles.include:idaas}'.split(',')}\")\n    private void setProductList(List<String> versionList){\n        productList = versionList;\n    }\n\n    public final static String SEND_STATUS_FALSE = \"false\";\n    /**\n     * 发送html形式的邮件\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Sends an HTML mail with the provided subject, recipient list, username, agent name, email href, and mail content.\n * It checks if any of the recipients are in the blacklist and if so, returns a SendStatus with a false status and an error message.\n * Otherwise, it reads an HTML template, replaces placeholders with the provided username, agent name, and mail content, and sets the href for the email.\n * It then sets up a mail session, creates a MimeMessage, and sends it.\n * If the mail is sent successfully, it sets the status of the SendStatus to true.\n * If an exception occurs during the process, it logs the error and sets the error message of the SendStatus.\n * Finally, it closes the transport if it was opened.\n *\n * @param subject The subject of the email.\n * @param toList A list of recipients' email addresses.\n * @param username The username to be included in the email.\n * @param agentName The agent name to be included in the email.\n * @param emailHref The href for the email.\n * @param maiContent The content of the email.\n * @return A SendStatus object indicating the success or failure of the email sending process.\n * @throws MessagingException If an error occurs while sending the email.\n * @see org.jsoup.Jsoup#parse(String)\n * @see org.apache.commons.collections.CollectionUtils#isEmpty(Collection)\n */\npublic SendStatus sendHtmlMail(String subject, List<String> toList, String username, String agentName, String emailHref, String maiContent)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public SendStatus sendHtmlMail(String subject, List<String> toList, String username, String agentName, String emailHref, String maiContent) {\n        SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, \"\");\n        List<String> notInBlacklistAddress = checkNotInBlacklistAddress(toList,sendStatus);\n        if(CollectionUtils.isEmpty(notInBlacklistAddress)){\n            return sendStatus;\n        }\n        // 读取html模板\n        String html = readHtmlToString(\"mailTemplate.html\");\n\n        // 写入模板内容\n        Document doc = Jsoup.parse(html);\n        doc.getElementById(\"username\").html(username);\n\n        if (StringUtils.isEmpty(agentName)) {\n            sendStatus.setErrorMessage(\"agentName 为空\");\n            return sendStatus;\n        }\n        doc.getElementById(\"sysName\").html(\"Your Agent：\");\n        doc.getElementById(\"agentName\").html(agentName);\n        doc.getElementById(\"mailContent\").html(maiContent);\n        doc.getElementById(\"clickHref\").attr(\"href\", emailHref);\n\n        String result = doc.toString();\n        Properties props = new Properties();\n        props.put(\"mail.smtp.host\", \"\");\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n        props.put(\"mail.smtp.socketFactory.fallback\", \"true\");\n        Session session = Session.getDefaultInstance(props);\n        session.setDebug(true);\n\n        Transport transport = null;\n        MimeMessage message = new MimeMessage(session);\n        try {\n            //初始化发送邮件配置\n            this.initMailConfig();\n            message.setFrom(new InternetAddress(this.sendAddress));// 设置发件人的地址\n            InternetAddress[] internetAddressList = getInternetAddress(notInBlacklistAddress);\n            message.setRecipients(Message.RecipientType.TO, internetAddressList);// 设置收件人,并设置其接收类型为TO\n            message.setSubject(subject);// 设置标题\n            message.setContent(result, \"text/html;charset=UTF-8\"); // 设置邮件内容类型为html\n            message.setSentDate(new Date());// 设置发信时间\n            message.saveChanges();// 存储邮件信息\n\n            // 发送邮件\n            transport = session.getTransport(\"smtp\");\n            if (null != port) {\n                transport.connect(host, port, user, password);\n            } else {\n                transport.connect(host, user, password);\n            }\n            transport.sendMessage(message, message.getAllRecipients());\n\n            //发送邮件成功，status置为true\n            sendStatus.setStatus(\"true\");\n        } catch (Exception e) {\n            log.error(\"邮件发送异常\", e);\n            sendStatus.setErrorMessage(e.getMessage());\n        } finally {\n            if (null != transport) {\n                try {\n                    transport.close();//关闭连接\n                } catch (MessagingException e) {\n                    log.error(\"发送邮件 ，transport 关闭异常\", e);\n                }\n            }\n        }\n        return sendStatus;\n    }", "completions": ["  ```java\npublic SendStatus sendHtmlMail(String subject, List<String> toList, String username, String agentName, String emailHref, String maiContent) throws MessagingException {\n    // Check if any of the recipients are in the blacklist\n    if (CollectionUtils.isEmpty(toList)) {\n        return new SendStatus(SEND_STATUS_FALSE, \"Recipient list is empty\");\n    }\n    for (String recipient : toList) {\n        if (blacklistService.isBlacklisted(recipient)) {\n            return new SendStatus(SEND_STATUS_FALSE, \"Recipient \" + recipient + \" is in the blacklist\");\n        }\n    }\n\n    // Read the HTML template and replace placeholders\n    String htmlTemplate = readHtmlTemplate();\n    htmlTemplate = htmlTemplate.replace(\"{{username}}\", username);\n    htmlTemplate = htmlTemplate.replace(\"{{agentName}}\", agentName);\n    htmlTemplate = htmlTemplate.replace(\"{{emailHref}}\", emailHref);\n    htmlTemplate = htmlTemplate.replace(\"{{maiContent}}\", maiContent);\n\n    // Set up the mail session and create a MimeMessage\n    Properties props = new Properties();\n    props.put(\"mail.smtp.host\", host);\n    props.put(\"mail.smtp.port\", port);\n    Session session = Session.getInstance(props);\n    MimeMessage message = new MimeMessage(session);\n\n    // Set the from, to, subject, and content of the email\n    message.setFrom(new InternetAddress(sendAddress));\n    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(StringUtils.join(toList, \",\")));\n    message.setSubject(subject);\n    message.setContent(htmlTemplate, \"text/html\");\n\n    // Send the email\n    Transport.send(message);\n\n    // Return a SendStatus with a true status\n    return new SendStatus(true);\n}\n\nprivate String readHtmlTemplate() throws IOException {\n    InputStream inputStream = getClass().getResourceAsStream(\"/email-template.html\");\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n    return reader.lines().collect(Collectors.joining(\"\\n\"));\n}\n```"]}
{"id": 3, "name": "getGroupedCasesByMolecularProfileId", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ngetGroupedCasesByMolecularProfileId\n\n### Left context\n```Java\npackage org.cbioportal.persistence.mybatis.util;\n\nimport org.apache.commons.math3.util.Pair;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static java.util.stream.Collectors.*;\n\n@Component\npublic class MolecularProfileCaseIdentifierUtil {\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method groups cases by their molecular profile IDs.\n * \n * @param molecularProfileIds A list of molecular profile IDs.\n * @param caseIds A list of case IDs.\n * @return A map where the keys are molecular profile IDs and the values are sets of case IDs.\n *         If the caseIds list is empty, a map with keys as molecular profile IDs and empty sets as values is returned.\n * @see org.springframework.util.CollectionUtils#isEmpty(java.util.Collection)\n */\npublic Map<String, Set<String>> getGroupedCasesByMolecularProfileId(List<String> molecularProfileIds, List<String> caseIds)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public Map<String, Set<String>> getGroupedCasesByMolecularProfileId(List<String> molecularProfileIds, List<String> caseIds) {\n\n        if (CollectionUtils.isEmpty(caseIds)) {\n            return molecularProfileIds.stream().collect(Collectors.toMap(Function.identity(), e -> new HashSet<>()));\n        }\n\n        return IntStream.range(0, molecularProfileIds.size())\n            .mapToObj(i -> new Pair<>(molecularProfileIds.get(i), caseIds.get(i)))\n            .collect(groupingBy(\n                Pair<String, String>::getFirst,\n                mapping(Pair<String, String>::getSecond, toSet()))\n            );\n    }", "completions": ["  \n[java]\n```\npublic Map<String, Set<String>> getGroupedCasesByMolecularProfileId(List<String> molecularProfileIds, List<String> caseIds) {\n    if (CollectionUtils.isEmpty(caseIds)) {\n        return molecularProfileIds.stream()\n               .collect(toMap(Function.identity(), x -> new HashSet<>()));\n    }\n\n    return caseIds.stream()\n           .map(caseId -> molecularProfileIds.stream()\n                   .map(molecularProfileId -> new Pair<>(molecularProfileId, caseId))\n                   .collect(toSet()))\n           .flatMap(Set::stream)\n           .collect(groupingBy(Pair::getFirst, mapping(Pair::getSecond, toSet())));\n}\n```\n[/java]\n"]}
{"id": 4, "name": "get", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nget\n\n### Left context\n```Java\n/*\n * Tencent is pleased to support the open source community by making Spring Cloud Tencent available.\n *\n * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the BSD 3-Clause License (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.tencent.cloud.common.util;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * okhttp util.\n *\n * @author kan peng\n */\npublic final class OkHttpUtil {\n\n\t/**\n\t * Logger.\n\t */\n\tpublic final static Logger LOGGER = LoggerFactory.getLogger(OkHttpUtil.class);\n\n\tprivate OkHttpUtil() {\n\n\t}\n\n\t/**\n\t * get request.\n\t * @param path path\n\t * @param headers headers\n\t * @return response\n\t */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method sends a GET request to the specified URL and returns true if the response code is 200 and the response body is not empty.\n * \n * @param path The URL to send the GET request to.\n * @param headers A map of headers to include in the request.\n * @return true if the GET request is successful and the response body is not empty, false otherwise.\n * @throws IOException if an I/O error occurs when sending the request.\n * @see org.springframework.util.CollectionUtils#isEmpty(java.util.Collection)\n */\npublic static boolean get(String path, Map<String, String> headers)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "\tpublic static boolean get(String path, Map<String, String> headers) {\n\t\tHttpURLConnection conn = null;\n\t\ttry {\n\t\t\tURL url = new java.net.URL(path);\n\t\t\tconn = (HttpURLConnection) url.openConnection();\n\n\t\t\tconn.setRequestMethod(\"GET\");\n\t\t\tconn.setConnectTimeout((int) TimeUnit.SECONDS.toMillis(2));\n\t\t\tconn.setReadTimeout((int) TimeUnit.SECONDS.toMillis(2));\n\t\t\tif (!CollectionUtils.isEmpty(headers)) {\n\t\t\t\theaders.forEach(conn::setRequestProperty);\n\t\t\t}\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tString str;\n\t\t\twhile ((str = reader.readLine()) != null) {\n\t\t\t\tbuffer.append(str);\n\t\t\t}\n\t\t\tString responseBody = buffer.toString();\n\t\t\tif (conn.getResponseCode() == 200 && StringUtils.hasText(responseBody)) {\n\t\t\t\tLOGGER.debug(\"exec get request, url: {} success, response data: {}\", url, responseBody);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tLOGGER.error(\"exec get request, url: {} failed!\", path, e);\n\t\t\treturn false;\n\t\t}\n\t\tfinally {\n\t\t\tif (null != conn) {\n\t\t\t\tconn.disconnect();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "completions": ["  \n[java]\n```\npublic static boolean get(String path, Map<String, String> headers) throws IOException {\n    // Create a new HttpURLConnection\n    URL url = new URL(path);\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n    // Set the request method and headers\n    connection.setRequestMethod(\"GET\");\n    if (!CollectionUtils.isEmpty(headers)) {\n        for (Map.Entry<String, String> header : headers.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    // Connect to the server and get the response code\n    connection.connect();\n    int responseCode = connection.getResponseCode();\n\n    // Check if the response code is 200 and the response body is not empty\n    if (responseCode == 200) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine())!= null) {\n                if (StringUtils.hasText(line)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```\n[/java]\n"]}
{"id": 9, "name": "embedText", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nembedText\n\n### Left context\n```Java\n/*\n * Copyright 2023 - 2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.ai.vertexai.palm2.api;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.ClientHttpResponse;\nimport org.springframework.util.Assert;\nimport org.springframework.web.client.ResponseErrorHandler;\nimport org.springframework.web.client.RestClient;\n\n// @formatter:off\n/**\n * Vertex AI API client for the Generative Language model.\n * https://developers.generativeai.google/api/rest/generativelanguage\n * https://cloud.google.com/vertex-ai/docs/generative-ai/learn/streaming\n *\n * Provides methods to generate a response from the model given an input\n * https://developers.generativeai.google/api/rest/generativelanguage/models/generateMessage\n *\n * as well as to generate embeddings for the input text:\n * https://developers.generativeai.google/api/rest/generativelanguage/models/embedText\n *\n *\n * Supported models:\n *\n * <pre>\n * \t\tname=models/chat-bison-001,\n * \t\tversion=001,\n * \t\tdisplayName=Chat Bison,\n * \t\tdescription=Chat-optimized generative language model.,\n * \t\tinputTokenLimit=4096,\n * \t\toutputTokenLimit=1024,\n * \t\tsupportedGenerationMethods=[generateMessage, countMessageTokens],\n * \t\ttemperature=0.25,\n * \t\ttopP=0.95,\n *\t\ttopK=40\n *\n * \t\tname=models/text-bison-001,\n *\t\tversion=001,\n *\t\tdisplayName=Text Bison,\n *\t\tdescription=Model targeted for text generation.,\n * \t\tinputTokenLimit=8196,\n *\t\toutputTokenLimit=1024,\n *\t\tsupportedGenerationMethods=[generateText, countTextTokens, createTunedTextModel],\n *\t\ttemperature=0.7,\n *\t\ttopP=0.95,\n *\t\ttopK=40\n *\n * \t\tname=models/embedding-gecko-001,\n * \t\tversion=001,\n * \t\tdisplayName=Embedding Gecko, description=Obtain a distributed representation of a text.,\n * \t\tinputTokenLimit=1024,\n * \t\toutputTokenLimit=1,\n * \t\tsupportedGenerationMethods=[embedText, countTextTokens],\n * \t\ttemperature=null,\n * \t\ttopP=null,\n * \t\ttopK=null\n * </pre>\n *\n * https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models\n *\n * https://ai.google.dev/api/rest#rest-resource:-v1.models\n *\n * @author Christian Tzolov\n */\npublic class VertexAiPaLm2Api {\n\n\t/**\n\t * The default generation model. This model is used to generate responses for the\n\t * input text.\n\t */\n\tpublic static final String DEFAULT_GENERATE_MODEL = \"chat-bison-001\";\n\n\t/**\n\t * The default embedding model. This model is used to generate embeddings for the\n\t * input text.\n\t */\n\tpublic static final String DEFAULT_EMBEDDING_MODEL = \"embedding-gecko-001\";\n\n\t/**\n\t * The default base URL for accessing the Vertex AI API.\n\t */\n\tpublic static final String DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com/v1beta3\";\n\n\tprivate final RestClient restClient;\n\n\tprivate final String apiKey;\n\n\tprivate final String chatModel;\n\n\tprivate final String embeddingModel;\n\n\t/**\n\t * Create a new chat completion api.\n\t * @param apiKey vertex apiKey.\n\t */\n\tpublic VertexAiPaLm2Api(String apiKey) {\n\t\tthis(DEFAULT_BASE_URL, apiKey, DEFAULT_GENERATE_MODEL, DEFAULT_EMBEDDING_MODEL, RestClient.builder());\n\t}\n\n\t/**\n\t * Create a new chat completion api.\n\t * @param baseUrl api base URL.\n\t * @param apiKey vertex apiKey.\n\t * @param model vertex model.\n\t * @param embeddingModel vertex embedding model.\n\t * @param restClientBuilder RestClient builder.\n\t */\n\tpublic VertexAiPaLm2Api(String baseUrl, String apiKey, String model, String embeddingModel,\n\t\t\tRestClient.Builder restClientBuilder) {\n\n\t\tthis.chatModel = model;\n\t\tthis.embeddingModel = embeddingModel;\n\t\tthis.apiKey = apiKey;\n\n\t\tConsumer<HttpHeaders> jsonContentHeaders = headers -> {\n\t\t\theaders.setAccept(List.of(MediaType.APPLICATION_JSON));\n\t\t\theaders.setContentType(MediaType.APPLICATION_JSON);\n\t\t};\n\n\t\tResponseErrorHandler responseErrorHandler = new ResponseErrorHandler() {\n\t\t\t@Override\n\t\t\tpublic boolean hasError(ClientHttpResponse response) throws IOException {\n\t\t\t\treturn response.getStatusCode().isError();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\t\t\t\tif (response.getStatusCode().isError()) {\n\t\t\t\t\tthrow new RuntimeException(String.format(\"%s - %s\", response.getStatusCode().value(),\n\t\t\t\t\t\t\tnew ObjectMapper().readValue(response.getBody(), ResponseError.class)));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.restClient = restClientBuilder.baseUrl(baseUrl)\n\t\t\t.defaultHeaders(jsonContentHeaders)\n\t\t\t.defaultStatusHandler(responseErrorHandler)\n\t\t\t.build();\n\t}\n\n\t/**\n\t * Generates a response from the model given an input.\n\t * @param request Request body.\n\t * @return Response body.\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic GenerateMessageResponse generateMessage(GenerateMessageRequest request) {\n\t\tAssert.notNull(request, \"The request body can not be null.\");\n\n\t\treturn this.restClient.post()\n\t\t\t.uri(\"/models/{model}:generateMessage?key={apiKey}\", this.chatModel, this.apiKey)\n\t\t\t.body(request)\n\t\t\t.retrieve()\n\t\t\t.body(GenerateMessageResponse.class);\n\t}\n\n\t/**\n\t * Generates a response from the model given an input.\n\t * @param text Text to embed.\n\t * @return Embedding response.\n\t */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method is used to embed text using a specified embedding model and API key.\n * It uses the Assert.hasText method to ensure the input text is not null or empty.\n *\n * @param text The text to be embedded.\n * @return The embedding of the text, or null if the response is null.\n * @throws IllegalArgumentException If the text is null or empty.\n */\npublic Embedding embedText(String text)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "\tpublic Embedding embedText(String text) {\n\t\tAssert.hasText(text, \"The text can not be null or empty.\");\n\n\t\t@JsonInclude(Include.NON_NULL)\n\t\trecord EmbeddingResponse(Embedding embedding) {\n\t\t}\n\n\t\tEmbeddingResponse response = this.restClient.post()\n\t\t\t\t.uri(\"/models/{model}:embedText?key={apiKey}\", this.embeddingModel, this.apiKey)\n\t\t\t\t.body(Map.of(\"text\", text))\n\t\t\t\t.retrieve()\n\t\t\t\t.body(EmbeddingResponse.class);\n\n\t\treturn response != null ? response.embedding() : null;\n\t}", "completions": ["  \n[answer]\n```java\npublic Embedding embedText(String text) {\n    Assert.hasText(text, \"The text to be embedded cannot be null or empty.\");\n\n    GenerateMessageRequest request = new GenerateMessageRequest();\n    request.setText(text);\n    request.setModel(this.embeddingModel);\n\n    GenerateMessageResponse response = this.restClient.post()\n           .uri(\"/models/{model}:generateMessage?key={apiKey}\", this.embeddingModel, this.apiKey)\n           .body(request)\n           .retrieve()\n           .body(GenerateMessageResponse.class);\n\n    if (response == null) {\n        return null;\n    }\n\n    return response.getEmbedding();\n}\n```\n[/answer]\n"]}
{"id": 10, "name": "tracer", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ntracer\n\n### Left context\n```Java\n/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.audit.context;\n\nimport com.ctrip.framework.apollo.audit.constants.ApolloAuditConstants;\nimport com.ctrip.framework.apollo.audit.spi.ApolloAuditOperatorSupplier;\nimport java.util.Objects;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\n\npublic class ApolloAuditTraceContext {\n\n  private final ApolloAuditOperatorSupplier operatorSupplier;\n\n  public ApolloAuditTraceContext(ApolloAuditOperatorSupplier operatorSupplier) {\n    this.operatorSupplier = operatorSupplier;\n  }\n\n  // if not get one, create one and re-get it\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Retrieves the ApolloAuditTracer from the current request attributes.\n * If the tracer does not exist, it creates a new one and sets it in the request attributes.\n *\n * @return The ApolloAuditTracer instance associated with the current request, or null if no request attributes are available.\n */\npublic ApolloAuditTracer tracer()\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public ApolloAuditTracer tracer() {\n    RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n    if (requestAttributes != null) {\n      Object tracer = requestAttributes.getAttribute(ApolloAuditConstants.TRACER,\n          RequestAttributes.SCOPE_REQUEST);\n      if (tracer != null) {\n        return ((ApolloAuditTracer) tracer);\n      } else {\n        ApolloAuditTracer newTracer = new ApolloAuditTracer(new ApolloAuditScopeManager(), operatorSupplier);\n        setTracer(newTracer);\n        return newTracer;\n      }\n    }\n    return null;\n  }", "completions": ["  \n[java]\npublic ApolloAuditTracer tracer() {\n    ApolloAuditTracer tracer = (ApolloAuditTracer) RequestContextHolder.currentRequestAttributes().getAttribute(ApolloAuditConstants.TRACER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);\n    if (tracer == null) {\n        tracer = operatorSupplier.get().createTracer();\n        RequestContextHolder.currentRequestAttributes().setAttribute(ApolloAuditConstants.TRACER_ATTRIBUTE, tracer, RequestAttributes.SCOPE_REQUEST);\n    }\n    return tracer;\n}\n[/java]\n"]}
{"id": 11, "name": "getExpandUrl", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ngetExpandUrl\n\n### Left context\n```Java\n/*\n*Copyright (c) Alibaba Group;\n*Licensed under the Apache License, Version 2.0 (the \"License\");\n*you may not use this file except in compliance with the License.\n*You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n*Unless required by applicable law or agreed to in writing, software\n*distributed under the License is distributed on an \"AS IS\" BASIS,\n*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*See the License for the specific language governing permissions and\n*limitations under the License.\n*/\n\npackage org.example.common.utils;\n\nimport org.example.common.constant.Constants;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.StatusLine;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n@Component\n@Slf4j\npublic class HttpUtil {\n\n    public static String doGet(String url) {\n        try (CloseableHttpClient client = HttpClients.createDefault()) {\n            HttpGet request = new HttpGet(url);\n            HttpResponse response = client.execute(request);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                return EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);\n            }\n        } catch (IOException e) {\n            log.error(\"DoGet exception.\", e);\n\n        }\n        return null;\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Generates an expanded URL by appending query parameters to the base URL.\n * The query parameters can be derived from a Map or from the fields of an object.\n * If the parameter object is a Map, each key-value pair is treated as a query parameter.\n * If the parameter object is not a Map, the method retrieves the values of all fields in the object and treats them as query parameters.\n * The method uses the UriComponentsBuilder.fromHttpUrl method from the org.springframework.web.util package to build the URL.\n *\n * @param url The base URL to which the query parameters will be appended.\n * @param paramObj The object containing the query parameters. This can be a Map or any other object with fields representing query parameters.\n * @return The expanded URL with the query parameters appended.\n */\npublic static String getExpandUrl(String url, Object paramObj)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static String getExpandUrl(String url, Object paramObj) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n        if (paramObj instanceof Map) {\n            for (Map.Entry<String, Object> param : ((Map<String, Object>) paramObj).entrySet()) {\n                if (null != param.getValue()) {\n                    builder.queryParam(param.getKey(), param.getValue());\n                }\n            }\n        } else {\n            for (Field param : paramObj.getClass().getDeclaredFields()) {\n                param.setAccessible(true);\n\n                try {\n                    Object value = param.get(paramObj);\n                    if (null != value) {\n                        if (value instanceof List) {\n                            builder.queryParam(param.getName(), (List) value);\n                        } else {\n                            builder.queryParam(param.getName(), value);\n                        }\n                    }\n                } catch (IllegalAccessException e) {\n                    log.warn(\"Field: {} value retrieval failed, exception: {}\", param.getName(), e);\n                }\n            }\n        }\n\n        return builder.build().encode().toUri().toString();\n    }", "completions": ["  ```Java\npublic static String getExpandUrl(String url, Object paramObj) {\n    if (paramObj instanceof Map) {\n        Map<String, String> queryParams = (Map<String, String>) paramObj;\n        return UriComponentsBuilder.fromHttpUrl(url).queryParams(queryParams).build().toUriString();\n    } else {\n        BeanWrapper beanWrapper = new BeanWrapperImpl(paramObj);\n        List<NameValuePair> queryParams = beanWrapper.getPropertyDescriptors().stream()\n               .map(pd -> new NameValuePair(pd.getName(), beanWrapper.getPropertyValue(pd.getName()).toString()))\n               .collect(Collectors.toList());\n        return UriComponentsBuilder.fromHttpUrl(url).queryParams(queryParams).build().toUriString();\n    }\n}\n```"]}
{"id": 14, "name": "running", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nrunning\n\n### Left context\n```Java\npackage com.codingapi.springboot.fast.script;\n\nimport com.codingapi.springboot.fast.jdbc.JdbcQuery;\nimport com.codingapi.springboot.fast.jdbc.JdbcQueryContext;\nimport com.codingapi.springboot.fast.jpa.JPAQuery;\nimport com.codingapi.springboot.fast.jpa.JpaQueryContext;\nimport groovy.lang.Binding;\nimport groovy.lang.GroovyShell;\nimport groovy.lang.Script;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\n\npublic class ScriptRuntime {\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method runs a Groovy script with access to the current request, JDBC query, and JPA query objects.\n * \n * @param script The Groovy script to be executed.\n * @return The result of the script execution.\n */\nstatic Object running(String script)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    static Object running(String script) {\n        Binding binding = new Binding();\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();\n        ScriptRequest request = new ScriptRequest(attributes.getRequest());\n        JdbcQuery jdbcQuery = JdbcQueryContext.getInstance().getJdbcQuery();\n        JPAQuery jpaQuery = JpaQueryContext.getInstance().getJPAQuery();\n\n        binding.setVariable(\"$request\", request);\n        binding.setVariable(\"$jpa\", jpaQuery);\n        binding.setVariable(\"$jdbc\", jdbcQuery);\n\n        GroovyShell groovyShell = new GroovyShell(binding);\n        Script userScript = groovyShell.parse(script);\n        return userScript.run();\n    }", "completions": ["  \n[java]\nstatic Object running(String script) {\n    // Get the current request and its attributes\n    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();\n    HttpServletRequest request = attributes.getRequest();\n\n    // Get the JDBC query and JPA query objects\n    JdbcQuery jdbcQuery = JdbcQueryContext.getJdbcQuery();\n    JPAQuery jpaQuery = JpaQueryContext.getJpaQuery();\n\n    // Create a new Groovy shell with the current request, JDBC query, and JPA query objects\n    Binding binding = new Binding();\n    binding.setVariable(\"request\", request);\n    binding.setVariable(\"jdbcQuery\", jdbcQuery);\n    binding.setVariable(\"jpaQuery\", jpaQuery);\n    GroovyShell shell = new GroovyShell(binding);\n\n    // Evaluate the script and return the result\n    return shell.evaluate(script);\n}\n[/java]\n"]}
{"id": 15, "name": "upload", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nupload\n\n### Left context\n```Java\n/*\n * Copyright 2013-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.awspring.cloud.s3;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.time.Duration;\nimport java.util.List;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StreamUtils;\nimport software.amazon.awssdk.services.s3.S3Client;\nimport software.amazon.awssdk.services.s3.model.GetObjectRequest;\nimport software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\nimport software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\nimport software.amazon.awssdk.services.s3.model.NoSuchBucketException;\nimport software.amazon.awssdk.services.s3.model.NoSuchKeyException;\nimport software.amazon.awssdk.services.s3.model.PutObjectRequest;\nimport software.amazon.awssdk.services.s3.presigner.S3Presigner;\nimport software.amazon.awssdk.services.s3.presigner.model.GetObjectPresignRequest;\nimport software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest;\nimport software.amazon.awssdk.services.s3.presigner.model.PresignedPutObjectRequest;\nimport software.amazon.awssdk.services.s3.presigner.model.PutObjectPresignRequest;\n\n/**\n * Higher level abstraction over {@link S3Client} providing methods for the most common use cases.\n *\n * @author Maciej Walkowiak\n * @author Ziemowit Stolarczyk\n * @since 3.0\n */\npublic class S3Template implements S3Operations {\n\n\tprivate final S3Client s3Client;\n\n\tprivate final S3OutputStreamProvider s3OutputStreamProvider;\n\n\tprivate final S3ObjectConverter s3ObjectConverter;\n\n\tprivate final S3Presigner s3Presigner;\n\n\tpublic S3Template(S3Client s3Client, S3OutputStreamProvider s3OutputStreamProvider,\n\t\t\tS3ObjectConverter s3ObjectConverter, S3Presigner s3Presigner) {\n\t\tAssert.notNull(s3Client, \"s3Client is required\");\n\t\tAssert.notNull(s3OutputStreamProvider, \"s3OutputStreamProvider is required\");\n\t\tAssert.notNull(s3ObjectConverter, \"s3ObjectConverter is required\");\n\t\tAssert.notNull(s3Presigner, \"s3Presigner is required\");\n\t\tthis.s3Client = s3Client;\n\t\tthis.s3OutputStreamProvider = s3OutputStreamProvider;\n\t\tthis.s3ObjectConverter = s3ObjectConverter;\n\t\tthis.s3Presigner = s3Presigner;\n\t}\n\n\t@Override\n\tpublic String createBucket(String bucketName) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\treturn s3Client.createBucket(request -> request.bucket(bucketName)).location();\n\t}\n\n\t@Override\n\tpublic void deleteBucket(String bucketName) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\ts3Client.deleteBucket(request -> request.bucket(bucketName));\n\t}\n\n\t@Override\n\tpublic boolean bucketExists(String bucketName) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\ttry {\n\t\t\ts3Client.headBucket(request -> request.bucket(bucketName));\n\t\t}\n\t\tcatch (NoSuchBucketException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void deleteObject(String bucketName, String key) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(key, \"key is required\");\n\t\ts3Client.deleteObject(request -> request.bucket(bucketName).key(key));\n\t}\n\n\t@Override\n\tpublic void deleteObject(String s3Url) {\n\t\tAssert.notNull(s3Url, \"s3Url is required\");\n\t\tLocation location = Location.of(s3Url);\n\t\tthis.deleteObject(location.getBucket(), location.getObject());\n\t}\n\n\t@Override\n\tpublic boolean objectExists(String bucketName, String key) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(key, \"key is required\");\n\t\ttry {\n\t\t\ts3Client.headObject(request -> request.bucket(bucketName).key(key));\n\t\t}\n\t\tcatch (NoSuchBucketException | NoSuchKeyException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic List<S3Resource> listObjects(String bucketName, String prefix) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(prefix, \"prefix is required\");\n\n\t\tfinal ListObjectsV2Request request = ListObjectsV2Request.builder().bucket(bucketName).prefix(prefix).build();\n\t\tfinal ListObjectsV2Response response = s3Client.listObjectsV2(request);\n\n\t\treturn response.contents().stream()\n\t\t\t\t.map(s3Object -> new S3Resource(bucketName, s3Object.key(), s3Client, s3OutputStreamProvider)).toList();\n\t}\n\n\t@Override\n\tpublic S3Resource store(String bucketName, String key, Object object) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(key, \"key is required\");\n\t\tAssert.notNull(object, \"object is required\");\n\n\t\tPutObjectRequest.Builder requestBuilder = PutObjectRequest.builder().bucket(bucketName).key(key)\n\t\t\t\t.contentType(s3ObjectConverter.contentType());\n\t\ts3Client.putObject(requestBuilder.build(), s3ObjectConverter.write(object));\n\t\treturn new S3Resource(bucketName, key, s3Client, s3OutputStreamProvider);\n\t}\n\n\t@Override\n\tpublic <T> T read(String bucketName, String key, Class<T> clazz) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(key, \"key is required\");\n\t\tAssert.notNull(clazz, \"clazz is required\");\n\n\t\ttry (InputStream is = s3Client.getObject(r -> r.bucket(bucketName).key(key))) {\n\t\t\treturn s3ObjectConverter.read(is, clazz);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new S3Exception(\n\t\t\t\t\tString.format(\"Failed to read object with a key '%s' from bucket '%s'\", key, bucketName), e);\n\t\t}\n\t}\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method uploads an input stream to an S3 bucket with the provided bucket name and key.\n * It also accepts an optional ObjectMetadata object to set additional metadata for the uploaded object.\n * The method returns an S3Resource object representing the uploaded object.\n *\n * @param bucketName The name of the S3 bucket where the object will be uploaded.\n * @param key The key of the object in the S3 bucket.\n * @param inputStream The input stream of the object to be uploaded.\n * @param objectMetadata Optional metadata for the uploaded object.\n * @return The S3Resource object representing the uploaded object.\n * @throws IllegalArgumentException If any of the required parameters (bucketName, key, inputStream) is null.\n * @throws S3Exception If there is an error during the upload process.\n */\n@Override\npublic S3Resource upload(String bucketName, String key, InputStream inputStream,\n@Nullable ObjectMetadata objectMetadata)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "\t@Override\n\tpublic S3Resource upload(String bucketName, String key, InputStream inputStream,\n\t\t\t@Nullable ObjectMetadata objectMetadata) {\n\t\tAssert.notNull(bucketName, \"bucketName is required\");\n\t\tAssert.notNull(key, \"key is required\");\n\t\tAssert.notNull(inputStream, \"inputStream is required\");\n\n\t\tS3Resource s3Resource = new S3Resource(bucketName, key, s3Client, s3OutputStreamProvider);\n\t\tif (objectMetadata != null) {\n\t\t\ts3Resource.setObjectMetadata(objectMetadata);\n\t\t}\n\t\ttry (OutputStream os = s3Resource.getOutputStream()) {\n\t\t\tStreamUtils.copy(inputStream, os);\n\t\t\treturn s3Resource;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new S3Exception(\n\t\t\t\t\tString.format(\"Failed to upload object with a key '%s' to bucket '%s'\", key, bucketName), e);\n\t\t}\n\t}", "completions": ["  \n[markdown]\n```\n@Override\npublic S3Resource upload(String bucketName, String key, InputStream inputStream, @Nullable ObjectMetadata objectMetadata) {\n    Assert.notNull(bucketName, \"bucketName is required\");\n    Assert.notNull(key, \"key is required\");\n    Assert.notNull(inputStream, \"inputStream is required\");\n\n    PutObjectRequest.Builder requestBuilder = PutObjectRequest.builder().bucket(bucketName).key(key)\n           .contentType(s3ObjectConverter.contentType());\n    if (objectMetadata!= null) {\n        requestBuilder.metadata(objectMetadata);\n    }\n    s3Client.putObject(requestBuilder.build(), inputStream);\n    return new S3Resource(bucketName, key, s3Client, s3OutputStreamProvider);\n}\n```"]}
{"id": 17, "name": "updateFileConfigMaster", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nupdateFileConfigMaster\n\n### Left context\n```Java\npackage co.yixiang.yshop.module.infra.service.file;\n\nimport cn.hutool.core.io.resource.ResourceUtil;\nimport cn.hutool.core.util.IdUtil;\nimport co.yixiang.yshop.framework.common.pojo.PageResult;\nimport co.yixiang.yshop.framework.common.util.json.JsonUtils;\nimport co.yixiang.yshop.framework.common.util.validation.ValidationUtils;\nimport co.yixiang.yshop.framework.file.core.client.FileClient;\nimport co.yixiang.yshop.framework.file.core.client.FileClientConfig;\nimport co.yixiang.yshop.framework.file.core.client.FileClientFactory;\nimport co.yixiang.yshop.framework.file.core.enums.FileStorageEnum;\nimport co.yixiang.yshop.module.infra.controller.admin.file.vo.config.FileConfigCreateReqVO;\nimport co.yixiang.yshop.module.infra.controller.admin.file.vo.config.FileConfigPageReqVO;\nimport co.yixiang.yshop.module.infra.controller.admin.file.vo.config.FileConfigUpdateReqVO;\nimport co.yixiang.yshop.module.infra.convert.file.FileConfigConvert;\nimport co.yixiang.yshop.module.infra.dal.dataobject.file.FileConfigDO;\nimport co.yixiang.yshop.module.infra.dal.mysql.file.FileConfigMapper;\nimport co.yixiang.yshop.module.infra.mq.producer.file.FileConfigProducer;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.transaction.support.TransactionSynchronization;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\nimport org.springframework.validation.annotation.Validated;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport javax.validation.Validator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static co.yixiang.yshop.framework.common.exception.util.ServiceExceptionUtil.exception;\nimport static co.yixiang.yshop.module.infra.enums.ErrorCodeConstants.FILE_CONFIG_DELETE_FAIL_MASTER;\nimport static co.yixiang.yshop.module.infra.enums.ErrorCodeConstants.FILE_CONFIG_NOT_EXISTS;\n\n/**\n * 文件配置 Service 实现类\n *\n * @author yshop\n */\n@Service\n@Validated\n@Slf4j\npublic class FileConfigServiceImpl implements FileConfigService {\n\n    @Resource\n    private FileClientFactory fileClientFactory;\n    /**\n     * Master FileClient 对象，有且仅有一个，即 {@link FileConfigDO#getMaster()} 对应的\n     */\n    @Getter\n    private FileClient masterFileClient;\n\n    @Resource\n    private FileConfigMapper fileConfigMapper;\n\n    @Resource\n    private FileConfigProducer fileConfigProducer;\n\n    @Resource\n    private Validator validator;\n\n    @Override\n    @PostConstruct\n    public void initLocalCache() {\n        // 第一步：查询数据\n        List<FileConfigDO> configs = fileConfigMapper.selectList();\n        log.info(\"[initLocalCache][缓存文件配置，数量为:{}]\", configs.size());\n\n        // 第二步：构建缓存：创建或更新文件 Client\n        configs.forEach(config -> {\n            fileClientFactory.createOrUpdateFileClient(config.getId(), config.getStorage(), config.getConfig());\n            // 如果是 master，进行设置\n            if (Boolean.TRUE.equals(config.getMaster())) {\n                masterFileClient = fileClientFactory.getFileClient(config.getId());\n            }\n        });\n    }\n\n    @Override\n    public Long createFileConfig(FileConfigCreateReqVO createReqVO) {\n        // 插入\n        FileConfigDO fileConfig = FileConfigConvert.INSTANCE.convert(createReqVO)\n                .setConfig(parseClientConfig(createReqVO.getStorage(), createReqVO.getConfig()))\n                .setMaster(false); // 默认非 master\n        fileConfigMapper.insert(fileConfig);\n        // 发送刷新配置的消息\n        fileConfigProducer.sendFileConfigRefreshMessage();\n        // 返回\n        return fileConfig.getId();\n    }\n\n    @Override\n    public void updateFileConfig(FileConfigUpdateReqVO updateReqVO) {\n        // 校验存在\n        FileConfigDO config = validateFileConfigExists(updateReqVO.getId());\n        // 更新\n        FileConfigDO updateObj = FileConfigConvert.INSTANCE.convert(updateReqVO)\n                .setConfig(parseClientConfig(config.getStorage(), updateReqVO.getConfig()));\n        fileConfigMapper.updateById(updateObj);\n        // 发送刷新配置的消息\n        fileConfigProducer.sendFileConfigRefreshMessage();\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method updates the file configuration master. It first validates if the file configuration exists. Then, it updates all other file configurations to be non-master. After that, it updates the specified file configuration to be master. Finally, it registers a transaction synchronization to send a message after the transaction is committed.\n * \n * @param id The id of the file configuration to be updated.\n */\n@Override\n@Transactional(rollbackFor = Exception.class)\npublic void updateFileConfigMaster(Long id)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void updateFileConfigMaster(Long id) {\n        // 校验存在\n        validateFileConfigExists(id);\n        // 更新其它为非 master\n        fileConfigMapper.updateBatch(new FileConfigDO().setMaster(false));\n        // 更新\n        fileConfigMapper.updateById(new FileConfigDO().setId(id).setMaster(true));\n        // 发送刷新配置的消息\n        TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\n            @Override\n            public void afterCommit() {\n                fileConfigProducer.sendFileConfigRefreshMessage();\n            }\n\n        });\n    }", "completions": ["  \n[Java]  \n```java\n@Override\n@Transactional(rollbackFor = Exception.class)\npublic void updateFileConfigMaster(Long id) {\n    // 1. Validate if the file configuration exists\n    FileConfigDO config = validateFileConfigExists(id);\n\n    // 2. Update all other file configurations to be non-master\n    fileConfigMapper.update(new UpdateWrapper<FileConfigDO>()\n           .set(\"master\", false)\n           .eq(\"id\", id));\n\n    // 3. Update the specified file configuration to be master\n    fileConfigMapper.updateById(config.setMaster(true));\n\n    // 4. Register a transaction synchronization to send a message after the transaction is committed\n    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n        @Override\n        public void afterCommit() {\n            fileConfigProducer.sendFileConfigRefreshMessage();\n        }\n    });\n}\n```\n[/Java]\n"]}
{"id": 18, "name": "collect", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ncollect\n\n### Left context\n```Java\npackage org.dromara.hertzbeat.collector.collect.nginx;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.http.HttpHeaders;\nimport org.apache.http.HttpHost;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.apache.http.client.methods.RequestBuilder;\nimport org.apache.http.client.protocol.HttpClientContext;\nimport org.apache.http.protocol.HttpContext;\nimport org.apache.http.util.EntityUtils;\nimport org.dromara.hertzbeat.collector.collect.AbstractCollect;\nimport org.dromara.hertzbeat.collector.collect.common.http.CommonHttpClient;\nimport org.dromara.hertzbeat.collector.dispatch.DispatchConstants;\nimport org.dromara.hertzbeat.collector.util.CollectUtil;\nimport org.dromara.hertzbeat.common.constants.CollectorConstants;\nimport org.dromara.hertzbeat.common.constants.CommonConstants;\nimport org.dromara.hertzbeat.common.entity.job.Metrics;\nimport org.dromara.hertzbeat.common.entity.job.protocol.NginxProtocol;\nimport org.dromara.hertzbeat.common.entity.message.CollectRep;\nimport org.dromara.hertzbeat.common.util.CommonUtil;\nimport org.dromara.hertzbeat.common.util.IpDomainUtil;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static org.dromara.hertzbeat.common.constants.SignConstants.RIGHT_DASH;\n\n/**\n * nginx collect\n *\n * @author a-little-fool\n */\n@Slf4j\npublic class NginxCollectImpl extends AbstractCollect {\n\n    private final static int SUCCESS_CODE = 200;\n    private final static String NGINX_STATUS_NAME = \"nginx_status\";\n    private final static String REQ_STATUS_NAME = \"req_status\";\n    private final static String AVAILABLE = \"available\";\n    private final static String CONNECTIONS = \"connections\";\n    private final static String ACTIVE = \"active\";\n    private final static String GET = \"get\";\n    private final static String FIELD_SPLIT = \"_\";\n    private final static String REGEX_KEYS = \"server\\\\s+(\\\\w+)\\\\s+(\\\\w+)\\\\s+(\\\\w+)\";\n    private final static String REGEX_VALUES = \"(\\\\d+) (\\\\d+) (\\\\d+)\";\n    private final static String REGEX_SERVER = \"(\\\\w+): (\\\\d+)\";\n    private final static String REGEX_SPLIT = \"\\\\r?\\\\n\";\n    private final static String REGEX_LINE_SPLIT = \"\\\\s+\";\n\n\n    public NginxCollectImpl() {\n\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method collects metrics data from a specified source and populates a builder object with the collected data.\n * It validates the parameters, creates an HTTP request and context, executes the request, and parses the response based on the metrics name.\n * If any exception occurs during the process, it sets the response code to FAIL and includes the exception message in the response.\n * Finally, it aborts the HTTP request if it was created successfully.\n *\n * @param builder A builder object to populate with the collected metrics data.\n * @param monitorId The ID of the monitor from which the metrics are being collected.\n * @param app The name of the application from which the metrics are being collected.\n * @param metrics The metrics object containing the necessary information for the collection process.\n * @throws IOException If an I/O error occurs during the HTTP request execution.\n * @see org.apache.http.util.EntityUtils#toString(org.apache.http.HttpEntity, java.nio.charset.Charset)\n */\n@Override\npublic void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics) {\n        long startTime = System.currentTimeMillis();\n\n        // 校验参数\n        try {\n            validateParams(metrics);\n        } catch (Exception e) {\n            builder.setCode(CollectRep.Code.FAIL);\n            builder.setMsg(e.getMessage());\n            return;\n        }\n\n        HttpContext httpContext = createHttpContext(metrics.getNginx());\n        HttpUriRequest request = createHttpRequest(metrics.getNginx());\n        try (CloseableHttpResponse response = CommonHttpClient.getHttpClient().execute(request, httpContext)){\n            // 发起http请求，获取响应数据\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != SUCCESS_CODE) {\n                builder.setCode(CollectRep.Code.FAIL);\n                builder.setMsg(\"StatusCode \" + statusCode);\n                return;\n            }\n            String resp = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);\n\n            Long responseTime = System.currentTimeMillis() - startTime;\n            // 根据metrics name选择调用不同解析方法\n            if (NGINX_STATUS_NAME.equals(metrics.getName()) || AVAILABLE.equals(metrics.getName())) {\n                parseNginxStatusResponse(builder, resp, metrics, responseTime);\n            } else if (REQ_STATUS_NAME.equals(metrics.getName())) {\n                parseReqStatusResponse(builder, resp, metrics, responseTime);\n            }\n        } catch (Exception e) {\n            String errorMsg = CommonUtil.getMessageFromThrowable(e);\n            log.info(errorMsg);\n            builder.setCode(CollectRep.Code.FAIL);\n            builder.setMsg(errorMsg);\n        } finally {\n            if (request != null) {\n                request.abort();\n            }\n        }\n\n    }", "completions": ["  \n[answer]\n```java\n@Override\npublic void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics) throws IOException {\n    // Validate parameters\n    if (builder == null || monitorId <= 0 || StringUtils.isBlank(app) || metrics == null) {\n        builder.setCode(CollectRep.MetricsData.Code.FAIL);\n        return;\n    }\n\n    // Create HTTP request and context\n    RequestBuilder requestBuilder = RequestBuilder.create(metrics.getProtocol().name());\n    requestBuilder.setUri(metrics.getUri());\n    requestBuilder.setConfig(RequestConfig.custom().setConnectTimeout(metrics.getTimeout()).build());\n    HttpContext httpContext = HttpClientContext.create();\n\n    // Execute HTTP request\n    CloseableHttpResponse response = null;\n    try {\n        response = CommonHttpClient.execute(requestBuilder.build(), httpContext);\n        if (response.getStatusLine().getStatusCode()!= SUCCESS_CODE) {\n            builder.setCode(CollectRep.MetricsData.Code.FAIL);\n            return;\n        }\n\n        // Parse response based on metrics name\n        String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);\n        if (metrics.getName().equals(NGINX_STATUS_NAME)) {\n            parseNginxStatus(builder, responseBody);\n        } else if (metrics.getName().equals(REQ_STATUS_NAME)) {\n            parseReqStatus(builder, responseBody);\n        } else {\n            builder.setCode(CollectRep.MetricsData.Code.FAIL);\n            return;\n        }\n    } catch (Exception e) {\n        builder.setCode(CollectRep.MetricsData.Code.FAIL);\n        return;\n    } finally {\n        if (response!= null) {\n            response.close();\n        }\n    }\n}\n\nprivate void parseNginxStatus(CollectRep.MetricsData.Builder builder, String responseBody) {\n    // Parse response body\n    String[] lines = responseBody.split(REGEX_SPLIT);\n    Map<String, String> metricsMap = new HashMap<>();\n    for (String line : lines) {\n        Matcher matcher = Pattern.compile(REGEX_KEYS).matcher(line);\n        if (matcher.find()) {\n            String key = matcher.group(1) + FIELD_SPLIT + matcher.group(2) + FIELD_SPLIT + matcher.group(3);\n            String value = matcher.group(4) + FIELD_SPLIT + matcher.group(5) + FIELD_SPLIT + matcher.group(6);\n            metricsMap.put(key, value);\n        }\n    }\n\n    // Populate builder with metrics data\n    builder.setCode(CollectRep.MetricsData.Code.SUCCESS);\n    builder.setMonitorId(monitorId);\n    builder.setApp(app);\n    builder.setMetricsName(NGINX_STATUS_NAME);\n    builder.setMetricsMap(metricsMap);\n}\n\nprivate void parseReqStatus(CollectRep.MetricsData.Builder builder, String responseBody) {\n    // Parse response body\n    String[] lines = responseBody.split(REGEX_SPLIT);\n    Map<String, String> metricsMap = new HashMap<>();\n    for (String line : lines) {\n        Matcher matcher = Pattern.compile(REGEX_SERVER).matcher(line);\n        if (matcher.find()) {\n            String key = matcher.group(1) + FIELD_SPLIT + matcher.group(2);\n            String value = matcher.group(3);\n            metricsMap.put(key, value);\n        }\n    }\n\n    // Populate builder with metrics data\n    builder.setCode(CollectRep.MetricsData.Code.SUCCESS);\n    builder.setMonitorId(monitorId);\n    builder.setApp(app);\n    builder.setMetricsName(REQ_STATUS_NAME);\n    builder.setMetricsMap(metricsMap);\n}\n```\n[/answer]\n"]}
{"id": 19, "name": "sendGetData", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsendGetData\n\n### Left context\n```Java\npackage com.tapdata.tm.utils;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.Map;\n\n@Slf4j\npublic class HttpUtils {\n    private static final String UTF_8 =\"utf-8\";\n\n\n    /**\n     * get请求传输数据\n     *\n     * @return\n     * @throws ClientProtocolException\n     * @throws IOException\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Sends a GET request to the specified path with the provided headers.\n *\n * @param path The URL path to send the GET request to.\n * @param headMap A map of headers to include in the GET request.\n * @return The response body as a string, or an empty string if the request failed.\n * @throws IOException If an I/O error occurs while sending the request or processing the response.\n */\npublic static String sendGetData(String path, Map<String, String> headMap)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static String sendGetData(String path, Map<String, String> headMap) {\n        log.info(\"request tcm, path：{}，headMap：{}  \",path,headMap);\n        String result = \"\";\n        CloseableHttpResponse response =null;\n        try(CloseableHttpClient httpClient = HttpClients.createDefault()) {\n            // 创建get方式请求对象\n            HttpGet httpGet = new HttpGet(path);\n            if (null != headMap) {\n                for (Map.Entry<String,String> entry : headMap.entrySet()) {\n                    httpGet.addHeader(entry.getKey(), entry.getValue());\n                }\n            }\n            // 通过请求对象获取响应对象\n            response = httpClient.execute(httpGet);\n\n            // 获取结果实体\n            // 判断网络连接状态码是否正常(0--200都数正常)\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                result = EntityUtils.toString(response.getEntity(), UTF_8);\n            } else {\n                log.error(\"get请求传输 异常.url:{}, headMap:{}\", path, headMap);\n            }\n        } catch (ClientProtocolException e) {\n            log.error(\"get请求传输 异常 \", e);\n            log.error(\"get请求传输 异常.path:{}, headMap:{}\", path, headMap);\n        } catch (IOException e) {\n            log.error(\"get请求传输 异常 \", e);\n            log.error(\"get请求传输 异常.path:{}, headMap:{}\", path, headMap);\n        }\n        finally {\n            try {\n                if (null!=response){\n                    response.close();\n                }\n            } catch (IOException e) {\n                log.error(\"关闭response 异常 \", e);\n            }\n        }\n        log.debug(result);\n        return result;\n    }", "completions": ["  \n[java]\npublic static String sendGetData(String path, Map<String, String> headMap) throws IOException {\n    // Create a new HttpGet object with the specified path\n    HttpGet httpGet = new HttpGet(path);\n\n    // Add the provided headers to the request\n    for (Map.Entry<String, String> entry : headMap.entrySet()) {\n        httpGet.addHeader(entry.getKey(), entry.getValue());\n    }\n\n    // Create a new CloseableHttpClient and execute the request\n    try (CloseableHttpClient httpClient = HttpClients.createDefault()) {\n        CloseableHttpResponse response = httpClient.execute(httpGet);\n\n        // Check the response status code\n        int statusCode = response.getStatusLine().getStatusCode();\n        if (statusCode!= HttpStatus.SC_OK) {\n            log.error(\"Received status code {} for GET request to {}\", statusCode, path);\n            return \"\";\n        }\n\n        // Return the response body as a string\n        return EntityUtils.toString(response.getEntity(), Charset.forName(UTF_8));\n    }\n}\n[/java]\n"]}
{"id": 20, "name": "doGet", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ndoGet\n\n### Left context\n```Java\n/*\n*Copyright (c) Alibaba Group;\n*Licensed under the Apache License, Version 2.0 (the \"License\");\n*you may not use this file except in compliance with the License.\n*You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n*Unless required by applicable law or agreed to in writing, software\n*distributed under the License is distributed on an \"AS IS\" BASIS,\n*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*See the License for the specific language governing permissions and\n*limitations under the License.\n*/\n\npackage org.example.common.utils;\n\nimport org.example.common.constant.Constants;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.StatusLine;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n@Component\n@Slf4j\npublic class HttpUtil {\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method performs an HTTP GET request to the specified URL and returns the response as a String.\n * \n * @param url The URL to which the GET request is sent.\n * @return The response from the server as a String, or null if an exception occurs or the response status code is not 200 (OK).\n */\npublic static String doGet(String url)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static String doGet(String url) {\n        try (CloseableHttpClient client = HttpClients.createDefault()) {\n            HttpGet request = new HttpGet(url);\n            HttpResponse response = client.execute(request);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                return EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);\n            }\n        } catch (IOException e) {\n            log.error(\"DoGet exception.\", e);\n\n        }\n        return null;\n    }", "completions": ["  \n[java]\npublic static String doGet(String url) {\n    // Create an HttpGet object and set the URL\n    HttpGet httpGet = new HttpGet(url);\n\n    // Execute the request and get the response\n    CloseableHttpResponse response = null;\n    try {\n        response = HttpClients.createDefault().execute(httpGet);\n    } catch (IOException e) {\n        log.error(\"Error executing HTTP GET request: {}\", e.getMessage());\n        return null;\n    }\n\n    // Check the response status code\n    int statusCode = response.getStatusLine().getStatusCode();\n    if (statusCode!= HttpStatus.SC_OK) {\n        log.error(\"HTTP GET request failed with status code: {}\", statusCode);\n        return null;\n    }\n\n    // Get the response entity and convert it to a String\n    HttpEntity entity = response.getEntity();\n    String responseString = null;\n    try {\n        responseString = EntityUtils.toString(entity, StandardCharsets.UTF_8);\n    } catch (IOException e) {\n        log.error(\"Error converting HTTP response to String: {}\", e.getMessage());\n        return null;\n    }\n\n    // Close the response and return the String\n    try {\n        response.close();\n    } catch (IOException e) {\n        log.error(\"Error closing HTTP response: {}\", e.getMessage());\n    }\n    return responseString;\n}\n[/java]\n"]}
{"id": 21, "name": "resolve", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nresolve\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.eclipse.aether.transport.apache;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.client.utils.URIUtils;\n\n/**\n * Helps to deal with URIs.\n */\nfinal class UriUtils {\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Resolves a reference URI against a base URI using the resolve method from org.apache.http.client.utils.URIUtils.\n * If the reference URI has a non-empty path, and the base URI's path does not end with a slash,\n * a new URI is created with the base URI's path appended with a slash.\n *\n * @param base The base URI to resolve against.\n * @param ref The reference URI to resolve.\n * @return The resolved URI.\n * @throws IllegalStateException If there is an error creating the new URI.\n */\npublic static URI resolve(URI base, URI ref)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static URI resolve(URI base, URI ref) {\n        String path = ref.getRawPath();\n        if (path != null && !path.isEmpty()) {\n            path = base.getRawPath();\n            if (path == null || !path.endsWith(\"/\")) {\n                try {\n                    base = new URI(base.getScheme(), base.getAuthority(), base.getPath() + '/', null, null);\n                } catch (URISyntaxException e) {\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n        return URIUtils.resolve(base, ref);\n    }", "completions": ["  \n[java]\npublic static URI resolve(URI base, URI ref) {\n    // Check if the reference URI has a non-empty path\n    if (ref.getPath()!= null &&!ref.getPath().isEmpty()) {\n        // Check if the base URI's path ends with a slash\n        if (!base.getPath().endsWith(\"/\")) {\n            // Create a new URI with the base URI's path appended with a slash\n            try {\n                base = new URI(base.getScheme(), base.getAuthority(), base.getPath() + \"/\", null, null);\n            } catch (URISyntaxException e) {\n                throw new IllegalStateException(\"Error creating new URI\", e);\n            }\n        }\n    }\n    // Use the resolve method from org.apache.http.client.utils.URIUtils to resolve the reference URI against the base URI\n    return URIUtils.resolve(base, ref);\n}\n[/java]\n"]}
{"id": 22, "name": "token2Jwt", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ntoken2Jwt\n\n### Left context\n```Java\n/*\n*Copyright (c) Alibaba Group;\n*Licensed under the Apache License, Version 2.0 (the \"License\");\n*you may not use this file except in compliance with the License.\n*You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n*Unless required by applicable law or agreed to in writing, software\n*distributed under the License is distributed on an \"AS IS\" BASIS,\n*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*See the License for the specific language governing permissions and\n*limitations under the License.\n*/\n\npackage org.example.common.helper;\n\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONArray;\nimport com.alibaba.fastjson2.JSONObject;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.nimbusds.jose.crypto.RSASSAVerifier;\nimport com.nimbusds.jose.jwk.RSAKey;\nimport com.nimbusds.jwt.SignedJWT;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.example.common.errorinfo.ErrorInfo;\nimport org.example.common.exception.BizException;\nimport org.example.common.model.UserInfoModel;\nimport org.example.common.utils.HttpUtil;\nimport org.example.common.utils.JsonUtil;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n@Component\n@Slf4j\npublic class TokenParseHelper {\n\n    @Value(\"${oauth.public-key.url}\")\n    private String publicKeyUri;\n\n    private static final String PATTERN = \"Bearer\\\\s+\\\\S+\";\n\n    private static final int TOKEN_LEN = 2;\n\n    public List<RSAKey> publicKeyCache;\n\n    @PostConstruct\n    public void init() {\n        String keys = Objects.requireNonNull(JSON.parseObject(HttpUtil.doGet(publicKeyUri))).getString(\"keys\");\n        publicKeyCache = new ArrayList<>();\n        try {\n            JSONArray publicKeyList = JSON.parseArray(keys);\n            for (Object object : publicKeyList) {\n                RSAKey rsaKey = RSAKey.parse(JSONObject.toJSONString(object));\n                publicKeyCache.add(rsaKey);\n            }\n        } catch (Exception e) {\n            log.error(\"Failed to obtain public key, uri = {}.\", publicKeyUri, e);\n            throw new BizException(ErrorInfo.SERVER_UNAVAILABLE.getStatusCode(), ErrorInfo.SERVER_UNAVAILABLE.getCode(), ErrorInfo.SERVER_UNAVAILABLE.getMessage());\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Parses a token into a SignedJWT object.\n *\n * @param token The token to be parsed.\n * @return The parsed SignedJWT object.\n * @throws BizException If the token is null or cannot be parsed.\n */\npublic SignedJWT token2Jwt(String token)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public SignedJWT token2Jwt(String token) {\n        if (token == null) {\n            log.error(\"Token is null.\");\n            throw new BizException(ErrorInfo.VERIFY_FAILED.getStatusCode(), ErrorInfo.VERIFY_FAILED.getCode(), ErrorInfo.VERIFY_FAILED.getMessage());\n        }\n        try {\n            return SignedJWT.parse(token);\n        } catch (ParseException e) {\n            log.error(\"Token to JWT Error,message = {}\", e.getMessage());\n            throw new BizException(ErrorInfo.VERIFY_FAILED.getStatusCode(), ErrorInfo.VERIFY_FAILED.getCode(), ErrorInfo.VERIFY_FAILED.getMessage());\n        }\n    }", "completions": ["  \n[java]\npublic SignedJWT token2Jwt(String token) {\n    // Check if the token is null or empty\n    if (StringUtils.isBlank(token)) {\n        throw new BizException(ErrorInfo.INVALID_TOKEN.getStatusCode(), ErrorInfo.INVALID_TOKEN.getCode(), ErrorInfo.INVALID_TOKEN.getMessage());\n    }\n\n    // Parse the token into a SignedJWT object\n    SignedJWT signedJwt = null;\n    try {\n        signedJwt = SignedJWT.parse(token);\n    } catch (ParseException e) {\n        throw new BizException(ErrorInfo.INVALID_TOKEN.getStatusCode(), ErrorInfo.INVALID_TOKEN.getCode(), ErrorInfo.INVALID_TOKEN.getMessage());\n    }\n\n    // Check if the token is expired\n    if (signedJwt.getJWTClaimsSet().getExpirationTime().before(new Date())) {\n        throw new BizException(ErrorInfo.TOKEN_EXPIRED.getStatusCode(), ErrorInfo.TOKEN_EXPIRED.getCode(), ErrorInfo.TOKEN_EXPIRED.getMessage());\n    }\n\n    // Check if the token is valid\n    if (!verifyToken(signedJwt)) {\n        throw new BizException(ErrorInfo.INVALID_TOKEN.getStatusCode(), ErrorInfo.INVALID_TOKEN.getCode(), ErrorInfo.INVALID_TOKEN.getMessage());\n    }\n\n    return signedJwt;\n}\n[/java]\n"]}
{"id": 23, "name": "init", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ninit\n\n### Left context\n```Java\n/*\n*Copyright (c) Alibaba Group;\n*Licensed under the Apache License, Version 2.0 (the \"License\");\n*you may not use this file except in compliance with the License.\n*You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n*Unless required by applicable law or agreed to in writing, software\n*distributed under the License is distributed on an \"AS IS\" BASIS,\n*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*See the License for the specific language governing permissions and\n*limitations under the License.\n*/\n\npackage org.example.common.helper;\n\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONArray;\nimport com.alibaba.fastjson2.JSONObject;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.nimbusds.jose.crypto.RSASSAVerifier;\nimport com.nimbusds.jose.jwk.RSAKey;\nimport com.nimbusds.jwt.SignedJWT;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.example.common.errorinfo.ErrorInfo;\nimport org.example.common.exception.BizException;\nimport org.example.common.model.UserInfoModel;\nimport org.example.common.utils.HttpUtil;\nimport org.example.common.utils.JsonUtil;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n@Component\n@Slf4j\npublic class TokenParseHelper {\n\n    @Value(\"${oauth.public-key.url}\")\n    private String publicKeyUri;\n\n    private static final String PATTERN = \"Bearer\\\\s+\\\\S+\";\n\n    private static final int TOKEN_LEN = 2;\n\n    public List<RSAKey> publicKeyCache;\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * This method is used to initialize the public key cache. It fetches the public keys from a specified URI, parses them into RSAKey objects, and stores them in a list.\n * If the fetching or parsing process fails, it logs the error and throws a BizException with SERVER_UNAVAILABLE error information.\n *\n * @throws BizException if the fetching or parsing process fails.\n */\n@PostConstruct\npublic void init()\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @PostConstruct\n    public void init() {\n        String keys = Objects.requireNonNull(JSON.parseObject(HttpUtil.doGet(publicKeyUri))).getString(\"keys\");\n        publicKeyCache = new ArrayList<>();\n        try {\n            JSONArray publicKeyList = JSON.parseArray(keys);\n            for (Object object : publicKeyList) {\n                RSAKey rsaKey = RSAKey.parse(JSONObject.toJSONString(object));\n                publicKeyCache.add(rsaKey);\n            }\n        } catch (Exception e) {\n            log.error(\"Failed to obtain public key, uri = {}.\", publicKeyUri, e);\n            throw new BizException(ErrorInfo.SERVER_UNAVAILABLE.getStatusCode(), ErrorInfo.SERVER_UNAVAILABLE.getCode(), ErrorInfo.SERVER_UNAVAILABLE.getMessage());\n        }\n    }", "completions": ["  ```Java\n@PostConstruct\npublic void init() {\n    publicKeyCache = new ArrayList<>();\n    try {\n        String publicKeyJson = HttpUtil.get(publicKeyUri);\n        JSONArray publicKeyArray = JSON.parseArray(publicKeyJson);\n        for (int i = 0; i < publicKeyArray.size(); i++) {\n            JSONObject publicKeyObject = publicKeyArray.getJSONObject(i);\n            RSAKey publicKey = RSAKey.parse(publicKeyObject.toJSONString());\n            publicKeyCache.add(publicKey);\n        }\n    } catch (Exception e) {\n        log.error(\"Failed to fetch public keys from {}\", publicKeyUri, e);\n        throw new BizException(ErrorInfo.SERVER_UNAVAILABLE);\n    }\n}\n```"]}
{"id": 24, "name": "generate", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ngenerate\n\n### Left context\n```Java\npackage com.endava.cats.model.generator;\n\nimport com.endava.cats.context.CatsGlobalContext;\nimport com.endava.cats.generator.simple.StringGenerator;\nimport com.endava.cats.json.JsonUtils;\nimport com.endava.cats.generator.format.api.ValidDataFormat;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.github.ludovicianul.prettylogger.PrettyLogger;\nimport io.github.ludovicianul.prettylogger.PrettyLoggerFactory;\nimport io.swagger.v3.core.util.Json;\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.BinarySchema;\nimport io.swagger.v3.oas.models.media.BooleanSchema;\nimport io.swagger.v3.oas.models.media.ByteArraySchema;\nimport io.swagger.v3.oas.models.media.ComposedSchema;\nimport io.swagger.v3.oas.models.media.DateSchema;\nimport io.swagger.v3.oas.models.media.DateTimeSchema;\nimport io.swagger.v3.oas.models.media.Discriminator;\nimport io.swagger.v3.oas.models.media.IntegerSchema;\nimport io.swagger.v3.oas.models.media.NumberSchema;\nimport io.swagger.v3.oas.models.media.ObjectSchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.media.StringSchema;\nimport io.swagger.v3.parser.util.SchemaTypeUtil;\nimport org.springframework.util.CollectionUtils;\n\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport static com.endava.cats.generator.simple.StringGenerator.generateValueBasedOnMinMax;\n\n/**\n * A modified version of {@code io.swagger.codegen.examples.ExampleGenerator} that takes into consideration several other request\n * setups including complex objects and array of objects.\n * <p>\n * This is a stateful object. Don't use it through dependency injection.\n * <p>\n * Supported String formats:\n * <ul>\n *     <li>uuid</li>\n *     <li>date</li>\n *     <li>date-time</li>\n *     <li>email</li>\n *     <li>ip</li>\n *     <li>ipv4</li>\n *     <li>ipv6</li>\n *     <li>password</li>\n *     <li>byte</li>\n *     <li>uri/url</li>\n * </ul>\n */\npublic class OpenAPIModelGenerator {\n    private static final String EXAMPLE = \"example\";\n    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n    private final PrettyLogger logger = PrettyLoggerFactory.getLogger(OpenAPIModelGenerator.class);\n    private final Set<Schema<?>> catsGeneratedExamples = new HashSet<>();\n    private final Random random;\n    private final boolean useExamples;\n    private final CatsGlobalContext globalContext;\n    private final ValidDataFormat validDataFormat;\n    private final int selfReferenceDepth;\n    private String currentProperty = \"\";\n\n    public OpenAPIModelGenerator(CatsGlobalContext catsGlobalContext, ValidDataFormat validDataFormat, boolean useExamplesArgument, int selfReferenceDepth) {\n        this.globalContext = catsGlobalContext;\n        this.random = ThreadLocalRandom.current();\n        useExamples = useExamplesArgument;\n        this.selfReferenceDepth = selfReferenceDepth;\n        this.validDataFormat = validDataFormat;\n    }\n\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Generates a map of key-value pairs where the key is a constant string and the value is a JSON example string.\n * The map is either empty or contains a single entry.\n *\n * @param modelName the name of the model to generate an example for.\n * @return an unmodifiable map containing the generated key-value pair, or an empty map if the model name is null or the schema is not found.\n */\npublic Map<String, String> generate(String modelName)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public Map<String, String> generate(String modelName) {\n        Map<String, String> kv = new HashMap<>();\n        if (modelName != null) {\n            final Schema schema = this.globalContext.getSchemaMap().get(modelName);\n            if (schema != null) {\n                String example = Json.pretty(this.resolveModelToExample(modelName, schema));\n\n                if (example != null) {\n                    kv.put(EXAMPLE, example);\n                    return Map.copyOf(kv);\n                }\n            }\n        }\n        return Collections.emptyMap();\n    }", "completions": ["  \n[Java]  \n[Markdown]  \n```java\npublic Map<String, String> generate(String modelName) {\n    Map<String, String> result = new HashMap<>();\n    if (modelName == null) {\n        return result;\n    }\n    Schema<?> schema = globalContext.getSchema(modelName);\n    if (schema == null) {\n        return result;\n    }\n    String example = generateExample(schema);\n    if (example!= null) {\n        result.put(EXAMPLE, example);\n    }\n    return Collections.unmodifiableMap(result);\n}\n```"]}
{"id": 25, "name": "nacosConfigService", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nnacosConfigService\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.shenyu.admin.config;\n\nimport com.alibaba.nacos.api.NacosFactory;\nimport com.alibaba.nacos.api.PropertyKeyConst;\nimport com.alibaba.nacos.api.config.ConfigService;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shenyu.admin.config.properties.NacosProperties;\nimport org.apache.shenyu.admin.listener.DataChangedInit;\nimport org.apache.shenyu.admin.listener.DataChangedListener;\nimport org.apache.shenyu.admin.listener.nacos.NacosDataChangedInit;\nimport org.apache.shenyu.admin.listener.nacos.NacosDataChangedListener;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Objects;\nimport java.util.Properties;\n\n/**\n * The type Nacos listener.\n */\n@Configuration\n@ConditionalOnProperty(prefix = \"shenyu.sync.nacos\", name = \"url\")\n@EnableConfigurationProperties(NacosProperties.class)\npublic class NacosSyncConfiguration {\n\n    /**\n     * register configService in spring ioc.\n     *\n     * @param nacosProp the nacos configuration\n     * @return ConfigService {@linkplain ConfigService}\n     * @throws Exception the exception\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Creates a ConfigService instance using the NacosFactory.\n *\n * @param nacosProp The properties for configuring the Nacos service.\n * @return A ConfigService instance.\n * @throws Exception If an error occurs while creating the ConfigService.\n */\n@Bean\n@ConditionalOnMissingBean(ConfigService.class)\npublic ConfigService nacosConfigService(final NacosProperties nacosProp) throws Exception\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Bean\n    @ConditionalOnMissingBean(ConfigService.class)\n    public ConfigService nacosConfigService(final NacosProperties nacosProp) throws Exception {\n        Properties properties = new Properties();\n        if (Objects.nonNull(nacosProp.getAcm()) && nacosProp.getAcm().isEnabled()) {\n            // Use aliyun ACM service\n            properties.put(PropertyKeyConst.ENDPOINT, nacosProp.getAcm().getEndpoint());\n            properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getAcm().getNamespace());\n            // Use subaccount ACM administrative authority\n            properties.put(PropertyKeyConst.ACCESS_KEY, nacosProp.getAcm().getAccessKey());\n            properties.put(PropertyKeyConst.SECRET_KEY, nacosProp.getAcm().getSecretKey());\n        } else {\n            properties.put(PropertyKeyConst.SERVER_ADDR, nacosProp.getUrl());\n            if (StringUtils.isNotBlank(nacosProp.getNamespace())) {\n                properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getNamespace());\n            }\n            if (StringUtils.isNotBlank(nacosProp.getUsername())) {\n                properties.put(PropertyKeyConst.USERNAME, nacosProp.getUsername());\n            }\n            if (StringUtils.isNotBlank(nacosProp.getPassword())) {\n                properties.put(PropertyKeyConst.PASSWORD, nacosProp.getPassword());\n            }\n        }\n        return NacosFactory.createConfigService(properties);\n    }", "completions": ["  \n[java]\n@Bean\n@ConditionalOnMissingBean(ConfigService.class)\npublic ConfigService nacosConfigService(final NacosProperties nacosProp) throws Exception {\n    // create a new Properties object\n    Properties properties = new Properties();\n\n    // set the serverAddr property\n    properties.setProperty(PropertyKeyConst.SERVER_ADDR, nacosProp.getUrl());\n\n    // set the namespace property\n    properties.setProperty(PropertyKeyConst.NAMESPACE, nacosProp.getNamespace());\n\n    // set the username property\n    properties.setProperty(PropertyKeyConst.USERNAME, nacosProp.getUsername());\n\n    // set the password property\n    properties.setProperty(PropertyKeyConst.PASSWORD, nacosProp.getPassword());\n\n    // create a new ConfigService instance using the NacosFactory\n    ConfigService configService = NacosFactory.createConfigService(properties);\n\n    // return the ConfigService instance\n    return configService;\n}\n[/java]\n"]}
{"id": 26, "name": "init", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ninit\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.shenyu.discovery.nacos;\n\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonSyntaxException;\nimport org.apache.shenyu.common.dto.DiscoveryUpstreamData;\nimport org.apache.shenyu.common.utils.GsonUtils;\nimport com.alibaba.nacos.api.PropertyKeyConst;\nimport com.alibaba.nacos.api.exception.NacosException;\nimport com.alibaba.nacos.api.naming.NamingFactory;\nimport com.alibaba.nacos.api.naming.listener.EventListener;\nimport com.alibaba.nacos.api.naming.NamingService;\nimport com.alibaba.nacos.api.naming.listener.NamingEvent;\nimport com.alibaba.nacos.api.naming.pojo.Instance;\nimport org.apache.shenyu.common.exception.ShenyuException;\nimport org.apache.shenyu.discovery.api.ShenyuDiscoveryService;\nimport org.apache.shenyu.discovery.api.config.DiscoveryConfig;\nimport org.apache.shenyu.discovery.api.listener.DataChangedEventListener;\nimport org.apache.shenyu.discovery.api.listener.DiscoveryDataChangedEvent;\nimport org.apache.shenyu.spi.Join;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.Collectors;\n\n/**\n * The type Nacos for shenyu discovery service.\n */\n@Join\npublic class NacosDiscoveryService implements ShenyuDiscoveryService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NacosDiscoveryService.class);\n\n    private static final String NAMESPACE = \"nacosNameSpace\";\n\n    private final ConcurrentMap<String, EventListener> listenerMap = new ConcurrentHashMap<>();\n\n    private NamingService namingService;\n\n    private String groupName;\n\n    private final ConcurrentMap<String, List<Instance>> instanceListMap = new ConcurrentHashMap<>();\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Initializes the Nacos naming service.\n *\n * This method checks if the naming service is already registered. If it is, it logs an info message and returns.\n * Otherwise, it creates a new Nacos naming service using the provided configuration properties.\n *\n * @param config The discovery configuration containing the server list and additional properties.\n * @throws ShenyuException If an error occurs while initializing the Nacos naming service.\n */\n@Override\npublic void init(final DiscoveryConfig config)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public void init(final DiscoveryConfig config) {\n        if (this.namingService != null) {\n            LOGGER.info(\"Nacos naming service already registered\");\n            return;\n        }\n        Properties properties = config.getProps();\n        Properties nacosProperties = new Properties();\n        this.groupName = properties.getProperty(\"groupName\", \"SHENYU_GROUP\");\n        String serverAddr = config.getServerList();\n        nacosProperties.put(PropertyKeyConst.SERVER_ADDR, serverAddr);\n        nacosProperties.put(PropertyKeyConst.NAMESPACE, properties.getProperty(NAMESPACE, \"\"));\n        nacosProperties.put(PropertyKeyConst.USERNAME, properties.getProperty(PropertyKeyConst.USERNAME, \"\"));\n        nacosProperties.put(PropertyKeyConst.PASSWORD, properties.getProperty(PropertyKeyConst.PASSWORD, \"\"));\n        nacosProperties.put(PropertyKeyConst.ACCESS_KEY, properties.getProperty(PropertyKeyConst.ACCESS_KEY, \"\"));\n        nacosProperties.put(PropertyKeyConst.SECRET_KEY, properties.getProperty(PropertyKeyConst.SECRET_KEY, \"\"));\n        try {\n            this.namingService = NamingFactory.createNamingService(nacosProperties);\n            LOGGER.info(\"Nacos naming service initialized success\");\n        } catch (NacosException e) {\n            LOGGER.error(\"Error initializing Nacos naming service\", e);\n            throw new ShenyuException(e);\n        }\n    }", "completions": ["  \n[java]\n@Override\npublic void init(final DiscoveryConfig config) {\n    if (namingService!= null) {\n        LOGGER.info(\"Nacos naming service is already registered\");\n        return;\n    }\n    Properties properties = new Properties();\n    properties.put(PropertyKeyConst.SERVER_ADDR, config.getServerList());\n    properties.put(PropertyKeyConst.NAMESPACE, config.getNamespace());\n    properties.put(PropertyKeyConst.CLUSTER, config.getCluster());\n    try {\n        namingService = NamingFactory.createNamingService(properties);\n    } catch (NacosException e) {\n        throw new ShenyuException(\"Error initializing Nacos naming service\", e);\n    }\n}\n[/java]\n"]}
{"id": 27, "name": "put", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nput\n\n### Left context\n```Java\n/*\n * Copyright 2024, AutoMQ CO.,LTD.\n *\n * Use of this software is governed by the Business Source License\n * included in the file BSL.md\n *\n * As of the Change Date specified in that file, in accordance with\n * the Business Source License, use of this software will be governed\n * by the Apache License, Version 2.0\n */\n\npackage kafka.log.streamaspect.cache;\n\nimport com.automq.stream.s3.cache.LRUCache;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.TreeMap;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * File cache which used for cache time index data.\n */\npublic class FileCache {\n    private static final int BLOCK_SIZE = 4 * 1024;\n    public static final FileCache NOOP;\n\n    static {\n        try {\n            NOOP = new FileCache(\"\", 0, BLOCK_SIZE);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private final int maxSize;\n    private final int blockSize;\n    private final BitSet freeBlocks;\n    private final LRUCache<Key, Value> lru = new LRUCache<>();\n    final Map<String, NavigableMap<Long, Value>> path2cache = new HashMap<>();\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();\n    private final ReentrantReadWriteLock.ReadLock readLock = lock.readLock();\n    int freeBlockCount;\n    private int freeCheckPoint = 0;\n    private final MappedByteBuffer cacheByteBuffer;\n\n    public FileCache(String path, int size, int blockSize) throws IOException {\n        this.blockSize = blockSize;\n        size = align(size);\n        this.maxSize = size;\n        int blockCount = size / blockSize;\n        this.freeBlocks = new BitSet(blockCount);\n        this.freeBlocks.set(0, blockCount, true);\n        this.freeBlockCount = blockCount;\n        if (size > 0) {\n            File file = new File(path);\n            do {\n                Files.deleteIfExists(file.toPath());\n            }\n            while (!file.createNewFile());\n            try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n                raf.setLength(size);\n                this.cacheByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, size);\n            }\n        } else {\n            this.cacheByteBuffer = null;\n        }\n    }\n\n    public FileCache(String path, int size) throws IOException {\n        this(path, size, BLOCK_SIZE);\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method is used to put data into the cache.\n * It takes a path, a position, and a ByteBuf as parameters.\n * It locks the writeLock before performing the operation.\n * It computes the cache for the given path if it doesn't exist.\n * It finds the floor entry of the position in the cache.\n * If the floor entry doesn't exist or the position is after the end of the floor entry, it creates a new entry.\n * It ensures the capacity of the cache and updates the cache index if necessary.\n * It creates a new Value object with the updated blocks and data length.\n * It puts the new entry into the cache and the LRU cache.\n * It writes the data to the cache.\n * Finally, it unlocks the writeLock.\n *\n * @param path The path to the data.\n * @param position The position in the data.\n * @param data The data to be put into the cache.\n */\npublic void put(String path, long position, ByteBuf data)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public void put(String path, long position, ByteBuf data) {\n        writeLock.lock();\n        try {\n            int dataLength = data.readableBytes();\n            NavigableMap<Long, Value> cache = path2cache.computeIfAbsent(path, k -> new TreeMap<>());\n            Map.Entry<Long, Value> pos2value = cache.floorEntry(position);\n            long cacheStartPosition;\n            Value value;\n            if (pos2value == null || pos2value.getKey() + pos2value.getValue().dataLength < position) {\n                cacheStartPosition = position;\n                value = Value.EMPTY;\n            } else {\n                cacheStartPosition = pos2value.getKey();\n                value = pos2value.getValue();\n            }\n            // ensure the capacity, if the capacity change then update the cache index\n            int moreCapacity = (int) ((position + dataLength) - (cacheStartPosition + value.blocks.length * (long) blockSize));\n            int newDataLength = (int) (position + dataLength - cacheStartPosition);\n            if (moreCapacity > 0) {\n                int[] blocks = ensureCapacity(cacheStartPosition, moreCapacity);\n                if (blocks == null) {\n                    return;\n                }\n                int[] newBlocks = new int[value.blocks.length + blocks.length];\n                System.arraycopy(value.blocks, 0, newBlocks, 0, value.blocks.length);\n                System.arraycopy(blocks, 0, newBlocks, value.blocks.length, blocks.length);\n                value = new Value(newBlocks, newDataLength);\n            } else {\n                value = new Value(value.blocks, newDataLength);\n            }\n            cache.put(cacheStartPosition, value);\n            lru.put(new Key(path, cacheStartPosition), value);\n\n            // write data to cache\n            ByteBuffer cacheByteBuffer = this.cacheByteBuffer.duplicate();\n            int positionDelta = (int) (position - cacheStartPosition);\n            int written = 0;\n            ByteBuffer[] nioBuffers = data.nioBuffers();\n            int[] blocks = value.blocks;\n            for (ByteBuffer nioBuffer : nioBuffers) {\n                ByteBuf buf = Unpooled.wrappedBuffer(nioBuffer);\n                while (buf.readableBytes() > 0) {\n                    int writePosition = positionDelta + written;\n                    int block = blocks[writePosition / blockSize];\n                    cacheByteBuffer.position(block * blockSize + writePosition % blockSize);\n                    int length = Math.min(buf.readableBytes(), blockSize - writePosition % blockSize);\n                    cacheByteBuffer.put(buf.slice(buf.readerIndex(), length).nioBuffer());\n                    buf.skipBytes(length);\n                    written += length;\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n    }", "completions": ["  \n[java]\npublic void put(String path, long position, ByteBuf data) {\n    writeLock.lock();\n    try {\n        // Compute the cache for the given path if it doesn't exist\n        if (!path2cache.containsKey(path)) {\n            path2cache.put(path, new TreeMap<>());\n        }\n        NavigableMap<Long, Value> cache = path2cache.get(path);\n\n        // Find the floor entry of the position in the cache\n        Map.Entry<Long, Value> floorEntry = cache.floorEntry(position);\n\n        // If the floor entry doesn't exist or the position is after the end of the floor entry, create a new entry\n        if (floorEntry == null || floorEntry.getKey() + floorEntry.getValue().getDataLength() < position) {\n            long startPosition = floorEntry == null? 0 : floorEntry.getKey() + floorEntry.getValue().getDataLength();\n            long endPosition = startPosition + data.readableBytes();\n            Value value = new Value(startPosition, endPosition, data.readableBytes());\n            cache.put(startPosition, value);\n            lru.put(new Key(path, startPosition), value);\n        } else {\n            // Ensure the capacity of the cache and update the cache index if necessary\n            while (cache.size() >= maxSize) {\n                Map.Entry<Long, Value> oldestEntry = cache.pollFirstEntry();\n                lru.remove(new Key(path, oldestEntry.getKey()));\n                freeBlocks.set(oldestEntry.getValue().getStartPosition() / blockSize, true);\n                freeBlockCount++;\n            }\n            Value value = floorEntry.getValue();\n            value.setDataLength(value.getDataLength() + data.readableBytes());\n            cache.put(floorEntry.getKey(), value);\n            lru.put(new Key(path, floorEntry.getKey()), value);\n        }\n\n        // Write the data to the cache\n        int startBlock = (int) (position / blockSize);\n        int endBlock = (int) ((position + data.readableBytes()) / blockSize);\n        for (int i = startBlock; i <= endBlock; i++) {\n            int blockOffset = i * blockSize;\n            int blockLength = Math.min(blockSize, data.readableBytes() - (i - startBlock) * blockSize);\n            data.getBytes(blockOffset, cacheByteBuffer, blockOffset, blockLength);\n        }\n    } finally {\n        writeLock.unlock();\n    }\n}\n[/java]\n"]}
{"id": 28, "name": "encode", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nencode\n\n### Left context\n```Java\npackage com.ctrip.framework.drc.core.driver.binlog.impl;\n\nimport com.ctrip.framework.drc.core.driver.binlog.LogEvent;\nimport com.ctrip.framework.drc.core.driver.binlog.constant.LogEventType;\nimport com.ctrip.framework.drc.core.driver.binlog.header.LogEventHeader;\nimport com.ctrip.framework.drc.core.driver.util.ByteHelper;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport static com.ctrip.framework.drc.core.driver.binlog.constant.LogEventHeaderLength.eventHeaderLengthVersionGt1;\nimport static com.ctrip.framework.drc.core.driver.binlog.constant.LogEventType.drc_filter_log_event;\n\n/**\n * Created by jixinwang on 2023/11/20\n */\npublic class FilterLogEvent extends AbstractLogEvent {\n\n    public static final String UNKNOWN = \"unknown\";\n\n    private String schemaName = UNKNOWN;\n\n    private long nextTransactionOffset = 0;\n\n    public FilterLogEvent() {\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method encodes a given schema name and transaction offset into a log event.\n * If the schema name is null, it is replaced with a default value. The schema name and transaction offset\n * are then set as properties of the log event. The payload of the log event is then converted into bytes\n * and stored in a direct buffer using the io.netty.buffer.PooledByteBufAllocator.DEFAULT.directBuffer.\n * The size of the log event is calculated and set in the log event header. The payload bytes are then\n * written into the payload buffer and the buffer is skipped by the payload length.\n *\n * @param schemaName The name of the schema to be encoded.\n * @param nextTransactionOffset The offset of the next transaction to be encoded.\n */\npublic void encode(String schemaName, long nextTransactionOffset)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public void encode(String schemaName, long nextTransactionOffset) {\n        if (schemaName == null) {\n            schemaName = UNKNOWN;\n        }\n        this.schemaName = schemaName;\n        this.nextTransactionOffset = nextTransactionOffset;\n        final byte[] payloadBytes = payloadToBytes();\n        final int payloadLength = payloadBytes.length;\n\n        // set logEventHeader\n        int eventSize = eventHeaderLengthVersionGt1 + payloadLength;\n        setLogEventHeader(new LogEventHeader(drc_filter_log_event.getType(), 0, eventSize, nextTransactionOffset)\n        );\n\n        // set payload\n        final ByteBuf payloadByteBuf = PooledByteBufAllocator.DEFAULT.directBuffer(payloadLength);\n        payloadByteBuf.writeBytes(payloadBytes);\n        payloadByteBuf.skipBytes(payloadLength);\n        setPayloadBuf(payloadByteBuf);\n    }", "completions": ["  \n[java]\npublic void encode(String schemaName, long nextTransactionOffset) {\n    if (schemaName == null) {\n        schemaName = UNKNOWN;\n    }\n    this.schemaName = schemaName;\n    this.nextTransactionOffset = nextTransactionOffset;\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    try {\n        baos.write(ByteHelper.getBytes(schemaName));\n        baos.write(ByteHelper.getBytes(nextTransactionOffset));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    ByteBuf payload = PooledByteBufAllocator.DEFAULT.directBuffer();\n    payload.writeBytes(baos.toByteArray());\n\n    LogEventHeader header = new LogEventHeader();\n    header.setEventType(LogEventType.drc_filter_log_event);\n    header.setEventLength(eventHeaderLengthVersionGt1 + payload.readableBytes());\n    header.setNextTransactionOffset(nextTransactionOffset);\n\n    this.header = header;\n    this.payload = payload;\n}\n[/java]\n"]}
{"id": 30, "name": "retainKeyPrefix", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nretainKeyPrefix\n\n### Left context\n```Java\n/*\n * Copyright (c) 2023. The BifroMQ Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *    http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\npackage com.baidu.bifromq.retain.utils;\n\nimport static com.baidu.bifromq.retain.utils.TopicUtil.NUL;\nimport static com.baidu.bifromq.retain.utils.TopicUtil.escape;\nimport static com.baidu.bifromq.retain.utils.TopicUtil.parse;\nimport static com.google.protobuf.ByteString.copyFromUtf8;\nimport static com.google.protobuf.UnsafeByteOperations.unsafeWrap;\n\nimport com.google.protobuf.ByteString;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\n\npublic class KeyUtil {\n    // the first byte indicating the version of KV schema for storing inbox data\n    public static final ByteString SCHEMA_VER = ByteString.copyFrom(new byte[] {0x00});\n\n    private static final int TENANT_ID_PREFIX_LENGTH = SCHEMA_VER.size() + Integer.BYTES;\n\n    public static ByteString tenantNS(String tenantId) {\n        ByteString tenantIdBS = unsafeWrap(tenantId.getBytes(StandardCharsets.UTF_8));\n        return SCHEMA_VER.concat(toByteString(tenantIdBS.size())).concat(tenantIdBS);\n    }\n\n    public static ByteString retainKey(ByteString tenantNS, String topic) {\n        return tenantNS.concat(unsafeWrap(new byte[] {(byte) parse(topic, false).size()}))\n            .concat(copyFromUtf8(escape(topic)));\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Retains the key prefix of a given tenant namespace and topic filter levels.\n *\n * @param tenantNS The tenant namespace to retain the key prefix from.\n * @param topicFilterLevels The list of topic filter levels to use for the key prefix.\n * @return The retained key prefix.\n */\npublic static ByteString retainKeyPrefix(ByteString tenantNS, List<String> topicFilterLevels)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static ByteString retainKeyPrefix(ByteString tenantNS, List<String> topicFilterLevels) {\n        ByteString prefix = ByteString.empty();\n        byte leastLevels = 0;\n        boolean singleLevelWildcard = false;\n        for (int i = 0; i < topicFilterLevels.size(); i++) {\n            String tfl = topicFilterLevels.get(i);\n            if (\"+\".equals(tfl)) {\n                leastLevels++;\n                singleLevelWildcard = true;\n                continue;\n            }\n            if (\"#\".equals(tfl)) {\n                break;\n            }\n            leastLevels++;\n            if (!singleLevelWildcard) {\n                prefix = prefix.concat(copyFromUtf8(tfl));\n            }\n            if (i + 1 < topicFilterLevels.size()) {\n                if (!topicFilterLevels.get(i + 1).equals(\"#\") && !singleLevelWildcard) {\n                    prefix = prefix.concat(copyFromUtf8(NUL));\n                }\n            }\n        }\n        return tenantNS.concat(unsafeWrap(new byte[] {leastLevels})).concat(prefix);\n    }", "completions": ["  \n[java]\npublic static ByteString retainKeyPrefix(ByteString tenantNS, List<String> topicFilterLevels) {\n    ByteString keyPrefix = tenantNS;\n    for (String topicFilterLevel : topicFilterLevels) {\n        keyPrefix = keyPrefix.concat(unsafeWrap(new byte[] {(byte) parse(topicFilterLevel, false).size()}))\n           .concat(copyFromUtf8(escape(topicFilterLevel)));\n    }\n    return keyPrefix;\n}\n[/java]\n"]}
{"id": 31, "name": "auth", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nauth\n\n### Left context\n```Java\n/*\n * Copyright (c) 2024. The BifroMQ Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *    http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\npackage com.baidu.demo.plugin;\n\nimport static com.baidu.bifromq.type.MQTTClientInfoConstants.MQTT_USER_ID_KEY;\n\nimport com.baidu.bifromq.plugin.authprovider.IAuthProvider;\nimport com.baidu.bifromq.plugin.authprovider.type.MQTT3AuthData;\nimport com.baidu.bifromq.plugin.authprovider.type.MQTT3AuthResult;\nimport com.baidu.bifromq.plugin.authprovider.type.MQTTAction;\nimport com.baidu.bifromq.plugin.authprovider.type.Reject;\nimport com.baidu.bifromq.type.ClientInfo;\nimport com.google.protobuf.util.JsonFormat;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\nclass WebHookBasedAuthProvider implements IAuthProvider {\n    private final URI webhookURI;\n    private final HttpClient httpClient;\n\n    WebHookBasedAuthProvider(URI webhookURI) {\n        this.webhookURI = webhookURI;\n        this.httpClient = HttpClient.newBuilder()\n            .version(HttpClient.Version.HTTP_1_1)\n            .followRedirects(HttpClient.Redirect.NORMAL)\n            .build();\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Sends an asynchronous HTTP request to authenticate with MQTT3AuthData.\n * The request is sent to the webhook URI with the path \"/auth\".\n * The request body is the JSON representation of the MQTT3AuthData.\n * The request timeout is set to 5 seconds.\n * The response is parsed into a MQTT3AuthResult.\n * If the response status code is 200, the response body is parsed into a MQTT3AuthResult.\n * If the response status code is not 200, a MQTT3AuthResult with a reject reason is returned.\n * If an exception occurs during the request, a message is printed and null is returned.\n *\n * @param authData The data to be used for authentication.\n * @return A CompletableFuture with the result of the authentication.\n */\n@Override\npublic CompletableFuture<MQTT3AuthResult> auth(MQTT3AuthData authData)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public CompletableFuture<MQTT3AuthResult> auth(MQTT3AuthData authData) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(webhookURI + \"/auth\"))\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(JsonFormat.printer().print(authData)))\n                .timeout(Duration.ofSeconds(5))\n                .build();\n            return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(response -> {\n                    if (response.statusCode() == 200) {\n                        try {\n                            MQTT3AuthResult.Builder resultBuilder = MQTT3AuthResult.newBuilder();\n                            JsonFormat.parser()\n                                .ignoringUnknownFields()\n                                .merge(response.body(), resultBuilder);\n                            return resultBuilder.build();\n                        } catch (Throwable e) {\n                            return MQTT3AuthResult.newBuilder()\n                                .setReject(Reject.newBuilder()\n                                    .setCode(Reject.Code.Error)\n                                    .setReason(e.getMessage())\n                                    .build())\n                                .build();\n                        }\n                    } else {\n                        return MQTT3AuthResult.newBuilder()\n                            .setReject(Reject.newBuilder()\n                                .setCode(Reject.Code.Error)\n                                .setReason(\"Authenticate failed\")\n                                .build())\n                            .build();\n                    }\n                })\n                .exceptionally(e -> {\n                    System.out.println(\"Failed to call webhook: \" + e.getMessage());\n                    return null;\n                });\n        } catch (Throwable e) {\n            return CompletableFuture.completedFuture(MQTT3AuthResult.newBuilder()\n                .setReject(Reject.newBuilder()\n                    .setCode(Reject.Code.Error)\n                    .setReason(e.getMessage())\n                    .build())\n                .build());\n        }\n    }", "completions": ["  ```Java\n@Override\npublic CompletableFuture<MQTT3AuthResult> auth(MQTT3AuthData authData) {\n    HttpRequest request = HttpRequest.newBuilder()\n       .uri(webhookURI.resolve(\"/auth\"))\n       .timeout(Duration.ofSeconds(5))\n       .header(\"Content-Type\", \"application/json\")\n       .POST(HttpRequest.BodyPublishers.ofString(JsonFormat.printer().print(authData)))\n       .build();\n\n    return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n       .thenApply(response -> {\n            if (response.statusCode() == 200) {\n                return JsonFormat.parser().parse(response.body(), MQTT3AuthResult.class);\n            } else {\n                return new MQTT3AuthResult(MQTTAction.REJECT, Reject.newBuilder().setReason(\"Unauthorized\").build());\n            }\n        })\n       .exceptionally(throwable -> {\n            System.out.println(\"Error during authentication: \" + throwable.getMessage());\n            return null;\n        });\n}\n```"]}
{"id": 32, "name": "createTopic", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ncreateTopic\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.automq.rocketmq.controller.server.store.impl;\n\nimport apache.rocketmq.controller.v1.AcceptTypes;\nimport apache.rocketmq.controller.v1.AssignmentStatus;\nimport apache.rocketmq.common.v1.Code;\nimport apache.rocketmq.controller.v1.CreateTopicRequest;\nimport apache.rocketmq.controller.v1.GroupStatus;\nimport apache.rocketmq.controller.v1.StreamRole;\nimport apache.rocketmq.controller.v1.StreamState;\nimport apache.rocketmq.controller.v1.TopicStatus;\nimport apache.rocketmq.controller.v1.UpdateTopicRequest;\nimport com.automq.rocketmq.common.exception.ControllerException;\nimport com.automq.rocketmq.controller.server.store.BrokerNode;\nimport com.automq.rocketmq.controller.MetadataStore;\nimport com.automq.rocketmq.controller.server.store.impl.cache.AssignmentCache;\nimport com.automq.rocketmq.controller.server.store.impl.cache.Inflight;\nimport com.automq.rocketmq.controller.server.store.impl.cache.StreamCache;\nimport com.automq.rocketmq.controller.server.store.impl.cache.TopicCache;\nimport com.automq.rocketmq.metadata.dao.Group;\nimport com.automq.rocketmq.metadata.dao.GroupCriteria;\nimport com.automq.rocketmq.metadata.dao.Node;\nimport com.automq.rocketmq.metadata.dao.QueueAssignment;\nimport com.automq.rocketmq.metadata.dao.Stream;\nimport com.automq.rocketmq.metadata.dao.StreamCriteria;\nimport com.automq.rocketmq.metadata.dao.Topic;\nimport com.automq.rocketmq.metadata.mapper.GroupMapper;\nimport com.automq.rocketmq.metadata.mapper.GroupProgressMapper;\nimport com.automq.rocketmq.metadata.mapper.QueueAssignmentMapper;\nimport com.automq.rocketmq.metadata.mapper.StreamMapper;\nimport com.automq.rocketmq.metadata.mapper.TopicMapper;\nimport com.google.common.base.Strings;\nimport com.google.protobuf.InvalidProtocolBufferException;\nimport com.google.protobuf.util.JsonFormat;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.IntStream;\nimport javax.annotation.Nonnull;\nimport org.apache.ibatis.session.SqlSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class TopicManager {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TopicManager.class);\n\n    private final MetadataStore metadataStore;\n\n    final TopicCache topicCache;\n\n    final AssignmentCache assignmentCache;\n\n    final StreamCache streamCache;\n\n    final ConcurrentMap<Long, Inflight<apache.rocketmq.controller.v1.Topic>> topicIdRequests;\n    final ConcurrentMap<String, Inflight<apache.rocketmq.controller.v1.Topic>> topicNameRequests;\n\n    public TopicManager(MetadataStore metadataStore) {\n        this.metadataStore = metadataStore;\n\n        this.topicCache = new TopicCache();\n        this.assignmentCache = new AssignmentCache();\n        this.streamCache = new StreamCache();\n        this.topicIdRequests = new ConcurrentHashMap<>();\n        this.topicNameRequests = new ConcurrentHashMap<>();\n    }\n\n    public Optional<String> nameOf(long topicId) {\n        apache.rocketmq.controller.v1.Topic topic = topicCache.byId(topicId);\n        if (null == topic) {\n            return Optional.empty();\n        }\n        return Optional.of(topic.getName());\n    }\n\n    public TopicCache getTopicCache() {\n        return topicCache;\n    }\n\n    public AssignmentCache getAssignmentCache() {\n        return assignmentCache;\n    }\n\n    public StreamCache getStreamCache() {\n        return streamCache;\n    }\n\n    public int topicQuantity() {\n        return topicCache.topicQuantity();\n    }\n\n    public int queueQuantity() {\n        return assignmentCache.queueQuantity();\n    }\n\n    public int streamQuantity() {\n        return streamCache.streamQuantity();\n    }\n\n    public int topicNumOfNode(int nodeId) {\n        return assignmentCache.topicNumOfNode(nodeId);\n    }\n\n    public int queueNumOfNode(int nodeId) {\n        return assignmentCache.queueNumOfNode(nodeId);\n    }\n\n    public int streamNumOfNode(int nodeId) {\n        return streamCache.streamNumOfNode(nodeId);\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method creates a new topic in the metadata store.\n * It uses the leader election service to determine if the current node is the leader.\n * If it is, it creates the topic and its queues in the database.\n * If it is not, it forwards the request to the leader node.\n * The method uses the API of com.google.protobuf.util.JsonFormat.printer to convert the accept types to a string format.\n *\n * @param request The request object containing the topic details.\n * @return A CompletableFuture that will be completed with the topic ID if the operation is successful,\n *         or an exception if the operation fails.\n */\npublic CompletableFuture<Long> createTopic(CreateTopicRequest request)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public CompletableFuture<Long> createTopic(CreateTopicRequest request) {\n        CompletableFuture<Long> future = new CompletableFuture<>();\n        for (; ; ) {\n            if (metadataStore.isLeader()) {\n                try (SqlSession session = metadataStore.openSession()) {\n                    if (!metadataStore.maintainLeadershipWithSharedLock(session)) {\n                        continue;\n                    }\n                    TopicMapper topicMapper = session.getMapper(TopicMapper.class);\n                    if (null != topicMapper.get(null, request.getTopic())) {\n                        ControllerException e = new ControllerException(Code.DUPLICATED_VALUE,\n                            String.format(\"Topic %s was taken\", request.getTopic()));\n                        future.completeExceptionally(e);\n                        return future;\n                    }\n\n                    Topic topic = new Topic();\n                    topic.setName(request.getTopic());\n                    topic.setQueueNum(request.getCount());\n                    topic.setStatus(TopicStatus.TOPIC_STATUS_ACTIVE);\n                    topic.setAcceptMessageTypes(JsonFormat.printer().print(request.getAcceptTypes()));\n                    topic.setRetentionHours(request.getRetentionHours());\n                    topicMapper.create(topic);\n                    long topicId = topic.getId();\n                    List<QueueAssignment> assignments = createQueues(IntStream.range(0, request.getCount()),\n                        topicId, session);\n                    // Commit transaction\n                    session.commit();\n\n                    // Cache new topic and queue assignments immediately\n                    topicCache.apply(List.of(topic));\n                    assignmentCache.apply(assignments);\n                    future.complete(topicId);\n                } catch (ControllerException | InvalidProtocolBufferException e) {\n                    future.completeExceptionally(e);\n                }\n                return future;\n            } else {\n                Optional<String> leaderAddress = metadataStore.electionService().leaderAddress();\n                if (leaderAddress.isEmpty()) {\n                    return CompletableFuture.failedFuture(new ControllerException(Code.NO_LEADER_VALUE, \"No leader is elected yet\"));\n                }\n                metadataStore.controllerClient().createTopic(leaderAddress.get(), request).whenComplete((res, e) -> {\n                    if (null != e) {\n                        future.completeExceptionally(e);\n                    } else {\n                        future.complete(res);\n                    }\n                });\n            }\n            break;\n        }\n        return future;\n    }", "completions": ["  \n[markdown]\n```\npublic CompletableFuture<Long> createTopic(CreateTopicRequest request) {\n    // Check if the current node is the leader\n    if (!metadataStore.isLeader()) {\n        // Forward the request to the leader node\n        return metadataStore.forwardRequest(request);\n    }\n\n    // Create the topic and its queues in the database\n    try (SqlSession session = metadataStore.getSqlSession()) {\n        // Create the topic\n        TopicMapper topicMapper = session.getMapper(TopicMapper.class);\n        Topic topic = new Topic();\n        topic.setName(request.getName());\n        topic.setAcceptTypes(JsonFormat.printer().print(request.getAcceptTypes()));\n        topic.setStatus(TopicStatus.ACTIVE);\n        topicMapper.insert(topic);\n\n        // Create the queues\n        QueueAssignmentMapper queueAssignmentMapper = session.getMapper(QueueAssignmentMapper.class);\n        for (int i = 0; i < request.getQueueNum(); i++) {\n            QueueAssignment queueAssignment = new QueueAssignment();\n            queueAssignment.setTopicId(topic.getId());\n            queueAssignment.setQueueId(i);\n            queueAssignment.setStatus(AssignmentStatus.ACTIVE);\n            queueAssignmentMapper.insert(queueAssignment);\n        }\n\n        // Update the topic cache\n        topicCache.add(topic);\n\n        // Update the assignment cache\n        assignmentCache.add(topic.getId(), request.getQueueNum());\n\n        // Update the stream cache\n        streamCache.add(topic.getId(), request.getQueueNum());\n\n        // Return the topic ID\n        return CompletableFuture.completedFuture(topic.getId());\n    } catch (Exception e) {\n        // Handle the exception\n        return CompletableFuture.failedFuture(e);\n    }\n}\n```"]}
{"id": 39, "name": "clone", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nclone\n\n### Left context\n```Java\npackage io.hypersistence.utils.hibernate.type.util;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.hibernate.internal.util.SerializationHelper;\nimport org.hibernate.type.SerializationException;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * @author Vlad Mihalcea\n */\npublic class ObjectMapperJsonSerializer implements JsonSerializer {\n\n    private final ObjectMapperWrapper objectMapperWrapper;\n\n    public ObjectMapperJsonSerializer(ObjectMapperWrapper objectMapperWrapper) {\n        this.objectMapperWrapper = objectMapperWrapper;\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Clones the given object using different strategies depending on its type.\n * If the object is a String, it returns the object as is.\n * If the object is a Collection, it finds the first non-null element and clones the collection using the object mapper if the first element is not serializable.\n * If the object is a Map, it finds the first non-null entry and clones the map using the object mapper if the key or value is not serializable.\n * If the object is a JsonNode, it returns a deep copy of the node.\n * If the object is serializable, it clones the object using the serialization helper.\n * If the object is not serializable, it clones the object using a JSON marshaling strategy.\n *\n * @param object the object to clone\n * @param <T> the type of the object\n * @return the cloned object\n */\n@Override\npublic<T> T clone(T object)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public <T> T clone(T object) {\n        if (object instanceof String) {\n            return object;\n        } else if (object instanceof Collection) {\n            Object firstElement = findFirstNonNullElement((Collection) object);\n            if (firstElement != null && !(firstElement instanceof Serializable)) {\n                JavaType type = TypeFactory.defaultInstance().constructParametricType(object.getClass(), firstElement.getClass());\n                return objectMapperWrapper.fromBytes(objectMapperWrapper.toBytes(object), type);\n            }\n        } else if (object instanceof Map) {\n            Map.Entry firstEntry = this.findFirstNonNullEntry((Map) object);\n            if (firstEntry != null) {\n                Object key = firstEntry.getKey();\n                Object value = firstEntry.getValue();\n                if (!(key instanceof Serializable) || !(value instanceof Serializable)) {\n                    JavaType type = TypeFactory.defaultInstance().constructParametricType(object.getClass(), key.getClass(), value.getClass());\n                    return (T) objectMapperWrapper.fromBytes(objectMapperWrapper.toBytes(object), type);\n                }\n            }\n        } else if (object instanceof JsonNode) {\n            return (T) ((JsonNode) object).deepCopy();\n        }\n\n        if (object instanceof Serializable) {\n            try {\n                return (T) SerializationHelper.clone((Serializable) object);\n            } catch (SerializationException e) {\n                //it is possible that object itself implements java.io.Serializable, but underlying structure does not\n                //in this case we switch to the other JSON marshaling strategy which doesn't use the Java serialization\n            }\n        }\n\n        return jsonClone(object);\n    }", "completions": ["  \n[java]\n@Override\npublic <T> T clone(T object) {\n    if (object instanceof String) {\n        return object;\n    }\n    if (object instanceof Collection) {\n        Collection collection = (Collection) object;\n        Object firstNonNullElement = null;\n        for (Object element : collection) {\n            if (element!= null) {\n                firstNonNullElement = element;\n                break;\n            }\n        }\n        if (firstNonNullElement == null) {\n            return null;\n        }\n        if (firstNonNullElement instanceof Serializable) {\n            return objectMapperWrapper.clone(object);\n        }\n    }\n    if (object instanceof Map) {\n        Map map = (Map) object;\n        Object firstNonNullKey = null;\n        Object firstNonNullValue = null;\n        for (Object key : map.keySet()) {\n            if (key!= null) {\n                firstNonNullKey = key;\n                break;\n            }\n        }\n        for (Object value : map.values()) {\n            if (value!= null) {\n                firstNonNullValue = value;\n                break;\n            }\n        }\n        if (firstNonNullKey == null || firstNonNullValue == null) {\n            return null;\n        }\n        if (!(firstNonNullKey instanceof Serializable) ||!(firstNonNullValue instanceof Serializable)) {\n            return objectMapperWrapper.clone(object);\n        }\n    }\n    if (object instanceof JsonNode) {\n        return objectMapperWrapper.clone(object);\n    }\n    if (object instanceof Serializable) {\n        return SerializationHelper.clone((Serializable) object);\n    }\n    return objectMapperWrapper.clone(object);\n}\n[/java]\n"]}
{"id": 40, "name": "sign", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsign\n\n### Left context\n```Java\n/*\n * Copyright (c) 2023 OceanBase.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.oceanbase.odc.service.iam;\n\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.integration.jdbc.lock.JdbcLockRegistry;\nimport org.springframework.stereotype.Service;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTCreator;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.exceptions.TokenExpiredException;\nimport com.auth0.jwt.interfaces.Claim;\nimport com.oceanbase.odc.metadb.config.SystemConfigEntity;\nimport com.oceanbase.odc.service.config.SystemConfigService;\nimport com.oceanbase.odc.service.config.model.Configuration;\n\nimport lombok.extern.slf4j.Slf4j;\n\n@Service\n@Slf4j\npublic class JwtService {\n\n    private static final long TRY_LOCK_TIMEOUT_SECONDS = 5;\n    private static final String LOCK_KEY = \"ODC_JWT_SECRET_LOCK_KEY\";\n    private static final String ENCRYPTION_JWT_KEY_SYSTEM_CONFIG_KEY = \"odc.iam.auth.jwt.secret-key\";\n    @Autowired\n    private JwtProperties jwtProperties;\n\n    /**\n     * Ensure the consistency of automatically generated jwt key in distributed mode\n     * \n     * @param\n     * @param systemConfigService\n     * @param jdbcLockRegistry\n     */\n    public JwtService(JwtProperties jwtProperties,\n            SystemConfigService systemConfigService, JdbcLockRegistry jdbcLockRegistry) {\n        try {\n            if (StringUtils.isNotBlank(jwtProperties.getTokenSecret())) {\n                return;\n            }\n            log.info(\"Try to lock odc jwt secret...\");\n            Lock lock = jdbcLockRegistry.obtain(LOCK_KEY);\n            if (lock.tryLock(TRY_LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n                try {\n                    log.info(\"Successfully acquired the jwt secret lock\");\n                    List<Configuration> list = systemConfigService.queryByKeyPrefix(\n                            ENCRYPTION_JWT_KEY_SYSTEM_CONFIG_KEY);\n                    if (verifySystemConfig(list)) {\n                        jwtProperties.setTokenSecret(list.get(0).getValue());\n                    } else {\n                        String tokenSecret = UUID.randomUUID().toString();\n                        jwtProperties.setTokenSecret(tokenSecret);\n                        SystemConfigEntity jwtSecretKey =\n                                createSystemConfigEntity(ENCRYPTION_JWT_KEY_SYSTEM_CONFIG_KEY,\n                                        tokenSecret, \"ODC jwt secret key\");\n                        systemConfigService.upsert(Collections.singletonList(jwtSecretKey));\n                    }\n\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                log.info(\n                        \"Failed to get jwt secret lock, try to get jwt secret from system configuration\");\n                List<Configuration> list =\n                        systemConfigService.queryByKeyPrefix(ENCRYPTION_JWT_KEY_SYSTEM_CONFIG_KEY);\n                if (verifySystemConfig(list)) {\n                    jwtProperties.setTokenSecret(list.get(0).getValue());;\n                } else {\n                    throw new RuntimeException(\"Failed to get jwt secret from system configuration\");\n                }\n            }\n        } catch (Exception e) {\n            log.warn(\"Failed to init jwt secret, message={}\", e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    private boolean verifySystemConfig(List<Configuration> key) {\n        return key != null && !key.isEmpty() && Objects.nonNull(key.get(0))\n                && StringUtils.isNotBlank(key.get(0).getValue());\n    }\n\n    private SystemConfigEntity createSystemConfigEntity(String key, String value, String description) {\n        SystemConfigEntity entity = new SystemConfigEntity();\n        entity.setKey(key);\n        entity.setValue(value);\n        entity.setDescription(description);\n        return entity;\n    }\n\n    /**\n     * Generate the jwtToken\n     *\n     * @param map\n     * @return\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method is used to sign a JWT token with the provided map of claims.\n * \n * @param map A map of claims to be included in the JWT token.\n * @return A signed JWT token as a string, or null if an error occurs during signing.\n */\npublic String sign(Map<String, Object> map)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public String sign(Map<String, Object> map) {\n        try {\n            Date date = new Date(System.currentTimeMillis() + jwtProperties.getExpireTimeMills());\n            Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret());\n            Map<String, Object> header = new HashMap<>(2);\n            header.put(\"typ\", \"jwt\");\n            JWTCreator.Builder builder = JWT.create()\n                    .withHeader(header)\n                    .withIssuedAt(new Date())\n                    .withExpiresAt(date);\n            map.entrySet().forEach(entry -> {\n                if (entry.getValue() instanceof Integer) {\n                    builder.withClaim(entry.getKey(), (Integer) entry.getValue());\n                } else if (entry.getValue() instanceof Long) {\n                    builder.withClaim(entry.getKey(), (Long) entry.getValue());\n                } else if (entry.getValue() instanceof Boolean) {\n                    builder.withClaim(entry.getKey(), (Boolean) entry.getValue());\n                } else if (entry.getValue() instanceof String) {\n                    builder.withClaim(entry.getKey(), String.valueOf(entry.getValue()));\n                } else if (entry.getValue() instanceof Double) {\n                    builder.withClaim(entry.getKey(), (Double) entry.getValue());\n                } else if (entry.getValue() instanceof Date) {\n                    builder.withClaim(entry.getKey(), (Date) entry.getValue());\n                }\n            });\n            return builder.sign(algorithm);\n        } catch (Exception e) {\n            return null;\n        }\n    }", "completions": ["  \n[Java]  \n[Markdown]  \n```java\npublic String sign(Map<String, Object> map) {\n    try {\n        Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret());\n        JWTCreator.Builder builder = JWT.create();\n        map.forEach((key, value) -> builder.withClaim(key, value));\n        return builder.sign(algorithm);\n    } catch (Exception e) {\n        log.warn(\"Failed to sign JWT token, message={}\", e.getMessage());\n        return null;\n    }\n}\n```"]}
{"id": 41, "name": "isJson", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nisJson\n\n### Left context\n```Java\n/*\n*Copyright (c) Alibaba Group;\n*Licensed under the Apache License, Version 2.0 (the \"License\");\n*you may not use this file except in compliance with the License.\n*You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n*Unless required by applicable law or agreed to in writing, software\n*distributed under the License is distributed on an \"AS IS\" BASIS,\n*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*See the License for the specific language governing permissions and\n*limitations under the License.\n*/\n\npackage org.example.common.utils;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.gson.ExclusionStrategy;\nimport com.google.gson.FieldAttributes;\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport com.google.gson.internal.LinkedTreeMap;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n@Slf4j\npublic class JsonUtil {\n\n    private static final String PERIOD = \".\";\n\n    private static final Gson GSON_WITH_NULL = new GsonBuilder().serializeNulls().create();\n\n    private static final Gson GSON_UPPER_CAMEL_CASE = getUpperGson();\n\n    public static Gson GSON = getGson();\n\n    private static ObjectMapper mapper = new ObjectMapper();\n\n    public static String toJsonString(Object object) {\n        return GSON.toJson(object);\n    }\n\n    public static String toJsonStringExcludeFields(Object object, List<String> fieldList) {\n        Gson gson = new GsonBuilder().addSerializationExclusionStrategy(new ExclusionStrategy() {\n            @Override\n            public boolean shouldSkipField(FieldAttributes fieldAttributes) {\n                return fieldList.contains(fieldAttributes.getName());\n            }\n\n            @Override\n            public boolean shouldSkipClass(Class<?> arg0) {\n                return false;\n            }\n        }).create();\n        return gson.toJson(object);\n    }\n\n    public static String toJsonStringWithNull(Object object) {\n        return GSON_WITH_NULL.toJson(object);\n    }\n\n    public static <T> T parseObject(String json, Class<T> classOfT) {\n        return GSON.fromJson(json, classOfT);\n    }\n\n    public static <T> T parseObjectCustom(String json, Class<T> classOfT) {\n        JsonReader reader = new JsonReader(new StringReader(json));\n        reader.setLenient(true);\n        try {\n            return (T) read(reader);\n        } catch (IOException e) {\n            log.error(\"Json processing exception.\", e);\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Object read(JsonReader in) throws IOException {\n        JsonToken token = in.peek();\n        //判断字符串的实际类型\n        switch (token) {\n            case BEGIN_ARRAY:\n                List<Object> list = new ArrayList<>();\n                in.beginArray();\n                while (in.hasNext()) {\n                    list.add(read(in));\n                }\n                in.endArray();\n                return list;\n\n            case BEGIN_OBJECT:\n                Map<String, Object> map = new LinkedTreeMap<>();\n                in.beginObject();\n                while (in.hasNext()) {\n                    map.put(in.nextName(), read(in));\n                }\n                in.endObject();\n                return map;\n            case STRING:\n                return in.nextString();\n            case NUMBER:\n                String s = in.nextString();\n                if (s.contains(\".\")) {\n                    return Double.valueOf(s);\n                } else {\n                    return Long.valueOf(s);\n                }\n            case BOOLEAN:\n                return in.nextBoolean();\n            case NULL:\n                in.nextNull();\n                return null;\n            default:\n                throw new IllegalStateException();\n        }\n    }\n\n    public static <T> T parseJsonList(String jsonStr, Type typeOfT) {\n        Gson gson = new Gson();\n        return gson.fromJson(jsonStr, typeOfT);\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Checks if a given string is a valid JSON.\n *\n * @param value The string to be checked.\n * @return True if the string is a valid JSON, false otherwise.\n * @throws JsonSyntaxException If the string cannot be parsed as JSON.\n */\npublic static Boolean isJson(String value)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static Boolean isJson(String value) {\n        JsonElement jsonElement;\n        try {\n            jsonElement = JsonParser.parseString(value);\n        } catch (Exception e) {\n            return false;\n        }\n        if (jsonElement == null || jsonElement.isJsonNull()) {\n            return false;\n        }\n        if (!jsonElement.isJsonObject() && !jsonElement.isJsonArray()) {\n            return false;\n        }\n        return true;\n    }", "completions": ["  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    } catch (JsonSyntaxException e) {\n        return false;\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static Boolean isJson(String value) {\n    try {\n        new JsonParser().parse(value);\n        return true;\n    }"]}
{"id": 44, "name": "serialize", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nserialize\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.netease.arctic.flink.lookup;\n\nimport org.apache.commons.collections.CollectionUtils;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/** Utility class for serializing and deserializing a set of ByteArrayWrapper objects. */\npublic class ByteArraySetSerializer {\n\n  /**\n   * Deserializes a byte array into a set of ByteArrayWrapper objects.\n   *\n   * @param byteArray the byte array to deserialize\n   * @return the deserialized set of ByteArrayWrapper objects\n   */\n  public static Set<ByteArrayWrapper> deserialize(byte[] byteArray) {\n    if (byteArray == null) {\n      return Collections.emptySet();\n    }\n\n    Set<ByteArrayWrapper> set = new HashSet<>();\n\n    ByteBuffer buffer = ByteBuffer.wrap(byteArray);\n    int setSize = buffer.getInt(); // Read the size of the set\n\n    for (int i = 0; i < setSize; i++) {\n      int elementSize = buffer.getInt(); // Read the size of the element\n      byte[] element = new byte[elementSize];\n      buffer.get(element); // Read the element bytes\n      ByteArrayWrapper baw = new ByteArrayWrapper(element, elementSize);\n      set.add(baw);\n    }\n\n    return set;\n  }\n\n  /**\n   * Serializes a set of ByteArrayWrapper objects into a byte array.\n   *\n   * @param set the set of ByteArrayWrapper objects to serialize\n   * @return the serialized byte array\n   */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Serializes a set of ByteArrayWrapper objects into a byte array.\n * \n * @param set The set of ByteArrayWrapper objects to be serialized.\n * @return The serialized byte array. Returns null if the input set is empty.\n * @see org.apache.commons.collections.CollectionUtils#isEmpty(Collection)\n */\npublic static byte[] serialize(Set<ByteArrayWrapper> set)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public static byte[] serialize(Set<ByteArrayWrapper> set) {\n    if (CollectionUtils.isEmpty(set)) {\n      return null;\n    }\n\n    // Calculate the total size of the resulting byte array\n    // The first 4 bytes represent the size of the set\n    int totalSize = 4;\n    for (ByteArrayWrapper record : set) {\n      // Each element consists of 4 bytes representing the size of the element\n      totalSize += 4;\n      totalSize += record.size;\n    }\n\n    // Create a new byte array with the total size\n    ByteBuffer buffer = ByteBuffer.allocate(totalSize);\n    buffer.putInt(set.size()); // Write the size of the set\n\n    for (ByteArrayWrapper record : set) {\n      buffer.putInt(record.size); // Write the size of the element\n      buffer.put(record.bytes); // Write the element bytes\n    }\n\n    return buffer.array();\n  }", "completions": ["  \n[java]\npublic static byte[] serialize(Set<ByteArrayWrapper> set) {\n    if (CollectionUtils.isEmpty(set)) {\n        return null;\n    }\n\n    ByteBuffer buffer = ByteBuffer.allocate(set.size() * 4 + 4);\n    buffer.putInt(set.size());\n\n    for (ByteArrayWrapper baw : set) {\n        buffer.putInt(baw.getSize());\n        buffer.put(baw.getData());\n    }\n\n    return buffer.array();\n}\n[/java]\n"]}
{"id": 45, "name": "collect", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ncollect\n\n### Left context\n```Java\npackage org.dromara.hertzbeat.collector.collect.dns;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.dromara.hertzbeat.collector.collect.AbstractCollect;\nimport org.dromara.hertzbeat.collector.dispatch.DispatchConstants;\nimport org.dromara.hertzbeat.common.constants.CommonConstants;\nimport org.dromara.hertzbeat.common.entity.job.Metrics;\nimport org.dromara.hertzbeat.common.entity.job.protocol.DnsProtocol;\nimport org.dromara.hertzbeat.common.entity.message.CollectRep;\nimport org.dromara.hertzbeat.common.util.CommonUtil;\nimport org.springframework.util.StopWatch;\nimport org.xbill.DNS.DClass;\nimport org.xbill.DNS.Message;\nimport org.xbill.DNS.Name;\nimport org.xbill.DNS.Opcode;\nimport org.xbill.DNS.RRset;\nimport org.xbill.DNS.Rcode;\nimport org.xbill.DNS.Record;\nimport org.xbill.DNS.Resolver;\nimport org.xbill.DNS.Section;\nimport org.xbill.DNS.SimpleResolver;\nimport org.xbill.DNS.Type;\n\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * dns protocol collection implementation\n * @author Calvin\n */\n@Slf4j\npublic class DnsCollectImpl extends AbstractCollect {\n    /*\n     each part of dig command output\n     */\n    private static final String HEADER = \"header\";\n    private static final String QUESTION = \"question\";\n    private static final String ANSWER = \"answer\";\n    private static final String AUTHORITY = \"authority\";\n    private static final String ADDITIONAL = \"additional\";\n    /*\n     * used for header key\n     * example:\n     * ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 3221\n     * ;; flags: qr rd ra ; qd: 1 an: 1 au: 0 ad: 0\n     *\n     *\n     * opcode -> opcode\n     * status -> status\n     * flags -> flags\n     * qd -> questionRowCount\n     * an -> answerRowCount\n     * au -> authorityRowCount\n     * ad -> additionalRowCount\n     */\n    private static final String RESPONSE_TIME = \"responseTime\";\n    private static final String OP_CODE = \"opcode\";\n    private static final String STATUS = \"status\";\n    private static final String FLAGS = \"flags\";\n    private static final String QUESTION_ROW_COUNT = \"questionRowCount\";\n    private static final String ANSWER_ROW_COUNT = \"answerRowCount\";\n    private static final String AUTHORITY_ROW_COUNT = \"authorityRowCount\";\n    private static final String ADDITIONAL_ROW_COUNT = \"additionalRowCount\";\n\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method collects metrics data and builds a response.\n * It checks the DNS protocol parameter and runs a dig command.\n * If there is an IOException or an Exception, it logs the error and sets the response code and message accordingly.\n * If the DNS protocol parameter is valid, it builds the DNS metrics data and adds it to the response.\n * \n * @param builder The builder for the metrics data.\n * @param monitorId The ID of the monitor.\n * @param app The application name.\n * @param metrics The metrics object.\n */\n@Override\npublic void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics) {\n        // check params\n        if (checkDnsProtocolFailed(metrics.getDns())) {\n            builder.setCode(CollectRep.Code.FAIL);\n            builder.setMsg(\"DNS collect must have a valid DNS protocol param! \");\n            return;\n        }\n\n        DNSResolveResult dnsResolveResult;\n        try {\n            // run dig command\n            dnsResolveResult = dig(metrics.getDns());\n        } catch (IOException e) {\n            log.info(CommonUtil.getMessageFromThrowable(e));\n            builder.setCode(CollectRep.Code.UN_CONNECTABLE);\n            builder.setMsg(e.getMessage());\n            return;\n        } catch (Exception e) {\n            String errorMsg = CommonUtil.getMessageFromThrowable(e);\n            log.warn(\"[dns collect] error: {}\", e.getMessage(), e);\n            builder.setCode(CollectRep.Code.FAIL);\n            builder.setMsg(errorMsg);\n            return;\n        }\n\n        // build dns metrics data\n        CollectRep.ValueRow.Builder valueRowBuilder = CollectRep.ValueRow.newBuilder();\n        if (StringUtils.equals(HEADER, metrics.getName())) {\n            // add header columns\n            Map<String, String> headerInfo = dnsResolveResult.getHeaderInfo();\n            metrics.getAliasFields().forEach(field -> valueRowBuilder.addColumns(headerInfo.getOrDefault(field, CommonConstants.NULL_VALUE)));\n        }else {\n            // add question/answer/authority/additional columns\n            List<String> currentMetricsResolveResultList = dnsResolveResult.getList(metrics.getName());\n            for (int index = 0; index < metrics.getAliasFields().size(); index++) {\n                valueRowBuilder.addColumns(index >= currentMetricsResolveResultList.size()\n                        ? CommonConstants.NULL_VALUE\n                        : currentMetricsResolveResultList.get(index));\n            }\n        }\n\n        builder.addValues(valueRowBuilder.build());\n    }", "completions": ["  \n[java]\n```\n@Override\npublic void collect(CollectRep.MetricsData.Builder builder, long monitorId, String app, Metrics metrics) {\n    // Check if the DNS protocol parameter is valid\n    if (metrics.getProtocol() == null ||!metrics.getProtocol().equals(DnsProtocol.DNS)) {\n        log.error(\"Invalid DNS protocol parameter: {}\", metrics.getProtocol());\n        builder.setCode(CommonConstants.EXCEPTION_CODE);\n        builder.setMessage(\"Invalid DNS protocol parameter\");\n        return;\n    }\n\n    // Build the DNS metrics data\n    DnsMetricsData.Builder dnsBuilder = DnsMetricsData.newBuilder();\n    dnsBuilder.setMonitorId(monitorId);\n    dnsBuilder.setApp(app);\n    dnsBuilder.setProtocol(metrics.getProtocol());\n    dnsBuilder.setResponseTime(metrics.getResponseTime());\n    dnsBuilder.setOpCode(metrics.getOpCode());\n    dnsBuilder.setStatus(metrics.getStatus());\n    dnsBuilder.setFlags(metrics.getFlags());\n    dnsBuilder.setQuestionRowCount(metrics.getQuestionRowCount());\n    dnsBuilder.setAnswerRowCount(metrics.getAnswerRowCount());\n    dnsBuilder.setAuthorityRowCount(metrics.getAuthorityRowCount());\n    dnsBuilder.setAdditionalRowCount(metrics.getAdditionalRowCount());\n\n    // Add the DNS metrics data to the response\n    builder.setDns(dnsBuilder.build());\n}\n```\n[/java]\n"]}
{"id": 46, "name": "zip", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nzip\n\n### Left context\n```Java\npackage com.baeldung.commons.compress;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.ArchiveStreamFactory;\nimport org.apache.commons.compress.archivers.examples.Archiver;\nimport org.apache.commons.compress.archivers.examples.Expander;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.apache.commons.compress.compressors.CompressorInputStream;\nimport org.apache.commons.compress.compressors.CompressorOutputStream;\nimport org.apache.commons.compress.compressors.CompressorStreamFactory;\nimport org.apache.commons.compress.utils.FileNameUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\n\npublic class CompressUtils {\n\n    private CompressUtils() {\n    }\n\n    public static void archive(Path directory, Path destination) throws IOException, ArchiveException {\n        String format = FileNameUtils.getExtension(destination);\n        new Archiver().create(format, destination, directory);\n    }\n\n    public static void archiveAndCompress(String directory, Path destination) throws IOException, ArchiveException, CompressorException {\n        archiveAndCompress(Paths.get(directory), destination);\n    }\n\n    public static void archiveAndCompress(Path directory, Path destination) throws IOException, ArchiveException, CompressorException {\n        String compressionFormat = FileNameUtils.getExtension(destination);\n        String archiveFormat = FilenameUtils.getExtension(destination.getFileName()\n            .toString()\n            .replace(\".\" + compressionFormat, \"\"));\n\n        try (OutputStream archive = Files.newOutputStream(destination);\n            BufferedOutputStream archiveBuffer = new BufferedOutputStream(archive);\n            CompressorOutputStream compressor = new CompressorStreamFactory().createCompressorOutputStream(compressionFormat, archiveBuffer);\n            ArchiveOutputStream<?> archiver = new ArchiveStreamFactory().createArchiveOutputStream(archiveFormat, compressor)) {\n            new Archiver().create(archiver, directory);\n        }\n    }\n\n    public static void decompress(Path file, Path destination) throws IOException, ArchiveException, CompressorException {\n        decompress(Files.newInputStream(file), destination);\n    }\n\n    public static void decompress(InputStream file, Path destination) throws IOException, ArchiveException, CompressorException {\n        try (InputStream in = file;\n            BufferedInputStream inputBuffer = new BufferedInputStream(in);\n            OutputStream out = Files.newOutputStream(destination);\n            CompressorInputStream decompressor = new CompressorStreamFactory().createCompressorInputStream(inputBuffer)) {\n            IOUtils.copy(decompressor, out);\n        }\n    }\n\n    public static void extract(Path archive, Path destination) throws IOException, ArchiveException, CompressorException {\n        new Expander().expand(archive, destination);\n    }\n\n    public static void compressFile(Path file, Path destination) throws IOException, CompressorException {\n        String format = FileNameUtils.getExtension(destination);\n\n        try (OutputStream out = Files.newOutputStream(destination); \n            BufferedOutputStream buffer = new BufferedOutputStream(out);\n            CompressorOutputStream compressor = new CompressorStreamFactory().createCompressorOutputStream(format, buffer)) {\n            IOUtils.copy(Files.newInputStream(file), compressor);\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Compresses a file into a ZIP archive using the best compression level.\n *\n * @param file The file to be compressed.\n * @param destination The destination path for the compressed file.\n * @throws IOException If an I/O error occurs.\n */\npublic static void zip(Path file, Path destination) throws IOException\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static void zip(Path file, Path destination) throws IOException {\n        try (InputStream input = Files.newInputStream(file);\n            OutputStream output = Files.newOutputStream(destination);\n            ZipArchiveOutputStream archive = new ZipArchiveOutputStream(output)) {\n            archive.setLevel(Deflater.BEST_COMPRESSION);\n            archive.setMethod(ZipEntry.DEFLATED);\n\n            archive.putArchiveEntry(new ZipArchiveEntry(file.getFileName()\n                .toString()));\n            IOUtils.copy(input, archive);\n            archive.closeArchiveEntry();\n        }\n    }", "completions": ["  \n[java]\npublic static void zip(Path file, Path destination) throws IOException {\n    // Create a new ZipArchiveOutputStream using the destination path\n    try (ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(Files.newOutputStream(destination))) {\n        // Set the compression level to the best level\n        zipOut.setLevel(Deflater.BEST_COMPRESSION);\n\n        // Create a new ZipArchiveEntry for the file to be compressed\n        ZipArchiveEntry zipEntry = new ZipArchiveEntry(file.getFileName().toString());\n\n        // Add the ZipArchiveEntry to the ZipArchiveOutputStream\n        zipOut.putArchiveEntry(zipEntry);\n\n        // Copy the file to the ZipArchiveOutputStream\n        IOUtils.copy(Files.newInputStream(file), zipOut);\n\n        // Close the ZipArchiveEntry\n        zipOut.closeArchiveEntry();\n    }\n}\n[/java]\n"]}
{"id": 47, "name": "unTarZip", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nunTarZip\n\n### Left context\n```Java\npackage io.tapdata.observable.metric.py;\n\nimport io.tapdata.entity.error.CoreException;\nimport io.tapdata.exception.TapCodeException;\nimport io.tapdata.observable.metric.py.error.PythonScriptProcessorExCode_31;\nimport io.tapdata.pdk.core.error.PDKRunnerErrorCodes;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\npublic class ZipUtils {\n    private static final int BUFFER_SIZE = 16 * 1024;\n\n    public static void zip(String srcDir, OutputStream out) {\n        zip(srcDir, out, true, true);\n    }\n\n    public static void zip(File srcDir, OutputStream out) {\n        zip(srcDir, out, true, true);\n    }\n\n\n    public static void zip(String srcDir, OutputStream out, boolean keepDirStructure, boolean zipInsideDirectory)\n            throws RuntimeException {\n\n        if (srcDir == null || out == null)\n            throw new CoreException(PDKRunnerErrorCodes.COMMON_ILLEGAL_PARAMETERS, \"Zip missing srcDir or out\");\n        File srcDirFile = new File(srcDir);\n        if (srcDirFile.isFile())\n            throw new CoreException(PDKRunnerErrorCodes.CLI_ZIP_DIR_IS_FILE, \"Zip director is a file, expect to be directory or none\");\n        zip(srcDirFile, out, keepDirStructure, zipInsideDirectory);\n    }\n\n    public static void zip(File srcDir, OutputStream out, boolean keepdirstructure, boolean zipInsideDirectory)\n            throws TapCodeException {\n        try(ZipOutputStream zos = new ZipOutputStream(out)) {\n            if(zipInsideDirectory && srcDir.isDirectory()) {\n                File[] listFiles = srcDir.listFiles();\n                for(File file : listFiles) {\n                    compress(file, zos, file.getName(), keepdirstructure);\n                }\n            } else {\n                compress(srcDir, zos, srcDir.getName(), keepdirstructure);\n            }\n        } catch (Exception e) {\n            throw new TapCodeException(PythonScriptProcessorExCode_31.PYTHON_SCRIPT_ZIP_FAILED,String.format(\"zip error from ZipUtils failed,fileName:%s,filePath:%s\", srcDir.getName(),srcDir.getPath()));\n        }\n    }\n\n    private static void compress(File sourceFile, ZipOutputStream zos, String name,\n                                 boolean KeepDirStructure) throws Exception {\n        byte[] buf = new byte[BUFFER_SIZE];\n        if (sourceFile.isFile()) {\n            // 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字\n            zos.putNextEntry(new ZipEntry(name));\n            // copy文件到zip输出流中\n            int len;\n            try (FileInputStream in = new FileInputStream(sourceFile)) {\n                while ((len = in.read(buf)) != -1) {\n                    zos.write(buf, 0, len);\n                }\n                // Complete the entry\n                zos.closeEntry();\n            }\n        } else {\n            File[] listFiles = sourceFile.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                // 需要保留原来的文件结构时,需要对空文件夹进行处理\n                if (KeepDirStructure) {\n                    // 空文件夹的处理\n                    zos.putNextEntry(new ZipEntry(name + \"/\"));\n                    // 没有文件，不需要文件的copy\n                    zos.closeEntry();\n                }\n\n            } else {\n                for (File file : listFiles) {\n                    // 判断是否需要保留原来的文件结构\n                    if (KeepDirStructure) {\n                        // 注意：file.getName()前面需要带上父文件夹的名字加一斜杠,\n                        // 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了\n                        compress(file, zos, name + \"/\" + file.getName(), true);\n                    } else {\n                        compress(file, zos, file.getName(), false);\n                    }\n\n                }\n            }\n        }\n    }\n\n    public static void unzip(String zipFile, String outputPath) {\n        if (zipFile == null || outputPath == null)\n            throw new CoreException(PDKRunnerErrorCodes.COMMON_ILLEGAL_PARAMETERS, \"Unzip missing zipFile or outputPath\");\n        File outputDir = new File(outputPath);\n        if (outputDir.isFile())\n            throw new CoreException(PDKRunnerErrorCodes.CLI_UNZIP_DIR_IS_FILE, \"Unzip director is a file, expect to be directory or none\");\n        if (zipFile.endsWith(\".tar.gz\") || zipFile.endsWith(\".gz\")){\n            unTarZip(zipFile, outputPath);\n        } else {\n            unzip(zipFile, outputDir);\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method is used to decompress a tar.gz file to a specified directory.\n * It uses the TarArchiveInputStream and GzipCompressorInputStream classes from Apache Commons Compress to handle the tar.gz file.\n * The method reads each entry from the tar file and checks if it's a directory. If it's not, it creates the parent directories if they don't exist,\n * and then writes the file to the specified directory using IOUtils.copy from Apache Commons IO.\n *\n * @param tarFilePath The path of the tar.gz file to be decompressed.\n * @param targetDirectoryPath The path of the directory where the decompressed files will be placed.\n * @throws CoreException If the target directory is a file, not a directory or none, an exception is thrown with the error message.\n */\npublic static void unTarZip(String tarFilePath, String targetDirectoryPath)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static void unTarZip(String tarFilePath, String targetDirectoryPath){\n        File sourceFile = new File(tarFilePath);\n        try (TarArchiveInputStream fin = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(sourceFile)))) {\n            // decompressing *.tar.gz files to tar\n            File extraceFolder = new File(targetDirectoryPath);\n            TarArchiveEntry entry;\n            // 将 tar 文件解压到 extractPath 目录下\n            while ((entry = fin.getNextTarEntry()) != null) {\n                if (entry.isDirectory()) {\n                    continue;\n                }\n                File curfile = new File(extraceFolder, entry.getName());\n                File parent = curfile.getParentFile();\n                if (!parent.exists()) {\n                    parent.mkdirs();\n                }\n                // 将文件写出到解压的目录\n                try (FileOutputStream fileOutputStream = new FileOutputStream(curfile)){\n                    IOUtils.copy(fin, fileOutputStream);\n                }\n            }\n        } catch (Exception e){\n            throw new CoreException(PDKRunnerErrorCodes.CLI_UNZIP_DIR_IS_FILE, \"Unzip director is a file, expect to be directory or none, \" + e.getMessage());\n        }\n    }", "completions": ["  ```\npublic static void unTarZip(String tarFilePath, String targetDirectoryPath) {\n    try (TarArchiveInputStream tarIn = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(tarFilePath)))) {\n        TarArchiveEntry entry;\n        while ((entry = tarIn.getNextTarEntry())!= null) {\n            if (!entry.isDirectory()) {\n                File file = new File(targetDirectoryPath, entry.getName());\n                if (!file.getParentFile().exists()) {\n                    file.getParentFile().mkdirs();\n                }\n                IOUtils.copy(tarIn, new FileOutputStream(file));\n            }\n        }\n    } catch (IOException e) {\n        throw new CoreException(PDKRunnerErrorCodes.COMMON_IO_ERROR, \"Error while decompressing tar.gz file: \" + e.getMessage());\n    }\n}\n```"]}
{"id": 49, "name": "setUserData", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsetUserData\n\n### Left context\n```Java\n/*-\n * #%L\n * HAPI FHIR - Core Library\n * %%\n * Copyright (C) 2014 - 2024 Smile CDR, Inc.\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n */\npackage ca.uhn.fhir.model.api;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport org.apache.commons.lang3.Validate;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\npublic abstract class BaseBatchJobParameters implements IModelJson {\n\t/**\n\t * A serializable map of key-value pairs that can be\n\t * added to any extending job.\n\t */\n\t@JsonProperty(\"userData\")\n\tprivate Map<String, Object> myUserData;\n\n\tpublic Map<String, Object> getUserData() {\n\t\tif (myUserData == null) {\n\t\t\tmyUserData = new HashMap<>();\n\t\t}\n\t\treturn myUserData;\n\t}\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Sets the user data for a given key.\n *\n * @param theKey the key for the user data. Must be non-empty and non-null.\n * @param theValue the value for the user data. If null, the key-value pair will be removed.\n *                 Otherwise, the value must be validated by the `validateValue` method.\n *                 If the value is not valid, an exception will be thrown.\n * @throws IllegalArgumentException if the key is empty or null.\n * @throws IllegalArgumentException if the value is not valid according to `validateValue`.\n */\npublic void setUserData(String theKey, Object theValue)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "\tpublic void setUserData(String theKey, Object theValue) {\n\t\tValidate.isTrue(isNotBlank(theKey), \"Invalid key; key must be non-empty, non-null.\");\n\t\tif (theValue == null) {\n\t\t\tgetUserData().remove(theKey);\n\t\t} else {\n\t\t\tValidate.isTrue(\n\t\t\t\t\tvalidateValue(theValue),\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Invalid data type provided %s\", theValue.getClass().getName()));\n\t\t\tgetUserData().put(theKey, theValue);\n\t\t}\n\t}", "completions": ["  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);\n    } else {\n        validateValue(theValue);\n        getUserData().put(theKey, theValue);\n    }\n}\n```\n[/markdown]  \n[markdown]```\npublic void setUserData(String theKey, Object theValue) {\n    Validate.notBlank(theKey, \"theKey must not be blank\");\n    if (theValue == null) {\n        getUserData().remove(theKey);"]}
{"id": 50, "name": "submit", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsubmit\n\n### Left context\n```Java\n/*\n * Copyright (c) 2023 OceanBase.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.oceanbase.odc.service.partitionplan;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport javax.transaction.Transactional;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.quartz.SchedulerException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.oceanbase.odc.common.json.JsonUtils;\nimport com.oceanbase.odc.core.authority.util.SkipAuthorize;\nimport com.oceanbase.odc.core.flow.model.TaskParameters;\nimport com.oceanbase.odc.core.shared.constant.FlowStatus;\nimport com.oceanbase.odc.core.shared.constant.TaskErrorStrategy;\nimport com.oceanbase.odc.metadb.flow.FlowInstanceRepository;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanEntity;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanRepository;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanTableEntity;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanTablePartitionKeyEntity;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanTablePartitionKeyRepository;\nimport com.oceanbase.odc.metadb.partitionplan.PartitionPlanTableRepository;\nimport com.oceanbase.odc.metadb.schedule.ScheduleEntity;\nimport com.oceanbase.odc.service.connection.database.DatabaseService;\nimport com.oceanbase.odc.service.connection.database.model.Database;\nimport com.oceanbase.odc.service.flow.FlowInstanceService;\nimport com.oceanbase.odc.service.flow.model.FlowInstanceDetailResp;\nimport com.oceanbase.odc.service.iam.auth.AuthenticationFacade;\nimport com.oceanbase.odc.service.partitionplan.model.PartitionPlanConfig;\nimport com.oceanbase.odc.service.partitionplan.model.PartitionPlanKeyConfig;\nimport com.oceanbase.odc.service.partitionplan.model.PartitionPlanStrategy;\nimport com.oceanbase.odc.service.partitionplan.model.PartitionPlanTableConfig;\nimport com.oceanbase.odc.service.quartz.model.MisfireStrategy;\nimport com.oceanbase.odc.service.schedule.ScheduleService;\nimport com.oceanbase.odc.service.schedule.model.JobType;\nimport com.oceanbase.odc.service.schedule.model.ScheduleStatus;\nimport com.oceanbase.odc.service.schedule.model.TriggerConfig;\n\nimport lombok.NonNull;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * {@link PartitionPlanScheduleService}\n *\n * @author yh263208\n * @date 2024-02-05 19:27\n * @since ODC_release_4.2.4\n */\n@Slf4j\n@Service\n@SkipAuthorize(\"odc internal usage\")\npublic class PartitionPlanScheduleService {\n\n    @Autowired\n    private AuthenticationFacade authenticationFacade;\n    @Autowired\n    private DatabaseService databaseService;\n    @Autowired\n    private ScheduleService scheduleService;\n    @Autowired\n    private PartitionPlanTableRepository partitionPlanTableRepository;\n    @Autowired\n    private PartitionPlanRepository partitionPlanRepository;\n    @Autowired\n    private PartitionPlanTablePartitionKeyRepository partitionPlanTablePartitionKeyRepository;\n    @Autowired\n    private FlowInstanceService flowInstanceService;\n    @Autowired\n    private FlowInstanceRepository flowInstanceRepository;\n\n    public PartitionPlanConfig getPartitionPlanByFlowInstanceId(@NonNull Long flowInstanceId) {\n        FlowInstanceDetailResp resp = this.flowInstanceService.detail(flowInstanceId);\n        Optional<PartitionPlanEntity> optional = this.partitionPlanRepository.findByFlowInstanceId(resp.getId());\n        if (optional.isPresent()) {\n            return optional.map(this::getPartitionPlan).get();\n        }\n        TaskParameters parameters = resp.getParameters();\n        if (!(parameters instanceof PartitionPlanConfig)) {\n            return null;\n        }\n        PartitionPlanConfig partitionPlanConfig = (PartitionPlanConfig) parameters;\n        partitionPlanConfig.setEnabled(false);\n        if (CollectionUtils.isNotEmpty(partitionPlanConfig.getPartitionTableConfigs())) {\n            partitionPlanConfig.getPartitionTableConfigs().forEach(t -> t.setEnabled(false));\n        }\n        return partitionPlanConfig;\n    }\n\n    public PartitionPlanConfig getPartitionPlanByDatabaseId(@NonNull Long databaseId) {\n        Database database = this.databaseService.detail(databaseId);\n        List<PartitionPlanEntity> planEntities = this.partitionPlanRepository\n                .findByDatabaseIdAndEnabled(database.getId(), true);\n        if (CollectionUtils.isEmpty(planEntities)) {\n            return null;\n        } else if (planEntities.size() > 1) {\n            throw new IllegalStateException(\"Unknown error, there are \"\n                    + planEntities.size() + \" partition plans are active, databaseId=\" + databaseId);\n        }\n        return getPartitionPlan(planEntities.get(0));\n    }\n\n    public List<PartitionPlanTableConfig> getPartitionPlanTables(@NonNull List<Long> partitionPlanTableIds) {\n        List<PartitionPlanTableEntity> ppts = this.partitionPlanTableRepository.findByIdIn(partitionPlanTableIds);\n        if (CollectionUtils.isEmpty(ppts)) {\n            return Collections.emptyList();\n        }\n        List<PartitionPlanTableConfig> tableConfigs = ppts.stream()\n                .map(this::entityToModel).collect(Collectors.toList());\n        Map<Long, List<PartitionPlanTablePartitionKeyEntity>> pptId2KeyEntities =\n                this.partitionPlanTablePartitionKeyRepository.findByPartitionplanTableIdIn(tableConfigs.stream()\n                        .map(PartitionPlanTableConfig::getId).collect(Collectors.toList())).stream()\n                        .collect(Collectors.groupingBy(PartitionPlanTablePartitionKeyEntity::getPartitionplanTableId));\n        tableConfigs.forEach(tableConfig -> {\n            List<PartitionPlanTablePartitionKeyEntity> pptks = pptId2KeyEntities.get(tableConfig.getId());\n            if (CollectionUtils.isEmpty(pptks)) {\n                return;\n            }\n            tableConfig.setPartitionKeyConfigs(pptks.stream().map(this::entityToModel).collect(Collectors.toList()));\n        });\n        return tableConfigs;\n    }\n\n    /**\n     * submit a partition plan task\n     *\n     * @param partitionPlanConfig config for a partition plan\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method submits a partition plan configuration for execution. It disables all related partition plan tasks, saves the configuration, and if enabled and table configurations are present, it creates and enables schedules for partition plan table creation and dropping.\n * \n * @param partitionPlanConfig The partition plan configuration to be submitted.\n * @throws SchedulerException If there is an error with the scheduler.\n * @throws ClassNotFoundException If a class is not found.\n */\n@Transactional(rollbackOn = Exception.class)\npublic void submit(@NonNull PartitionPlanConfig partitionPlanConfig) throws SchedulerException, ClassNotFoundException\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Transactional(rollbackOn = Exception.class)\n    public void submit(@NonNull PartitionPlanConfig partitionPlanConfig)\n            throws SchedulerException, ClassNotFoundException {\n        Long databaseId = partitionPlanConfig.getDatabaseId();\n        Validate.notNull(databaseId, \"DatabaseId can not be null\");\n        // disable all related partition plan task\n        Database database = this.databaseService.detail(databaseId);\n        disablePartitionPlan(database.getId());\n        PartitionPlanEntity partitionPlanEntity = modelToEntity(partitionPlanConfig);\n        partitionPlanEntity = this.partitionPlanRepository.save(partitionPlanEntity);\n        if (!partitionPlanConfig.isEnabled()\n                || CollectionUtils.isEmpty(partitionPlanConfig.getPartitionTableConfigs())) {\n            log.info(\"Partition plan is disabled or table config is empty, do nothing and return\");\n            return;\n        }\n        Validate.isTrue(partitionPlanConfig.getCreationTrigger() != null, \"Creation trigger can not be null\");\n        if (partitionPlanConfig.getDroppingTrigger() == null) {\n            ScheduleEntity createScheduleEntity = createAndEnableSchedule(\n                    database, partitionPlanConfig.getCreationTrigger());\n            createPartitionPlanTables(partitionPlanConfig.getPartitionTableConfigs(),\n                    partitionPlanEntity.getId(), createScheduleEntity.getId(),\n                    partitionPlanConfig.getFlowInstanceId(), partitionPlanConfig.getTaskId(),\n                    partitionPlanConfig.getErrorStrategy(), partitionPlanConfig.getTimeoutMillis());\n            return;\n        }\n        Map<PartitionPlanStrategy, List<PartitionPlanTableConfig>> strategy2TblCfgs =\n                partitionPlanConfig.getPartitionTableConfigs().stream().flatMap(tableConfig -> {\n                    Map<PartitionPlanStrategy, List<PartitionPlanKeyConfig>> strategy2Cfgs =\n                            tableConfig.getPartitionKeyConfigs().stream()\n                                    .collect(Collectors.groupingBy(PartitionPlanKeyConfig::getStrategy));\n                    return strategy2Cfgs.values().stream().map(cfgs -> {\n                        PartitionPlanTableConfig cfg = new PartitionPlanTableConfig();\n                        cfg.setPartitionKeyConfigs(cfgs);\n                        cfg.setTableName(tableConfig.getTableName());\n                        cfg.setEnabled(tableConfig.isEnabled());\n                        cfg.setPartitionNameInvoker(tableConfig.getPartitionNameInvoker());\n                        cfg.setPartitionNameInvokerParameters(tableConfig.getPartitionNameInvokerParameters());\n                        return cfg;\n                    });\n                }).collect(Collectors.groupingBy(cfg -> cfg.getPartitionKeyConfigs().get(0).getStrategy()));\n        List<PartitionPlanTableConfig> createConfigs = strategy2TblCfgs.get(PartitionPlanStrategy.CREATE);\n        List<PartitionPlanTableConfig> dropConfigs = strategy2TblCfgs.get(PartitionPlanStrategy.DROP);\n        if (CollectionUtils.isNotEmpty(createConfigs)) {\n            ScheduleEntity createScheduleEntity = createAndEnableSchedule(\n                    database, partitionPlanConfig.getCreationTrigger());\n            createPartitionPlanTables(createConfigs,\n                    partitionPlanEntity.getId(), createScheduleEntity.getId(),\n                    partitionPlanConfig.getFlowInstanceId(), partitionPlanConfig.getTaskId(),\n                    partitionPlanConfig.getErrorStrategy(), partitionPlanConfig.getTimeoutMillis());\n        }\n        if (CollectionUtils.isNotEmpty(dropConfigs)) {\n            ScheduleEntity dropScheduleEntity = createAndEnableSchedule(\n                    database, partitionPlanConfig.getDroppingTrigger());\n            createPartitionPlanTables(dropConfigs,\n                    partitionPlanEntity.getId(), dropScheduleEntity.getId(),\n                    partitionPlanConfig.getFlowInstanceId(), partitionPlanConfig.getTaskId(),\n                    partitionPlanConfig.getErrorStrategy(), partitionPlanConfig.getTimeoutMillis());\n        }\n    }", "completions": ["  \n[java]\n```\n@Transactional(rollbackOn = Exception.class)\npublic void submit(@NonNull PartitionPlanConfig partitionPlanConfig) throws SchedulerException, ClassNotFoundException {\n    // Disable all related partition plan tasks\n    disablePartitionPlanTasks(partitionPlanConfig);\n\n    // Save the configuration\n    savePartitionPlanConfig(partitionPlanConfig);\n\n    // If enabled and table configurations are present, create and enable schedules for partition plan table creation and dropping\n    if (partitionPlanConfig.isEnabled() && CollectionUtils.isNotEmpty(partitionPlanConfig.getPartitionTableConfigs())) {\n        createAndEnableSchedules(partitionPlanConfig);\n    }\n}\n\nprivate void disablePartitionPlanTasks(PartitionPlanConfig partitionPlanConfig) {\n    // Disable all related partition plan tasks\n    List<PartitionPlanEntity> partitionPlanEntities = partitionPlanRepository.findByFlowInstanceId(partitionPlanConfig.getFlowInstanceId());\n    partitionPlanEntities.forEach(partitionPlanEntity -> {\n        partitionPlanEntity.setEnabled(false);\n        partitionPlanRepository.save(partitionPlanEntity);\n    });\n}\n\nprivate void savePartitionPlanConfig(PartitionPlanConfig partitionPlanConfig) {\n    // Save the configuration\n    PartitionPlanEntity partitionPlanEntity = new PartitionPlanEntity();\n    partitionPlanEntity.setFlowInstanceId(partitionPlanConfig.getFlowInstanceId());\n    partitionPlanEntity.setEnabled(partitionPlanConfig.isEnabled());\n    partitionPlanEntity.setPartitionPlanStrategy(partitionPlanConfig.getPartitionPlanStrategy());\n    partitionPlanEntity.setPartitionKeyConfigs(partitionPlanConfig.getPartitionKeyConfigs());\n    partitionPlanEntity.setPartitionTableConfigs(partitionPlanConfig.getPartitionTableConfigs());\n    partitionPlanRepository.save(partitionPlanEntity);\n}\n\nprivate void createAndEnableSchedules(PartitionPlanConfig partitionPlanConfig) throws SchedulerException, ClassNotFoundException {\n    // Create and enable schedules for partition plan table creation and dropping\n    List<PartitionPlanTableConfig> partitionTableConfigs = partitionPlanConfig.getPartitionTableConfigs();\n    for (PartitionPlanTableConfig partitionTableConfig : partitionTableConfigs) {\n        if (partitionTableConfig.isEnabled()) {\n            createAndEnableSchedule(partitionTableConfig);\n        }\n    }\n}\n\nprivate void createAndEnableSchedule(PartitionPlanTableConfig partitionTableConfig) throws SchedulerException, ClassNotFoundException {\n    // Create and enable schedule for partition plan table creation\n    TriggerConfig triggerConfig = new TriggerConfig();\n    triggerConfig.setJobType(JobType.PARTITION_PLAN_TABLE_CREATION);\n    triggerConfig.setMisfireStrategy(MisfireStrategy.IGNORE_MISFIRE_POLICY);\n    triggerConfig.setScheduleStatus(ScheduleStatus.ENABLED);\n    triggerConfig.setTaskParameters(partitionTableConfig);\n    ScheduleEntity scheduleEntity = scheduleService.create(triggerConfig);\n\n    // Create and enable schedule for partition plan table dropping\n    triggerConfig = new TriggerConfig();\n    triggerConfig.setJobType(JobType.PARTITION_PLAN_TABLE_DROPPING);\n    triggerConfig.setMisfireStrategy(MisfireStrategy.IGNORE_MISFIRE_POLICY);\n    triggerConfig.setScheduleStatus(ScheduleStatus.ENABLED);\n    triggerConfig.setTaskParameters(partitionTableConfig);\n    scheduleEntity = scheduleService.create(triggerConfig);\n}\n```\n[/java]\n"]}
{"id": 51, "name": "decrypt", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ndecrypt\n\n### Left context\n```Java\n/*\n * Copyright (c) 2017-2021 Nitrite author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.dizitart.no2.support.crypto;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.dizitart.no2.common.util.CryptoUtils;\nimport org.dizitart.no2.common.util.SecureString;\nimport org.dizitart.no2.exceptions.NitriteSecurityException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.GCMParameterSpec;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\n/**\n * The {@code AESEncryptor} class provides AES encryption and decryption\n * functionality.\n * <p>\n * It uses AES/GCM/NoPadding encryption algorithm with a 128-bit tag length,\n * 12-byte IV length, and 16-byte salt length by default.\n * <p>\n * The class provides methods to encrypt and decrypt byte arrays and strings\n * using the specified password and encryption parameters.\n * <p>\n * \n * NOTE: This is a derivative work of <a href=\n * \"https://mkyong.com/java/java-symmetric-key-cryptography-example/\">this</a>.\n * \n * @author Anindya Chatterjee\n * @since 4.0\n */\npublic class AESEncryptor implements Encryptor {\n    private final String encryptAlgo;\n    private final int tagLengthBit;\n    private final int ivLengthByte;\n    private final int saltLengthByte;\n    private final Charset UTF_8 = StandardCharsets.UTF_8;\n\n    private final SecureString password;\n\n    /**\n     * Instantiates a new {@link AESEncryptor} with these default values\n     * <ul>\n     * <li>Encryption Algo - AES/GCM/NoPadding</li>\n     * <li>Tag Length (bit) - 128</li>\n     * <li>IV Length (byte) - 12</li>\n     * <li>Salt Length (byte) - 16</li>\n     * </ul>\n     *\n     * @param password the password\n     */\n    public AESEncryptor(String password) {\n        this(password, \"AES/GCM/NoPadding\", 128, 12, 16);\n    }\n\n    /**\n     * Instantiates a new {@link AESEncryptor}.\n     *\n     * @param password       the password\n     * @param encryptionAlgo the encryption algo\n     * @param tagLengthBit   the tag length bit\n     * @param ivLengthByte   the iv length byte\n     * @param saltLengthByte the salt length byte\n     */\n    public AESEncryptor(String password, String encryptionAlgo,\n            Integer tagLengthBit, Integer ivLengthByte,\n            Integer saltLengthByte) {\n        this.password = new SecureString(password);\n        this.encryptAlgo = encryptionAlgo;\n        this.tagLengthBit = tagLengthBit;\n        this.ivLengthByte = ivLengthByte;\n        this.saltLengthByte = saltLengthByte;\n    }\n\n    /**\n     * Returns a base64 encoded AES encrypted string.\n     *\n     * @param plainText the text as byte array\n     * @return the encrypted string\n     */\n    @Override\n    public String encrypt(byte[] plainText) {\n        try {\n            // 16 bytes salt\n            byte[] salt = CryptoUtils.getRandomNonce(saltLengthByte);\n\n            // GCM recommended 12 bytes iv?\n            byte[] iv = CryptoUtils.getRandomNonce(ivLengthByte);\n\n            // secret key from password\n            SecretKey aesKeyFromPassword = CryptoUtils.getAESKeyFromPassword(password.asString().toCharArray(), salt);\n\n            Cipher cipher = Cipher.getInstance(encryptAlgo);\n\n            // ASE-GCM needs GCMParameterSpec\n            cipher.init(Cipher.ENCRYPT_MODE, aesKeyFromPassword, new GCMParameterSpec(tagLengthBit, iv));\n\n            byte[] cipherText = cipher.doFinal(plainText);\n\n            // prefix IV and Salt to cipher text\n            byte[] cipherTextWithIvSalt = ByteBuffer.allocate(iv.length + salt.length + cipherText.length)\n                    .put(iv)\n                    .put(salt)\n                    .put(cipherText)\n                    .array();\n\n            // string representation, base64, send this string to other for decryption.\n            return Base64.encodeBase64URLSafeString(cipherTextWithIvSalt);\n        } catch (Exception e) {\n            throw new NitriteSecurityException(\"Failed to encrypt data\", e);\n        }\n    }\n\n    /**\n     * Returns the decrypted string encoded by AES.\n     *\n     * <p>\n     * NOTE: The same password, salt and iv are needed to decrypt it.\n     * </p>\n     * \n     * @param encryptedText the encrypted text\n     * @return the plain text decrypted string\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Decrypts the given encrypted text using AES encryption with GCM mode.\n * The encrypted text is expected to be in Base64 format.\n * The decryption process involves the following steps:\n * 1. Decoding the Base64 encoded encrypted text to get the byte array.\n * 2. Extracting the Initialization Vector (IV) and salt from the byte array.\n * 3. Extracting the cipher text from the byte array.\n * 4. Generating the AES key from the password and salt.\n * 5. Initializing the cipher in decryption mode with the AES key and IV.\n * 6. Decrypting the cipher text to get the plain text.\n * 7. Converting the plain text byte array to a string using UTF-8 encoding.\n *\n * @param encryptedText The encrypted text to be decrypted.\n * @return The decrypted text as a string.\n * @throws NitriteSecurityException If there is any error during the decryption process.\n */\n@Override\npublic String decrypt(String encryptedText)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public String decrypt(String encryptedText) {\n        try {\n            byte[] decode = Base64.decodeBase64(encryptedText);\n\n            // get back the iv and salt from the cipher text\n            ByteBuffer bb = ByteBuffer.wrap(decode);\n            byte[] iv = new byte[ivLengthByte];\n            bb.get(iv);\n\n            byte[] salt = new byte[saltLengthByte];\n            bb.get(salt);\n\n            byte[] cipherText = new byte[bb.remaining()];\n            bb.get(cipherText);\n\n            // get back the aes key from the same password and salt\n            SecretKey aesKeyFromPassword = CryptoUtils.getAESKeyFromPassword(password.asString().toCharArray(), salt);\n            Cipher cipher = Cipher.getInstance(encryptAlgo);\n            cipher.init(Cipher.DECRYPT_MODE, aesKeyFromPassword, new GCMParameterSpec(tagLengthBit, iv));\n            byte[] plainText = cipher.doFinal(cipherText);\n            return new String(plainText, UTF_8);\n        } catch (Exception e) {\n            throw new NitriteSecurityException(\"Failed to decrypt data\", e);\n        }\n    }", "completions": ["  \n[java]\n```\n@Override\npublic String decrypt(String encryptedText) {\n    try {\n        // 1. Decode the Base64 encoded encrypted text to get the byte array.\n        byte[] cipherTextWithIvSalt = Base64.decodeBase64(encryptedText);\n\n        // 2. Extract the Initialization Vector (IV) and salt from the byte array.\n        byte[] iv = Arrays.copyOfRange(cipherTextWithIvSalt, 0, ivLengthByte);\n        byte[] salt = Arrays.copyOfRange(cipherTextWithIvSalt, ivLengthByte, ivLengthByte + saltLengthByte);\n        byte[] cipherText = Arrays.copyOfRange(cipherTextWithIvSalt, ivLengthByte + saltLengthByte, cipherTextWithIvSalt.length);\n\n        // 3. Extract the cipher text from the byte array.\n        // 4. Generate the AES key from the password and salt.\n        SecretKey aesKeyFromPassword = CryptoUtils.getAESKeyFromPassword(password.asString().toCharArray(), salt);\n\n        // 5. Initialize the cipher in decryption mode with the AES key and IV.\n        Cipher cipher = Cipher.getInstance(encryptAlgo);\n        cipher.init(Cipher.DECRYPT_MODE, aesKeyFromPassword, new GCMParameterSpec(tagLengthBit, iv));\n\n        // 6. Decrypt the cipher text to get the plain text.\n        byte[] plainText = cipher.doFinal(cipherText);\n\n        // 7. Convert the plain text byte array to a string using UTF-8 encoding.\n        return new String(plainText, UTF_8);\n    } catch (Exception e) {\n        throw new NitriteSecurityException(\"Failed to decrypt data\", e);\n    }\n}\n```\n[/java]\n"]}
{"id": 53, "name": "maybeFetchErrorIntervalMs", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nmaybeFetchErrorIntervalMs\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.telemetry.internals;\n\nimport io.opentelemetry.proto.metrics.v1.MetricsData;\n\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.metrics.MetricsContext;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.record.RecordBatch;\nimport org.apache.kafka.common.utils.BufferSupplier;\nimport org.apache.kafka.common.utils.ByteBufferOutputStream;\nimport org.apache.kafka.common.utils.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\npublic class ClientTelemetryUtils {\n\n    private final static Logger log = LoggerFactory.getLogger(ClientTelemetryUtils.class);\n\n    public final static Predicate<? super MetricKeyable> SELECTOR_NO_METRICS = k -> false;\n\n    public final static Predicate<? super MetricKeyable> SELECTOR_ALL_METRICS = k -> true;\n\n    /**\n     * Examine the response data and handle different error code accordingly:\n     *\n     * <ul>\n     *     <li>Invalid Request: Disable Telemetry</li>\n     *     <li>Invalid Record: Disable Telemetry</li>\n     *     <li>Unsupported Version: Disable Telemetry</li>\n     *     <li>UnknownSubscription or Unsupported Compression: Retry immediately</li>\n     *     <li>TelemetryTooLarge or ThrottlingQuotaExceeded: Retry as per next interval</li>\n     * </ul>\n     *\n     * @param errorCode response body error code\n     * @param intervalMs current push interval in milliseconds\n     *\n     * @return Optional of push interval in milliseconds\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method is used to fetch the error interval in milliseconds based on the error code.\n * If the error code is Errors.NONE, it returns an empty Optional.\n * If the error code is INVALID_REQUEST, INVALID_RECORD, UNSUPPORTED_VERSION, it sets the push interval to Integer.MAX_VALUE and logs a reason.\n * If the error code is UNKNOWN_SUBSCRIPTION_ID, UNSUPPORTED_COMPRESSION_TYPE, it sets the push interval to 0 and logs the error message.\n * If the error code is TELEMETRY_TOO_LARGE, THROTTLING_QUOTA_EXCEEDED, it sets the push interval to either the provided interval or the default interval and logs the error message.\n * For any other error code, it logs an error and sets the push interval to Integer.MAX_VALUE.\n * Finally, it logs the error code, reason, and push interval and returns the push interval in an Optional.\n *\n * @param errorCode The error code to fetch the interval for.\n * @param intervalMs The interval in milliseconds.\n * @return An Optional containing the push interval in milliseconds.\n */\npublic static Optional<Integer> maybeFetchErrorIntervalMs(short errorCode, int intervalMs)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static Optional<Integer> maybeFetchErrorIntervalMs(short errorCode, int intervalMs) {\n        if (errorCode == Errors.NONE.code())\n            return Optional.empty();\n\n        int pushIntervalMs;\n        String reason;\n\n        Errors error = Errors.forCode(errorCode);\n        switch (error) {\n            case INVALID_REQUEST:\n            case INVALID_RECORD:\n            case UNSUPPORTED_VERSION:\n                pushIntervalMs = Integer.MAX_VALUE;\n                reason = \"The broker response indicates the client sent an request that cannot be resolved\"\n                    + \" by re-trying, hence disable telemetry\";\n                break;\n            case UNKNOWN_SUBSCRIPTION_ID:\n            case UNSUPPORTED_COMPRESSION_TYPE:\n                pushIntervalMs = 0;\n                reason = error.message();\n                break;\n            case TELEMETRY_TOO_LARGE:\n            case THROTTLING_QUOTA_EXCEEDED:\n                reason = error.message();\n                pushIntervalMs = (intervalMs != -1) ? intervalMs : ClientTelemetryReporter.DEFAULT_PUSH_INTERVAL_MS;\n                break;\n            default:\n                reason = \"Unwrapped error code\";\n                log.error(\"Error code: {}. Unmapped error for telemetry, disable telemetry.\", errorCode);\n                pushIntervalMs = Integer.MAX_VALUE;\n        }\n\n        log.debug(\"Error code: {}, reason: {}. Push interval update to {} ms.\", errorCode, reason, pushIntervalMs);\n        return Optional.of(pushIntervalMs);\n    }", "completions": ["  \n[java]\npublic static Optional<Integer> maybeFetchErrorIntervalMs(short errorCode, int intervalMs) {\n    switch (errorCode) {\n        case Errors.NONE:\n            return Optional.empty();\n        case Errors.INVALID_REQUEST:\n        case Errors.INVALID_RECORD:\n        case Errors.UNSUPPORTED_VERSION:\n            log.error(\"Disabling telemetry due to error code {}\", errorCode);\n            return Optional.of(Integer.MAX_VALUE);\n        case Errors.UNKNOWN_SUBSCRIPTION_ID:\n        case Errors.UNSUPPORTED_COMPRESSION_TYPE:\n            log.error(\"Error code {} encountered, retrying immediately\", errorCode);\n            return Optional.of(0);\n        case Errors.TELEMETRY_TOO_LARGE:\n        case Errors.THROTTLING_QUOTA_EXCEEDED:\n            log.error(\"Error code {} encountered, retrying as per next interval\", errorCode);\n            return Optional.of(intervalMs);\n        default:\n            log.error(\"Unknown error code {} encountered, disabling telemetry\", errorCode);\n            return Optional.of(Integer.MAX_VALUE);\n    }\n}\n[/java]\n"]}
{"id": 54, "name": "retrieveQueryableStore", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nretrieveQueryableStore\n\n### Left context\n```Java\n/*\n * Copyright 2024-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.kafka.streams;\n\nimport java.util.Properties;\n\nimport org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.streams.KafkaStreams;\nimport org.apache.kafka.streams.KeyQueryMetadata;\nimport org.apache.kafka.streams.StoreQueryParameters;\nimport org.apache.kafka.streams.state.HostInfo;\nimport org.apache.kafka.streams.state.QueryableStoreType;\n\nimport org.springframework.kafka.config.StreamsBuilderFactoryBean;\nimport org.springframework.lang.Nullable;\nimport org.springframework.retry.support.RetryTemplate;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n\n/**\n * Provide a wrapper API around the interactive query stores in Kafka Streams.\n * Using this API, an application can gain access to a named state store in the\n * {@link KafkaStreams} under consideration.\n *\n * @author Soby Chacko\n * @since 3.2\n */\npublic class KafkaStreamsInteractiveQueryService {\n\n\t/**\n\t * {@link StreamsBuilderFactoryBean} that provides {@link KafkaStreams} where the state store is retrieved from.\n\t */\n\tprivate final StreamsBuilderFactoryBean streamsBuilderFactoryBean;\n\n\t/**\n\t * {@link RetryTemplate} to be used by the interative query service.\n\t */\n\tprivate RetryTemplate retryTemplate = new RetryTemplate();\n\n\t/**\n\t * Underlying {@link KafkaStreams} from {@link StreamsBuilderFactoryBean}.\n\t */\n\tprivate volatile KafkaStreams kafkaStreams;\n\n\t/**\n\t * Construct an instance for querying state stores from the KafkaStreams in the {@link StreamsBuilderFactoryBean}.\n\t * @param streamsBuilderFactoryBean {@link StreamsBuilderFactoryBean} for {@link KafkaStreams}.\n\t */\n\tpublic KafkaStreamsInteractiveQueryService(StreamsBuilderFactoryBean streamsBuilderFactoryBean) {\n\t\tAssert.notNull(streamsBuilderFactoryBean, \"StreamsBuildFactoryBean instance cannot be null.\");\n\t\tthis.streamsBuilderFactoryBean = streamsBuilderFactoryBean;\n\t}\n\n\t/**\n\t * Custom {@link RetryTemplate} provided by the end users.\n\t * @param retryTemplate {@link RetryTemplate}\n\t */\n\tpublic void setRetryTemplate(RetryTemplate retryTemplate) {\n\t\tAssert.notNull(retryTemplate, \"The provided RetryTemplate instance must not be null\");\n\t\tthis.retryTemplate = retryTemplate;\n\t}\n\n\t/**\n\t * Retrieve and return a queryable store by name created in the application.\n\t * @param storeName name of the queryable store\n\t * @param storeType type of the queryable store\n\t * @param <T> generic type for the queryable store\n\t * @return queryable store.\n\t */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Retrieves a queryable store of a specified type with a given name.\n *\n * @param storeName The name of the store to retrieve.\n * @param storeType The type of the store to retrieve.\n * @param <T> The type of the store.\n * @return The retrieved store.\n * @throws IllegalStateException If an error occurs while retrieving the store.\n */\npublic<T> T retrieveQueryableStore(String storeName, QueryableStoreType<T> storeType)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "\tpublic <T> T retrieveQueryableStore(String storeName, QueryableStoreType<T> storeType) {\n\t\tpopulateKafkaStreams();\n\t\tStoreQueryParameters<T> storeQueryParams = StoreQueryParameters.fromNameAndType(storeName, storeType);\n\n\t\treturn this.retryTemplate.execute(context -> {\n\t\t\ttry {\n\t\t\t\treturn this.kafkaStreams.store(storeQueryParams);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new IllegalStateException(\"Error retrieving state store: \" + storeName, e);\n\t\t\t}\n\t\t});\n\t}", "completions": ["  \n[Java]\n```java\npublic <T> T retrieveQueryableStore(String storeName, QueryableStoreType<T> storeType) {\n    Assert.hasText(storeName, \"Store name must not be empty\");\n    Assert.notNull(storeType, \"Store type must not be null\");\n\n    if (this.kafkaStreams == null) {\n        this.kafkaStreams = this.streamsBuilderFactoryBean.getKafkaStreams();\n    }\n\n    try {\n        return this.kafkaStreams.store(storeName, storeType);\n    }\n    catch (Exception e) {\n        throw new IllegalStateException(\"Error retrieving store\", e);\n    }\n}\n```"]}
{"id": 57, "name": "resetToOffsets", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nresetToOffsets\n\n### Left context\n```Java\npackage io.kafbat.ui.service;\n\nimport static java.util.stream.Collectors.toMap;\nimport static java.util.stream.Collectors.toSet;\nimport static org.apache.kafka.common.ConsumerGroupState.DEAD;\nimport static org.apache.kafka.common.ConsumerGroupState.EMPTY;\n\nimport com.google.common.base.Preconditions;\nimport io.kafbat.ui.exception.NotFoundException;\nimport io.kafbat.ui.exception.ValidationException;\nimport io.kafbat.ui.model.KafkaCluster;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.Nullable;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.clients.admin.OffsetSpec;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.stereotype.Component;\nimport reactor.core.publisher.Mono;\n\n/**\n * Implementation follows https://cwiki.apache.org/confluence/display/KAFKA/KIP-122%3A+Add+Reset+Consumer+Group+Offsets+tooling\n * to works like \"kafka-consumer-groups --reset-offsets\" console command\n * (see kafka.admin.ConsumerGroupCommand)\n */\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class OffsetsResetService {\n\n  private final AdminClientService adminClientService;\n\n  public Mono<Void> resetToEarliest(\n      KafkaCluster cluster, String group, String topic, Collection<Integer> partitions) {\n    return checkGroupCondition(cluster, group)\n        .flatMap(ac ->\n            offsets(ac, topic, partitions, OffsetSpec.earliest())\n                .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n\n  private Mono<Map<TopicPartition, Long>> offsets(ReactiveAdminClient client,\n                                                  String topic,\n                                                  @Nullable Collection<Integer> partitions,\n                                                  OffsetSpec spec) {\n    if (partitions == null) {\n      return client.listTopicOffsets(topic, spec, true);\n    }\n    return client.listOffsets(\n        partitions.stream().map(idx -> new TopicPartition(topic, idx)).collect(toSet()),\n        spec,\n        true\n    );\n  }\n\n  public Mono<Void> resetToLatest(\n      KafkaCluster cluster, String group, String topic, Collection<Integer> partitions) {\n    return checkGroupCondition(cluster, group)\n        .flatMap(ac ->\n            offsets(ac, topic, partitions, OffsetSpec.latest())\n                .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n\n  public Mono<Void> resetToTimestamp(\n      KafkaCluster cluster, String group, String topic, Collection<Integer> partitions,\n      long targetTimestamp) {\n    return checkGroupCondition(cluster, group)\n        .flatMap(ac ->\n            offsets(ac, topic, partitions, OffsetSpec.forTimestamp(targetTimestamp))\n                .flatMap(\n                    foundOffsets -> offsets(ac, topic, partitions, OffsetSpec.latest())\n                        .map(endOffsets -> editTsOffsets(foundOffsets, endOffsets))\n                )\n                .flatMap(offsets -> resetOffsets(ac, group, offsets))\n        );\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Resets the offsets of a Kafka consumer group to a specified set of offsets for a given topic.\n *\n * @param cluster The Kafka cluster to operate on.\n * @param group The consumer group to reset offsets for.\n * @param topic The topic to reset offsets for.\n * @param targetOffsets A map of partition IDs to target offsets.\n * @return A Mono that completes when the offsets have been reset.\n * @throws NullPointerException If the targetOffsets parameter is null.\n */\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    Preconditions.checkNotNull(targetOffsets);\n    var partitionOffsets = targetOffsets.entrySet().stream()\n        .collect(toMap(e -> new TopicPartition(topic, e.getKey()), Map.Entry::getValue));\n    return checkGroupCondition(cluster, group).flatMap(\n        ac ->\n            ac.listOffsets(partitionOffsets.keySet(), OffsetSpec.earliest(), true)\n                .flatMap(earliest ->\n                    ac.listOffsets(partitionOffsets.keySet(), OffsetSpec.latest(), true)\n                        .map(latest -> editOffsetsBounds(partitionOffsets, earliest, latest))\n                        .flatMap(offsetsToCommit -> resetOffsets(ac, group, offsetsToCommit)))\n    );\n  }", "completions": ["  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic Mono<Void> resetToOffsets(\n      KafkaCluster cluster, String group, String topic, Map<Integer, Long> targetOffsets) {\n    return checkGroupCondition(cluster, group)\n       .flatMap(ac ->\n            offsets(ac, topic, targetOffsets.keySet(), OffsetSpec.forOffsets(targetOffsets))\n               .flatMap(offsets -> resetOffsets(ac, group, offsets)));\n  }\n```\n[/Markdown]  \n[/INST"]}
{"id": 58, "name": "decompress", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ndecompress\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.telemetry.internals;\n\nimport io.opentelemetry.proto.metrics.v1.MetricsData;\n\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.metrics.MetricsContext;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.record.RecordBatch;\nimport org.apache.kafka.common.utils.BufferSupplier;\nimport org.apache.kafka.common.utils.ByteBufferOutputStream;\nimport org.apache.kafka.common.utils.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\npublic class ClientTelemetryUtils {\n\n    private final static Logger log = LoggerFactory.getLogger(ClientTelemetryUtils.class);\n\n    public final static Predicate<? super MetricKeyable> SELECTOR_NO_METRICS = k -> false;\n\n    public final static Predicate<? super MetricKeyable> SELECTOR_ALL_METRICS = k -> true;\n\n    /**\n     * Examine the response data and handle different error code accordingly:\n     *\n     * <ul>\n     *     <li>Invalid Request: Disable Telemetry</li>\n     *     <li>Invalid Record: Disable Telemetry</li>\n     *     <li>Unsupported Version: Disable Telemetry</li>\n     *     <li>UnknownSubscription or Unsupported Compression: Retry immediately</li>\n     *     <li>TelemetryTooLarge or ThrottlingQuotaExceeded: Retry as per next interval</li>\n     * </ul>\n     *\n     * @param errorCode response body error code\n     * @param intervalMs current push interval in milliseconds\n     *\n     * @return Optional of push interval in milliseconds\n     */\n    public static Optional<Integer> maybeFetchErrorIntervalMs(short errorCode, int intervalMs) {\n        if (errorCode == Errors.NONE.code())\n            return Optional.empty();\n\n        int pushIntervalMs;\n        String reason;\n\n        Errors error = Errors.forCode(errorCode);\n        switch (error) {\n            case INVALID_REQUEST:\n            case INVALID_RECORD:\n            case UNSUPPORTED_VERSION:\n                pushIntervalMs = Integer.MAX_VALUE;\n                reason = \"The broker response indicates the client sent an request that cannot be resolved\"\n                    + \" by re-trying, hence disable telemetry\";\n                break;\n            case UNKNOWN_SUBSCRIPTION_ID:\n            case UNSUPPORTED_COMPRESSION_TYPE:\n                pushIntervalMs = 0;\n                reason = error.message();\n                break;\n            case TELEMETRY_TOO_LARGE:\n            case THROTTLING_QUOTA_EXCEEDED:\n                reason = error.message();\n                pushIntervalMs = (intervalMs != -1) ? intervalMs : ClientTelemetryReporter.DEFAULT_PUSH_INTERVAL_MS;\n                break;\n            default:\n                reason = \"Unwrapped error code\";\n                log.error(\"Error code: {}. Unmapped error for telemetry, disable telemetry.\", errorCode);\n                pushIntervalMs = Integer.MAX_VALUE;\n        }\n\n        log.debug(\"Error code: {}, reason: {}. Push interval update to {} ms.\", errorCode, reason, pushIntervalMs);\n        return Optional.of(pushIntervalMs);\n    }\n\n    public static Predicate<? super MetricKeyable> getSelectorFromRequestedMetrics(List<String> requestedMetrics) {\n        if (requestedMetrics == null || requestedMetrics.isEmpty()) {\n            log.debug(\"Telemetry subscription has specified no metric names; telemetry will record no metrics\");\n            return SELECTOR_NO_METRICS;\n        } else if (requestedMetrics.size() == 1 && requestedMetrics.get(0) != null && requestedMetrics.get(0).equals(\"*\")) {\n            log.debug(\"Telemetry subscription has specified a single '*' metric name; using all metrics\");\n            return SELECTOR_ALL_METRICS;\n        } else {\n            log.debug(\"Telemetry subscription has specified to include only metrics that are prefixed with the following strings: {}\", requestedMetrics);\n            return k -> requestedMetrics.stream().anyMatch(f -> k.key().name().startsWith(f));\n        }\n    }\n\n    public static List<CompressionType> getCompressionTypesFromAcceptedList(List<Byte> acceptedCompressionTypes) {\n        if (acceptedCompressionTypes == null || acceptedCompressionTypes.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<CompressionType> result = new ArrayList<>();\n        for (Byte compressionByte : acceptedCompressionTypes) {\n            int compressionId = compressionByte.intValue();\n            try {\n                CompressionType compressionType = CompressionType.forId(compressionId);\n                result.add(compressionType);\n            } catch (IllegalArgumentException e) {\n                log.warn(\"Accepted compressionByte type with ID {} is not a known compressionByte type; ignoring\", compressionId, e);\n            }\n        }\n        return result;\n    }\n\n    public static Uuid validateClientInstanceId(Uuid clientInstanceId) {\n        if (clientInstanceId == null || clientInstanceId == Uuid.ZERO_UUID) {\n            throw new IllegalArgumentException(\"clientInstanceId is not valid\");\n        }\n\n        return clientInstanceId;\n    }\n\n    public static int validateIntervalMs(int intervalMs) {\n        if (intervalMs <= 0) {\n            log.warn(\"Telemetry subscription push interval value from broker was invalid ({}),\"\n                + \" substituting with default value of {}\", intervalMs, ClientTelemetryReporter.DEFAULT_PUSH_INTERVAL_MS);\n            return ClientTelemetryReporter.DEFAULT_PUSH_INTERVAL_MS;\n        }\n\n        log.debug(\"Telemetry subscription push interval value from broker: {}\", intervalMs);\n        return intervalMs;\n    }\n\n    public static boolean validateResourceLabel(Map<String, ?> m, String key) {\n        if (!m.containsKey(key)) {\n            log.trace(\"{} does not exist in map {}\", key, m);\n            return false;\n        }\n\n        if (m.get(key) == null) {\n            log.trace(\"{} is null. map {}\", key, m);\n            return false;\n        }\n\n        if (!(m.get(key) instanceof String)) {\n            log.trace(\"{} is not a string. map {}\", key, m);\n            return false;\n        }\n\n        String val = (String) m.get(key);\n        if (val.isEmpty()) {\n            log.trace(\"{} is empty string. value = {} map {}\", key, val, m);\n            return false;\n        }\n        return true;\n    }\n\n    public static boolean validateRequiredResourceLabels(Map<String, String> metadata) {\n        return validateResourceLabel(metadata, MetricsContext.NAMESPACE);\n    }\n\n    public static CompressionType preferredCompressionType(List<CompressionType> acceptedCompressionTypes) {\n        if (acceptedCompressionTypes != null && !acceptedCompressionTypes.isEmpty()) {\n            // Broker is providing the compression types in order of preference. Grab the\n            // first one.\n            return acceptedCompressionTypes.get(0);\n        }\n        return CompressionType.NONE;\n    }\n\n    public static byte[] compress(byte[] raw, CompressionType compressionType) throws IOException {\n        try (ByteBufferOutputStream compressedOut = new ByteBufferOutputStream(512)) {\n            try (OutputStream out = compressionType.wrapForOutput(compressedOut, RecordBatch.CURRENT_MAGIC_VALUE)) {\n                out.write(raw);\n                out.flush();\n            }\n            compressedOut.buffer().flip();\n            return Utils.toArray(compressedOut.buffer());\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Decompresses the given byte array using the specified compression type.\n * \n * @param metrics The byte array to be decompressed.\n * @param compressionType The compression type to be used for decompression.\n * @return A ByteBuffer containing the decompressed data.\n * @throws KafkaException If an I/O error occurs during decompression.\n */\npublic static ByteBuffer decompress(byte[] metrics, CompressionType compressionType)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static ByteBuffer decompress(byte[] metrics, CompressionType compressionType) {\n        ByteBuffer data = ByteBuffer.wrap(metrics);\n        try (InputStream in = compressionType.wrapForInput(data, RecordBatch.CURRENT_MAGIC_VALUE, BufferSupplier.create());\n            ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n\n            byte[] bytes = new byte[data.capacity() * 2];\n            int nRead;\n            while ((nRead = in.read(bytes, 0, bytes.length)) != -1) {\n                out.write(bytes, 0, nRead);\n            }\n\n            out.flush();\n            return ByteBuffer.wrap(out.toByteArray());\n        } catch (IOException e) {\n            throw new KafkaException(\"Failed to decompress metrics data\", e);\n        }\n    }", "completions": ["  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic static ByteBuffer decompress(byte[] metrics, CompressionType compressionType) throws KafkaException {\n    try (ByteBufferOutputStream compressedOut = new ByteBufferOutputStream(512)) {\n        try (OutputStream out = compressionType.wrapForOutput(compressedOut, RecordBatch.CURRENT_MAGIC_VALUE)) {\n            out.write(metrics);\n            out.flush();\n        }\n        compressedOut.buffer().flip();\n        return Utils.toArray(compressedOut.buffer());\n    }\n}\n```\n[/Markdown]  \n[/INST]  \n[INST:full]  \n[PYTHON]  \n[/PYTHON]  \n[Markdown]  \n[/Markdown]  \n[/INST]  \n"]}
{"id": 59, "name": "writePropertiesFile", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nwritePropertiesFile\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kafka.metadata.properties;\n\nimport org.apache.kafka.common.utils.Utils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Properties;\n\npublic final class PropertiesUtils {\n    /**\n     * Writes a Java Properties object to a file.\n     *\n     * @param props         The Properties object.\n     * @param path          The file to write to.\n     * @throws IOException\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method writes a properties file to the specified path. It uses a temporary file to write the properties,\n * then atomically moves the temporary file to the target file using the atomicMoveWithFallback method from the Utils class.\n * If fsync is true, it also ensures the file is synced to the disk.\n *\n * @param props The properties to be written to the file.\n * @param path The path of the file to be written.\n * @param fsync A boolean indicating whether to sync the file to the disk after writing.\n * @throws IOException If an I/O error occurs.\n */\npublic static void writePropertiesFile(\n        Properties props,\n        String path,\n        boolean fsync\n    ) throws IOException\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public static void writePropertiesFile(\n        Properties props,\n        String path,\n        boolean fsync\n    ) throws IOException {\n        File tempFile = new File(path + \".tmp\");\n        try (\n            FileOutputStream fos = new FileOutputStream(tempFile, false);\n            OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n            PrintWriter pw = new PrintWriter(osw)\n        ) {\n            props.store(pw, \"\");\n            fos.flush();\n            if (fsync) {\n                fos.getFD().sync();\n            }\n        }\n        File targetFile = new File(path);\n        try {\n            Utils.atomicMoveWithFallback(tempFile.toPath(), targetFile.toPath(), fsync);\n        } catch (Throwable e) {\n            Utils.delete(tempFile);\n            throw e;\n        }\n    }", "completions": ["  \n[java]\npublic static void writePropertiesFile(Properties props, String path, boolean fsync) throws IOException {\n    // Create a temporary file to write the properties to\n    File tempFile = File.createTempFile(\"properties\", null);\n    tempFile.deleteOnExit();\n\n    // Write the properties to the temporary file\n    try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(tempFile), StandardCharsets.UTF_8)) {\n        props.store(writer, null);\n    }\n\n    // Atomically move the temporary file to the target file\n    Utils.atomicMoveWithFallback(tempFile.toPath(), Paths.get(path));\n\n    // Sync the file to the disk if fsync is true\n    if (fsync) {\n        Files.write(Paths.get(path), new byte[0], StandardOpenOption.SYNC);\n    }\n}\n[/java]\n"]}
{"id": 60, "name": "encrypt", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nencrypt\n\n### Left context\n```Java\n/*\n * Copyright (c) 2017-2021 Nitrite author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.dizitart.no2.support.crypto;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.dizitart.no2.common.util.CryptoUtils;\nimport org.dizitart.no2.common.util.SecureString;\nimport org.dizitart.no2.exceptions.NitriteSecurityException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.GCMParameterSpec;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\n/**\n * The {@code AESEncryptor} class provides AES encryption and decryption\n * functionality.\n * <p>\n * It uses AES/GCM/NoPadding encryption algorithm with a 128-bit tag length,\n * 12-byte IV length, and 16-byte salt length by default.\n * <p>\n * The class provides methods to encrypt and decrypt byte arrays and strings\n * using the specified password and encryption parameters.\n * <p>\n * \n * NOTE: This is a derivative work of <a href=\n * \"https://mkyong.com/java/java-symmetric-key-cryptography-example/\">this</a>.\n * \n * @author Anindya Chatterjee\n * @since 4.0\n */\npublic class AESEncryptor implements Encryptor {\n    private final String encryptAlgo;\n    private final int tagLengthBit;\n    private final int ivLengthByte;\n    private final int saltLengthByte;\n    private final Charset UTF_8 = StandardCharsets.UTF_8;\n\n    private final SecureString password;\n\n    /**\n     * Instantiates a new {@link AESEncryptor} with these default values\n     * <ul>\n     * <li>Encryption Algo - AES/GCM/NoPadding</li>\n     * <li>Tag Length (bit) - 128</li>\n     * <li>IV Length (byte) - 12</li>\n     * <li>Salt Length (byte) - 16</li>\n     * </ul>\n     *\n     * @param password the password\n     */\n    public AESEncryptor(String password) {\n        this(password, \"AES/GCM/NoPadding\", 128, 12, 16);\n    }\n\n    /**\n     * Instantiates a new {@link AESEncryptor}.\n     *\n     * @param password       the password\n     * @param encryptionAlgo the encryption algo\n     * @param tagLengthBit   the tag length bit\n     * @param ivLengthByte   the iv length byte\n     * @param saltLengthByte the salt length byte\n     */\n    public AESEncryptor(String password, String encryptionAlgo,\n            Integer tagLengthBit, Integer ivLengthByte,\n            Integer saltLengthByte) {\n        this.password = new SecureString(password);\n        this.encryptAlgo = encryptionAlgo;\n        this.tagLengthBit = tagLengthBit;\n        this.ivLengthByte = ivLengthByte;\n        this.saltLengthByte = saltLengthByte;\n    }\n\n    /**\n     * Returns a base64 encoded AES encrypted string.\n     *\n     * @param plainText the text as byte array\n     * @return the encrypted string\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Encrypts the given plain text using AES-GCM encryption.\n * The encryption process includes generating a random salt, an initialization vector (IV),\n * and a secret key from the provided password. The encrypted data is then prefixed with the IV and salt,\n * and the resulting byte array is encoded into a URL-safe base64 string.\n *\n * @param plainText The data to be encrypted.\n * @return A URL-safe base64 encoded string representing the encrypted data.\n * @throws NitriteSecurityException If the encryption process fails.\n */\n@Override\npublic String encrypt(byte[] plainText)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public String encrypt(byte[] plainText) {\n        try {\n            // 16 bytes salt\n            byte[] salt = CryptoUtils.getRandomNonce(saltLengthByte);\n\n            // GCM recommended 12 bytes iv?\n            byte[] iv = CryptoUtils.getRandomNonce(ivLengthByte);\n\n            // secret key from password\n            SecretKey aesKeyFromPassword = CryptoUtils.getAESKeyFromPassword(password.asString().toCharArray(), salt);\n\n            Cipher cipher = Cipher.getInstance(encryptAlgo);\n\n            // ASE-GCM needs GCMParameterSpec\n            cipher.init(Cipher.ENCRYPT_MODE, aesKeyFromPassword, new GCMParameterSpec(tagLengthBit, iv));\n\n            byte[] cipherText = cipher.doFinal(plainText);\n\n            // prefix IV and Salt to cipher text\n            byte[] cipherTextWithIvSalt = ByteBuffer.allocate(iv.length + salt.length + cipherText.length)\n                    .put(iv)\n                    .put(salt)\n                    .put(cipherText)\n                    .array();\n\n            // string representation, base64, send this string to other for decryption.\n            return Base64.encodeBase64URLSafeString(cipherTextWithIvSalt);\n        } catch (Exception e) {\n            throw new NitriteSecurityException(\"Failed to encrypt data\", e);\n        }\n    }", "completions": ["  \n[java]\n```\n@Override\npublic String encrypt(byte[] plainText) {\n    try {\n        // Generate a random salt\n        byte[] salt = CryptoUtils.generateSalt(saltLengthByte);\n\n        // Generate an initialization vector (IV)\n        byte[] iv = CryptoUtils.generateIV(ivLengthByte);\n\n        // Generate a secret key from the password and salt\n        SecretKey secretKey = CryptoUtils.generateSecretKey(password, salt);\n\n        // Create a Cipher instance\n        Cipher cipher = Cipher.getInstance(encryptAlgo);\n\n        // Initialize the Cipher with the secret key and IV\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(tagLengthBit, iv));\n\n        // Encrypt the plain text\n        byte[] cipherText = cipher.doFinal(plainText);\n\n        // Prepend the IV and salt to the cipher text\n        ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + salt.length + cipherText.length);\n        byteBuffer.put(iv);\n        byteBuffer.put(salt);\n        byteBuffer.put(cipherText);\n\n        // Encode the cipher text into a URL-safe base64 string\n        return Base64.encodeBase64URLSafeString(byteBuffer.array());\n    } catch (Exception e) {\n        throw new NitriteSecurityException(\"Error encrypting data\", e);\n    }\n}\n```\n[/java]\n"]}
{"id": 61, "name": "process", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nprocess\n\n### Left context\n```Java\n/*\n * Janssen Project software is available under the MIT License (2008). See http://opensource.org/licenses/MIT for full text.\n *\n * Copyright (c) 2020, Janssen Project\n */\n\n/*\n * Copyright (c) 2018 Mastercard\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\npackage io.jans.fido2.service.processor.assertion;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.jans.fido2.ctap.AttestationFormat;\nimport io.jans.fido2.exception.Fido2CompromisedDevice;\nimport io.jans.fido2.exception.Fido2RuntimeException;\nimport io.jans.fido2.model.auth.AuthData;\nimport io.jans.fido2.service.AuthenticatorDataParser;\nimport io.jans.fido2.service.Base64Service;\nimport io.jans.fido2.service.CoseService;\nimport io.jans.fido2.service.DataMapperService;\nimport io.jans.fido2.service.processors.AssertionFormatProcessor;\nimport io.jans.fido2.service.verifier.AuthenticatorDataVerifier;\nimport io.jans.fido2.service.verifier.CommonVerifiers;\nimport io.jans.fido2.service.verifier.UserVerificationVerifier;\nimport io.jans.orm.model.fido2.Fido2AuthenticationData;\nimport io.jans.orm.model.fido2.Fido2RegistrationData;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.slf4j.Logger;\n\nimport java.security.PublicKey;\n\n/**\n * Class which processes assertions of \"none\" fmt (attestation type)\n */\n@ApplicationScoped\npublic class NoneAssertionFormatProcessor implements AssertionFormatProcessor {\n\n    @Inject\n    private Logger log;\n\n    @Inject\n    private CoseService coseService;\n\n    @Inject\n    private CommonVerifiers commonVerifiers;\n\n    @Inject\n    private AuthenticatorDataVerifier authenticatorDataVerifier;\n\n    @Inject\n    private UserVerificationVerifier userVerificationVerifier;\n\n    @Inject\n    private AuthenticatorDataParser authenticatorDataParser;\n\n    @Inject\n    private DataMapperService dataMapperService;\n\n    @Inject\n    private Base64Service base64Service;\n\n    @Override\n    public AttestationFormat getAttestationFormat() {\n        return AttestationFormat.none;\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * This method processes the FIDO2 authentication data. It verifies the registration domain, user verification option, counter, and assertion signature.\n *\n * @param base64AuthenticatorData The base64 encoded authenticator data.\n * @param signature The signature of the authentication data.\n * @param clientDataJson The client data in JSON format.\n * @param registration The FIDO2 registration data.\n * @param authenticationEntity The FIDO2 authentication data.\n * @throws Fido2CompromisedDevice If the device is compromised.\n * @throws Fido2RuntimeException If there is an error during the process.\n */\n@Override\npublic void process(String base64AuthenticatorData, String signature, String clientDataJson, Fido2RegistrationData registration,\n                        Fido2AuthenticationData authenticationEntity)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    public void process(String base64AuthenticatorData, String signature, String clientDataJson, Fido2RegistrationData registration,\n                        Fido2AuthenticationData authenticationEntity) {\n        log.debug(\"Registration: {}\", registration);\n\n        AuthData authData = authenticatorDataParser.parseAssertionData(base64AuthenticatorData);\n        commonVerifiers.verifyRpIdHash(authData, registration.getDomain());\n\n        log.debug(\"User verification option: {}\", authenticationEntity.getUserVerificationOption());\n        userVerificationVerifier.verifyUserVerificationOption(authenticationEntity.getUserVerificationOption(), authData);\n\n        byte[] clientDataHash = DigestUtils.getSha256Digest().digest(base64Service.urlDecode(clientDataJson));\n\n        try {\n            int counter = authenticatorDataParser.parseCounter(authData.getCounters());\n            commonVerifiers.verifyCounter(registration.getCounter(), counter);\n            registration.setCounter(counter);\n\n            JsonNode uncompressedECPointNode = dataMapperService.cborReadTree(base64Service.urlDecode(registration.getUncompressedECPoint()));\n            PublicKey publicKey = coseService.createUncompressedPointFromCOSEPublicKey(uncompressedECPointNode);\n\n            log.debug(\"Uncompressed ECpoint node: {}\", uncompressedECPointNode);\n            log.debug(\"EC Public key hex: {}\", Hex.encodeHexString(publicKey.getEncoded()));\n            log.debug(\"Registration algorithm: {}, default use: -7\", registration.getSignatureAlgorithm());\n            authenticatorDataVerifier.verifyAssertionSignature(authData, clientDataHash, signature, publicKey, -7);\n\n        } catch (Fido2CompromisedDevice ex) {\n            log.error(\"Error compromised device: {}\", ex.getMessage());\n            throw ex;\n        } catch (Exception ex) {\n            log.error(\"Error to check none assertion: {}\", ex.getMessage());\n            throw new Fido2RuntimeException(\"Failed to check none assertion: {}\", ex.getMessage(), ex);\n        }\n    }", "completions": ["  \n[answer]\n```java\n@Override\npublic void process(String base64AuthenticatorData, String signature, String clientDataJson, Fido2RegistrationData registration,\n                        Fido2AuthenticationData authenticationEntity) {\n    // Decode the authenticator data\n    byte[] authenticatorData = base64Service.decode(base64AuthenticatorData);\n\n    // Verify the registration domain\n    commonVerifiers.verifyRegistrationDomain(registration, clientDataJson);\n\n    // Verify the user verification option\n    userVerificationVerifier.verifyUserVerification(authenticationEntity, registration);\n\n    // Verify the counter\n    authenticatorDataVerifier.verifyCounter(authenticatorData, authenticationEntity);\n\n    // Verify the signature\n    coseService.verifySignature(authenticatorData, signature, registration.getPublicKey());\n}\n```\n[/answer]\n"]}
{"id": 65, "name": "fromExpirationTime", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nfromExpirationTime\n\n### Left context\n```Java\n/*\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.apphosting.runtime.jetty;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.flogger.GoogleLogger;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.TemporalUnit;\nimport java.util.regex.Pattern;\n\n/**\n * Wrapper for cache-control header value strings. Also includes logic to parse expiration time\n * strings provided in application config files.\n */\npublic final class CacheControlHeader {\n  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();\n  private static final String DEFAULT_BASE_VALUE = \"public, max-age=\";\n  // Default max age is 10 minutes, per GAE documentation\n  private static final String DEFAULT_MAX_AGE = \"600\";\n\n  private static final ImmutableMap<String, TemporalUnit> EXPIRATION_TIME_UNITS =\n      ImmutableMap.of(\n          \"s\", ChronoUnit.SECONDS,\n          \"m\", ChronoUnit.MINUTES,\n          \"h\", ChronoUnit.HOURS,\n          \"d\", ChronoUnit.DAYS);\n\n  private final String value;\n\n  private CacheControlHeader(String value) {\n    this.value = value;\n  }\n\n  public static CacheControlHeader getDefaultInstance() {\n    return new CacheControlHeader(DEFAULT_BASE_VALUE + DEFAULT_MAX_AGE);\n  }\n\n  /**\n   * Parse formatted expiration time (e.g., \"1d 2h 3m\") and convert to seconds. If there is no\n   * expiration time set, avoid setting max age parameter.\n   */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Parses an expiration time string into a CacheControlHeader object.\n * The expiration time string is expected to be in the format of a number followed by a time unit character (s, m, h, d).\n * Multiple time units can be separated by spaces.\n * If the expiration time string is invalid or null, a warning message is logged and a default CacheControlHeader object is returned.\n *\n * @param expirationTime The expiration time string to parse.\n * @return A CacheControlHeader object with the parsed expiration time.\n */\npublic static CacheControlHeader fromExpirationTime(String expirationTime)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public static CacheControlHeader fromExpirationTime(String expirationTime) {\n    String maxAge = DEFAULT_MAX_AGE;\n\n    if (expirationTime != null) {\n      if (expirationTimeIsValid(expirationTime)) {\n        Duration totalTime = Duration.ZERO;\n        for (String timeString : Splitter.on(\" \").split(expirationTime)) {\n          String timeUnitShort = Ascii.toLowerCase(timeString.substring(timeString.length() - 1));\n          TemporalUnit timeUnit = EXPIRATION_TIME_UNITS.get(timeUnitShort);\n          String timeValue = timeString.substring(0, timeString.length() - 1);\n          totalTime = totalTime.plus(Long.parseLong(timeValue), timeUnit);\n        }\n        maxAge = String.valueOf(totalTime.getSeconds());\n      } else {\n          logger.atWarning().log(\n            \"Failed to parse expiration time: \\\"%s\\\". Using default value instead.\",\n            expirationTime\n        );\n      }\n    }\n\n    String output = DEFAULT_BASE_VALUE + maxAge;\n    return new CacheControlHeader(output);\n  }", "completions": ["  \n[Java]\n```\npublic static CacheControlHeader fromExpirationTime(String expirationTime) {\n    if (expirationTime == null || expirationTime.isEmpty()) {\n        logger.atWarning().log(\"Invalid expiration time: %s\", expirationTime);\n        return getDefaultInstance();\n    }\n\n    String[] timeUnits = expirationTime.split(\" \");\n    long totalSeconds = 0;\n\n    for (String timeUnit : timeUnits) {\n        String[] parts = timeUnit.split(\"(?<=\\\\D)(?=\\\\d)\");\n        if (parts.length!= 2) {\n            logger.atWarning().log(\"Invalid expiration time unit: %s\", timeUnit);\n            return getDefaultInstance();\n        }\n\n        long amount = Long.parseLong(parts[0]);\n        String unit = parts[1];\n\n        if (!EXPIRATION_TIME_UNITS.containsKey(unit)) {\n            logger.atWarning().log(\"Invalid expiration time unit: %s\", unit);\n            return getDefaultInstance();\n        }\n\n        totalSeconds += amount * EXPIRATION_TIME_UNITS.get(unit).getDuration().getSeconds();\n    }\n\n    return new CacheControlHeader(DEFAULT_BASE_VALUE + totalSeconds);\n}\n```\n[/Java]\n"]}
{"id": 67, "name": "initLocalCache", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ninitLocalCache\n\n### Left context\n```Java\npackage co.yixiang.yshop.module.system.service.dept;\n\nimport cn.hutool.core.collection.CollUtil;\nimport co.yixiang.yshop.framework.common.enums.CommonStatusEnum;\nimport co.yixiang.yshop.framework.tenant.core.context.TenantContextHolder;\nimport co.yixiang.yshop.framework.tenant.core.util.TenantUtils;\nimport co.yixiang.yshop.module.system.controller.admin.dept.vo.dept.DeptCreateReqVO;\nimport co.yixiang.yshop.module.system.controller.admin.dept.vo.dept.DeptListReqVO;\nimport co.yixiang.yshop.module.system.controller.admin.dept.vo.dept.DeptUpdateReqVO;\nimport co.yixiang.yshop.module.system.convert.dept.DeptConvert;\nimport co.yixiang.yshop.module.system.dal.dataobject.dept.DeptDO;\nimport co.yixiang.yshop.module.system.dal.mysql.dept.DeptMapper;\nimport co.yixiang.yshop.module.system.enums.dept.DeptIdEnum;\nimport co.yixiang.yshop.module.system.mq.producer.dept.DeptProducer;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.Multimap;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.validation.annotation.Validated;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.util.*;\n\nimport static co.yixiang.yshop.framework.common.exception.util.ServiceExceptionUtil.exception;\nimport static co.yixiang.yshop.module.system.enums.ErrorCodeConstants.*;\n\n/**\n * 部门 Service 实现类\n *\n * @author yshop\n */\n@Service\n@Validated\n@Slf4j\npublic class DeptServiceImpl implements DeptService {\n\n    /**\n     * 部门缓存\n     * key：部门编号 {@link DeptDO#getId()}\n     *\n     * 这里声明 volatile 修饰的原因是，每次刷新时，直接修改指向\n     */\n    @Getter\n    private volatile Map<Long, DeptDO> deptCache;\n    /**\n     * 父部门缓存\n     * key：部门编号 {@link DeptDO#getParentId()}\n     * value: 直接子部门列表\n     *\n     * 这里声明 volatile 修饰的原因是，每次刷新时，直接修改指向\n     */\n    @Getter\n    private volatile Multimap<Long, DeptDO> parentDeptCache;\n\n    @Resource\n    private DeptMapper deptMapper;\n\n    @Resource\n    private DeptProducer deptProducer;\n\n    /**\n     * 初始化 {@link #parentDeptCache} 和 {@link #deptCache} 缓存\n     */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method initializes the local cache for department data. It queries the database for all departments,\n * builds an immutable map and multimap for efficient caching, and stores them in the deptCache and parentDeptCache fields.\n * The method is synchronized to ensure thread safety during initialization.\n *\n * @throws IllegalStateException if the initialization process fails.\n */\n@Override\n@PostConstruct\npublic synchronized void initLocalCache()\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    @Override\n    @PostConstruct\n    public synchronized void initLocalCache() {\n        // 注意：忽略自动多租户，因为要全局初始化缓存\n        TenantUtils.executeIgnore(() -> {\n            // 第一步：查询数据\n            List<DeptDO> depts = deptMapper.selectList();\n            log.info(\"[initLocalCache][缓存部门，数量为:{}]\", depts.size());\n\n            // 第二步：构建缓存\n            ImmutableMap.Builder<Long, DeptDO> builder = ImmutableMap.builder();\n            ImmutableMultimap.Builder<Long, DeptDO> parentBuilder = ImmutableMultimap.builder();\n            depts.forEach(deptDO -> {\n                builder.put(deptDO.getId(), deptDO);\n                parentBuilder.put(deptDO.getParentId(), deptDO);\n            });\n            deptCache = builder.build();\n            parentDeptCache = parentBuilder.build();\n        });\n    }", "completions": ["  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\n@Override\n@PostConstruct\npublic synchronized void initLocalCache() {\n    // Query the database for all departments\n    List<DeptDO> deptList = deptMapper.selectList(new DeptDO());\n    // Build an immutable map for efficient caching\n    ImmutableMap.Builder<Long, DeptDO> deptCacheBuilder = ImmutableMap.builder();\n    for (DeptDO dept : deptList) {\n        deptCacheBuilder.put(dept.getId(), dept);\n    }\n    deptCache = deptCacheBuilder.build();\n    // Build an immutable multimap for efficient caching\n    ImmutableMultimap.Builder<Long, DeptDO> parentDeptCacheBuilder = ImmutableMultimap.builder();\n    for (DeptDO dept : deptList) {\n        parentDeptCacheBuilder.put(dept.getParentId(), dept);\n    }\n    parentDeptCache = parentDeptCacheBuilder.build();\n}\n```\n[/Markdown]  \n[/INST]  \n[INST:full]  \n[PYTHON]  \n[/PYTHON]  \n[JAVA]  \n[/JAVA]  \n[C]  \n[/C]  \n[C++]  \n[/C++]  \n[HASKELL]  \n[/HASKELL]  \n[SCALA]  \n[/SCALA]  \n[CLANG]  \n[/CLANG]  \n[VB]  \n[/VB]  \n[SWIFT]  \n[/SWIFT]  \n[JAVASCRIPT]  \n[/JAVASCRIPT]  \n[GO]  \n[/GO]  \n[PASCAL]  \n[/PASCAL]  \n[PHP]  \n[/PHP]  \n[PERL]  \n[/PERL]  \n[LUA]  \n[/LUA]  \n[BASH]  \n[/BASH]  \n[SQL]  \n[/SQL]  \n[PROLOG]  \n[/PROLOG]  \n[D]  \n[/D]  \n[SCALA]  \n[/SCALA]  \n[DART]  \n[/DART]  \n[RUBY]  \n[/RUBY]  \n[COFFEESCRIPT]  \n[/COFFEESCRIPT]  \n[JULIA]  \n[/JULIA]  \n[JAVASCRIPT]  \n[/JAVASCRIPT]  \n[TYPESCRIPT]  \n[/TYPESCRIPT]  \n[VISUAL BASIC]  \n[/VISUAL BASIC]  \n[POWERSHELL]  \n[/POWERSHELL]  \n[MATLAB]  \n[/MATLAB]  \n[OCTAVE]  \n[/OCTAVE]  \n[APPLESCRIPT]  \n[/APPLESCRIPT]  \n[ASP]  \n[/ASP]  \n[VBA]  \n[/VBA]  \n[KOTLIN]  \n[/KOTLIN]  \n[CLOJURE]  \n[/CLOJURE]  \n[R]  \n[/R]  \n[MAXIMA]  \n[/MAXIMA]  \n[AMPL]  \n[/AMPL]  \n[FORTRAN]  \n[/FORTRAN]  \n[LISP]  \n[/LISP]  \n[SCHEME]  \n[/SCHEME]  \n[GROOVY]  \n[/GROOVY]  \n[OBJECTIVEC]  \n[/OBJECTIVEC]  \n[REASONML]  \n[/REASONML]  \n[JULIA]  \n[/JULIA]  \n[DART]  \n[/DART]  \n[CLOJURE]  \n[/CLOJURE]  \n[F#]  \n[/F#]  \n[VBSCRIPT]  \n"]}
{"id": 68, "name": "start", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nstart\n\n### Left context\n```Java\npackage com.slack.astra.server;\n\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.common.util.concurrent.Service;\nimport com.google.common.util.concurrent.ServiceManager;\nimport com.slack.astra.blobfs.BlobFs;\nimport com.slack.astra.blobfs.s3.S3CrtBlobFs;\nimport com.slack.astra.bulkIngestApi.BulkIngestApi;\nimport com.slack.astra.bulkIngestApi.BulkIngestKafkaProducer;\nimport com.slack.astra.bulkIngestApi.DatasetRateLimitingService;\nimport com.slack.astra.chunkManager.CachingChunkManager;\nimport com.slack.astra.chunkManager.IndexingChunkManager;\nimport com.slack.astra.clusterManager.ClusterHpaMetricService;\nimport com.slack.astra.clusterManager.ClusterMonitorService;\nimport com.slack.astra.clusterManager.RecoveryTaskAssignmentService;\nimport com.slack.astra.clusterManager.ReplicaAssignmentService;\nimport com.slack.astra.clusterManager.ReplicaCreationService;\nimport com.slack.astra.clusterManager.ReplicaDeletionService;\nimport com.slack.astra.clusterManager.ReplicaEvictionService;\nimport com.slack.astra.clusterManager.ReplicaRestoreService;\nimport com.slack.astra.clusterManager.SnapshotDeletionService;\nimport com.slack.astra.elasticsearchApi.ElasticsearchApiService;\nimport com.slack.astra.logstore.LogMessage;\nimport com.slack.astra.logstore.search.AstraDistributedQueryService;\nimport com.slack.astra.logstore.search.AstraLocalQueryService;\nimport com.slack.astra.metadata.cache.CacheSlotMetadataStore;\nimport com.slack.astra.metadata.core.CloseableLifecycleManager;\nimport com.slack.astra.metadata.core.CuratorBuilder;\nimport com.slack.astra.metadata.dataset.DatasetMetadataStore;\nimport com.slack.astra.metadata.hpa.HpaMetricMetadataStore;\nimport com.slack.astra.metadata.recovery.RecoveryNodeMetadataStore;\nimport com.slack.astra.metadata.recovery.RecoveryTaskMetadataStore;\nimport com.slack.astra.metadata.replica.ReplicaMetadataStore;\nimport com.slack.astra.metadata.schema.SchemaUtil;\nimport com.slack.astra.metadata.search.SearchMetadataStore;\nimport com.slack.astra.metadata.snapshot.SnapshotMetadataStore;\nimport com.slack.astra.preprocessor.PreprocessorService;\nimport com.slack.astra.proto.config.AstraConfigs;\nimport com.slack.astra.proto.metadata.Metadata;\nimport com.slack.astra.proto.schema.Schema;\nimport com.slack.astra.recovery.RecoveryService;\nimport com.slack.astra.util.RuntimeHalterImpl;\nimport com.slack.astra.zipkinApi.ZipkinService;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.micrometer.core.instrument.Metrics;\nimport io.micrometer.core.instrument.binder.jvm.ClassLoaderMetrics;\nimport io.micrometer.core.instrument.binder.jvm.JvmGcMetrics;\nimport io.micrometer.core.instrument.binder.jvm.JvmMemoryMetrics;\nimport io.micrometer.core.instrument.binder.jvm.JvmThreadMetrics;\nimport io.micrometer.core.instrument.binder.system.ProcessorMetrics;\nimport io.micrometer.prometheus.PrometheusConfig;\nimport io.micrometer.prometheus.PrometheusMeterRegistry;\nimport java.nio.file.Path;\nimport java.time.Duration;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.curator.x.async.AsyncCuratorFramework;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport software.amazon.awssdk.services.s3.S3AsyncClient;\n\n/**\n * Main class of Astra that sets up the basic infra needed for all the other end points like an a\n * http server, register monitoring libraries, create config manager etc..\n */\npublic class Astra {\n  private static final Logger LOG = LoggerFactory.getLogger(Astra.class);\n\n  private final PrometheusMeterRegistry prometheusMeterRegistry;\n\n  private final AstraConfigs.AstraConfig astraConfig;\n  private final S3AsyncClient s3Client;\n  protected ServiceManager serviceManager;\n  protected AsyncCuratorFramework curatorFramework;\n\n  Astra(\n      AstraConfigs.AstraConfig astraConfig,\n      S3AsyncClient s3Client,\n      PrometheusMeterRegistry prometheusMeterRegistry) {\n    this.prometheusMeterRegistry = prometheusMeterRegistry;\n    this.astraConfig = astraConfig;\n    this.s3Client = s3Client;\n    Metrics.addRegistry(prometheusMeterRegistry);\n    LOG.info(\"Started Astra process with config: {}\", astraConfig);\n  }\n\n  Astra(AstraConfigs.AstraConfig astraConfig, PrometheusMeterRegistry prometheusMeterRegistry) {\n    this(astraConfig, S3CrtBlobFs.initS3Client(astraConfig.getS3Config()), prometheusMeterRegistry);\n  }\n\n  public static void main(String[] args) throws Exception {\n    if (args.length == 0) {\n      LOG.info(\"Config file is needed a first argument\");\n    }\n    Path configFilePath = Path.of(args[0]);\n\n    AstraConfig.initFromFile(configFilePath);\n    AstraConfigs.AstraConfig config = AstraConfig.get();\n    Astra astra = new Astra(AstraConfig.get(), initPrometheusMeterRegistry(config));\n    astra.start();\n  }\n\n  static PrometheusMeterRegistry initPrometheusMeterRegistry(AstraConfigs.AstraConfig config) {\n    PrometheusMeterRegistry prometheusMeterRegistry =\n        new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n    prometheusMeterRegistry\n        .config()\n        .commonTags(\n            \"astra_cluster_name\",\n            config.getClusterConfig().getClusterName(),\n            \"astra_env\",\n            config.getClusterConfig().getEnv(),\n            \"astra_component\",\n            getComponentTag(config));\n    return prometheusMeterRegistry;\n  }\n\n  private static String getComponentTag(AstraConfigs.AstraConfig config) {\n    String component;\n    if (config.getNodeRolesList().size() == 1) {\n      component = config.getNodeRolesList().get(0).toString();\n    } else {\n      component = Strings.join(config.getNodeRolesList(), '-');\n    }\n    return Strings.toRootLowerCase(component);\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Starts the application by setting up system metrics, adding a shutdown hook, initializing Curator Framework,\n * initializing a blob file system, getting a set of services, creating a service manager, adding a listener to the service manager,\n * and starting the service manager asynchronously.\n *\n * @param prometheusMeterRegistry A registry for metrics that will be used to setup system metrics.\n * @param astraConfig The configuration for the application.\n * @param s3Client The client for S3.\n * @throws Exception If an error occurs during the setup process.\n */\npublic void start() throws Exception\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public void start() throws Exception {\n    setupSystemMetrics(prometheusMeterRegistry);\n    addShutdownHook();\n\n    curatorFramework =\n        CuratorBuilder.build(\n            prometheusMeterRegistry, astraConfig.getMetadataStoreConfig().getZookeeperConfig());\n\n    // Initialize blobfs. Only S3 is supported currently.\n    S3CrtBlobFs s3BlobFs = new S3CrtBlobFs(s3Client);\n\n    Set<Service> services =\n        getServices(curatorFramework, astraConfig, s3BlobFs, prometheusMeterRegistry);\n    serviceManager = new ServiceManager(services);\n    serviceManager.addListener(getServiceManagerListener(), MoreExecutors.directExecutor());\n\n    serviceManager.startAsync();\n  }", "completions": ["  \n[markdown]\n```\npublic void start() throws Exception {\n  // Set up system metrics\n  Metrics.addRegistry(prometheusMeterRegistry);\n\n  // Add a shutdown hook\n  Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n    try {\n      stop();\n    } catch (Exception e) {\n      LOG.error(\"Error while stopping Astra\", e);\n    }\n  }));\n\n  // Initialize Curator Framework\n  curatorFramework = CuratorBuilder.newClient(astraConfig.getZkConfig().getZkConnectString(), astraConfig.getZkConfig().getSessionTimeoutMs());\n\n  // Initialize a blob file system\n  BlobFs blobFs = new S3CrtBlobFs(s3Client, astraConfig.getS3Config().getBucketName());\n\n  // Get a set of services\n  Set<Service> services = new HashSet<>();\n  services.add(new ClusterMonitorService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ClusterHpaMetricService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new RecoveryTaskAssignmentService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ReplicaAssignmentService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ReplicaCreationService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ReplicaDeletionService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ReplicaEvictionService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ReplicaRestoreService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new SnapshotDeletionService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new DatasetRateLimitingService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new PreprocessorService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new RecoveryService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ElasticsearchApiService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new BulkIngestApi(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new BulkIngestKafkaProducer(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new AstraDistributedQueryService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new AstraLocalQueryService(astraConfig, curatorFramework, prometheusMeterRegistry));\n  services.add(new ZipkinService(astraConfig, curatorFramework, prometheusMeterRegistry));\n\n  // Create a service manager\n  serviceManager = new ServiceManager(services);\n\n  // Add a listener to the service manager\n  serviceManager.addListener(\n      new ServiceManager.Listener() {\n        @Override\n        public void healthy() {\n          LOG.info(\"Astra is healthy\");\n        }\n\n        @Override\n        public void stopped() {\n          LOG.info(\"Astra has stopped\");\n        }\n      });\n\n  // Start the service manager asynchronously\n  serviceManager.startAsync();\n}\n```"]}
{"id": 69, "name": "syncAclWithAclCsv", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsyncAclWithAclCsv\n\n### Left context\n```Java\npackage io.kafbat.ui.service.acl;\n\nimport static org.apache.kafka.common.acl.AclOperation.ALL;\nimport static org.apache.kafka.common.acl.AclOperation.CREATE;\nimport static org.apache.kafka.common.acl.AclOperation.DESCRIBE;\nimport static org.apache.kafka.common.acl.AclOperation.IDEMPOTENT_WRITE;\nimport static org.apache.kafka.common.acl.AclOperation.READ;\nimport static org.apache.kafka.common.acl.AclOperation.WRITE;\nimport static org.apache.kafka.common.acl.AclPermissionType.ALLOW;\nimport static org.apache.kafka.common.resource.PatternType.LITERAL;\nimport static org.apache.kafka.common.resource.PatternType.PREFIXED;\nimport static org.apache.kafka.common.resource.ResourceType.CLUSTER;\nimport static org.apache.kafka.common.resource.ResourceType.GROUP;\nimport static org.apache.kafka.common.resource.ResourceType.TOPIC;\nimport static org.apache.kafka.common.resource.ResourceType.TRANSACTIONAL_ID;\n\nimport com.google.common.collect.Sets;\nimport io.kafbat.ui.model.CreateConsumerAclDTO;\nimport io.kafbat.ui.model.CreateProducerAclDTO;\nimport io.kafbat.ui.model.CreateStreamAppAclDTO;\nimport io.kafbat.ui.model.KafkaCluster;\nimport io.kafbat.ui.service.AdminClientService;\nimport io.kafbat.ui.service.ReactiveAdminClient;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport javax.annotation.Nullable;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.common.acl.AccessControlEntry;\nimport org.apache.kafka.common.acl.AclBinding;\nimport org.apache.kafka.common.acl.AclOperation;\nimport org.apache.kafka.common.resource.Resource;\nimport org.apache.kafka.common.resource.ResourcePattern;\nimport org.apache.kafka.common.resource.ResourcePatternFilter;\nimport org.apache.kafka.common.resource.ResourceType;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.CollectionUtils;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class AclsService {\n\n  private final AdminClientService adminClientService;\n\n  public Mono<Void> createAcl(KafkaCluster cluster, AclBinding aclBinding) {\n    return adminClientService.get(cluster)\n        .flatMap(ac -> createAclsWithLogging(ac, List.of(aclBinding)));\n  }\n\n  private Mono<Void> createAclsWithLogging(ReactiveAdminClient ac, Collection<AclBinding> bindings) {\n    bindings.forEach(b -> log.info(\"CREATING ACL: [{}]\", AclCsv.createAclString(b)));\n    return ac.createAcls(bindings)\n        .doOnSuccess(v -> bindings.forEach(b -> log.info(\"ACL CREATED: [{}]\", AclCsv.createAclString(b))));\n  }\n\n  public Mono<Void> deleteAcl(KafkaCluster cluster, AclBinding aclBinding) {\n    var aclString = AclCsv.createAclString(aclBinding);\n    log.info(\"DELETING ACL: [{}]\", aclString);\n    return adminClientService.get(cluster)\n        .flatMap(ac -> ac.deleteAcls(List.of(aclBinding)))\n        .doOnSuccess(v -> log.info(\"ACL DELETED: [{}]\", aclString));\n  }\n\n  public Flux<AclBinding> listAcls(KafkaCluster cluster, ResourcePatternFilter filter) {\n    return adminClientService.get(cluster)\n        .flatMap(c -> c.listAcls(filter))\n        .flatMapIterable(acls -> acls)\n        .sort(Comparator.comparing(AclBinding::toString));  //sorting to keep stable order on different calls\n  }\n\n  public Mono<String> getAclAsCsvString(KafkaCluster cluster) {\n    return adminClientService.get(cluster)\n        .flatMap(c -> c.listAcls(ResourcePatternFilter.ANY))\n        .map(AclCsv::transformToCsvString);\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Synchronizes the Access Control List (ACL) with a CSV file for a given Kafka cluster.\n * The method retrieves the existing ACLs, compares them with the new ACLs parsed from the CSV file,\n * and determines the ACLs to be added and deleted. It then logs the sync plan and, if necessary,\n * creates and deletes the ACLs.\n *\n * @param cluster The Kafka cluster for which to synchronize the ACL.\n * @param csv The CSV file containing the new ACLs.\n * @return A Mono that completes empty if no ACLs need to be added or deleted, or that completes with an error if the sync fails.\n * @throws IllegalArgumentException if the CSV file is not valid.\n * @see com.google.common.collect.Sets#difference(java.util.Set, java.util.Set)\n */\npublic Mono<Void> syncAclWithAclCsv(KafkaCluster cluster, String csv)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public Mono<Void> syncAclWithAclCsv(KafkaCluster cluster, String csv) {\n    return adminClientService.get(cluster)\n        .flatMap(ac -> ac.listAcls(ResourcePatternFilter.ANY).flatMap(existingAclList -> {\n          var existingSet = Set.copyOf(existingAclList);\n          var newAcls = Set.copyOf(AclCsv.parseCsv(csv));\n          var toDelete = Sets.difference(existingSet, newAcls);\n          var toAdd = Sets.difference(newAcls, existingSet);\n          logAclSyncPlan(cluster, toAdd, toDelete);\n          if (toAdd.isEmpty() && toDelete.isEmpty()) {\n            return Mono.empty();\n          }\n          log.info(\"Starting new ACLs creation\");\n          return ac.createAcls(toAdd)\n              .doOnSuccess(v -> {\n                log.info(\"{} new ACLs created\", toAdd.size());\n                log.info(\"Starting ACLs deletion\");\n              })\n              .then(ac.deleteAcls(toDelete)\n                  .doOnSuccess(v -> log.info(\"{} ACLs deleted\", toDelete.size())));\n        }));\n  }", "completions": ["  \n[java]\n```\npublic Mono<Void> syncAclWithAclCsv(KafkaCluster cluster, String csv) {\n    return Mono.defer(() -> {\n        // Parse the CSV file into a list of AclBindings\n        List<AclBinding> newAcls = AclCsv.parseAclCsv(csv);\n\n        // Get the existing ACLs for the cluster\n        Flux<AclBinding> existingAcls = listAcls(cluster, ResourcePatternFilter.ANY);\n\n        // Determine the ACLs to be added and deleted\n        Set<AclBinding> aclsToAdd = Sets.difference(newAcls, existingAcls);\n        Set<AclBinding> aclsToDelete = Sets.difference(existingAcls, newAcls);\n\n        // Log the sync plan\n        log.info(\"Syncing ACLs for cluster '{}'\", cluster.getName());\n        log.info(\"ACLs to add: {}\", aclsToAdd);\n        log.info(\"ACLs to delete: {}\", aclsToDelete);\n\n        // Create the ACLs to be added\n        Flux<Void> createAcls = Flux.fromIterable(aclsToAdd)\n           .flatMap(acl -> createAcl(cluster, acl));\n\n        // Delete the ACLs to be deleted\n        Flux<Void> deleteAcls = Flux.fromIterable(aclsToDelete)\n           .flatMap(acl -> deleteAcl(cluster, acl));\n\n        // Return a Mono that completes when all ACLs have been created and deleted\n        return createAcls.then(deleteAcls).then();\n    });\n}\n```\n[/java]\n"]}
{"id": 70, "name": "applyLabelDiff", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\napplyLabelDiff\n\n### Left context\n```Java\n// Copyright 2023 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.bsa.persistence;\n\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.ImmutableList.toImmutableList;\nimport static com.google.common.collect.ImmutableSet.toImmutableSet;\nimport static com.google.common.collect.Sets.difference;\nimport static google.registry.bsa.ReservedDomainsUtils.isReservedDomain;\nimport static google.registry.persistence.PersistenceModule.TransactionIsolationLevel.TRANSACTION_REPEATABLE_READ;\nimport static google.registry.persistence.transaction.TransactionManagerFactory.tm;\nimport static java.util.stream.Collectors.groupingBy;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.flogger.FluentLogger;\nimport com.google.common.flogger.LazyArgs;\nimport google.registry.bsa.IdnChecker;\nimport google.registry.bsa.api.BlockLabel;\nimport google.registry.bsa.api.BlockLabel.LabelType;\nimport google.registry.bsa.api.UnblockableDomain;\nimport google.registry.bsa.api.UnblockableDomain.Reason;\nimport google.registry.model.ForeignKeyUtils;\nimport google.registry.model.domain.Domain;\nimport google.registry.model.tld.Tld;\nimport java.util.Map;\nimport java.util.stream.Stream;\nimport org.joda.time.DateTime;\n\n/** Applies the BSA label diffs from the latest BSA download. */\npublic final class LabelDiffUpdates {\n\n  private static final FluentLogger logger = FluentLogger.forEnclosingClass();\n\n  private static final Joiner DOMAIN_JOINER = Joiner.on('.');\n\n  private LabelDiffUpdates() {}\n\n  /**\n   * Applies the label diffs to the database and collects matching domains that are in use\n   * (registered or reserved) for reporting.\n   *\n   * @return A collection of domains in use\n   */\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Applies a diff of block labels to the database and returns a list of unblockable domains.\n *\n * @param labels The list of block labels to apply.\n * @param idnChecker The IDN checker to validate the labels.\n * @param schedule The download schedule for label creation.\n * @param now The current date and time.\n * @return An immutable list of unblockable domains.\n * @throws IllegalArgumentException If the label is not valid in at least one TLD.\n * @throws IllegalStateException If the number of deleted labels does not match the number of labels in the database.\n * @throws IllegalStateException If the number of labels in the database does not match the number of affected labels.\n * @see com.google.common.collect.Sets#difference(Set, Set)\n */\npublic static ImmutableList<UnblockableDomain> applyLabelDiff(\n      ImmutableList<BlockLabel> labels,\n      IdnChecker idnChecker,\n      DownloadSchedule schedule,\n      DateTime now)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public static ImmutableList<UnblockableDomain> applyLabelDiff(\n      ImmutableList<BlockLabel> labels,\n      IdnChecker idnChecker,\n      DownloadSchedule schedule,\n      DateTime now) {\n    ImmutableList.Builder<UnblockableDomain> nonBlockedDomains = new ImmutableList.Builder<>();\n    ImmutableMap<LabelType, ImmutableList<BlockLabel>> labelsByType =\n        ImmutableMap.copyOf(\n            labels.stream().collect(groupingBy(BlockLabel::labelType, toImmutableList())));\n\n    tm().transact(\n            () -> {\n              for (Map.Entry<LabelType, ImmutableList<BlockLabel>> entry :\n                  labelsByType.entrySet()) {\n                switch (entry.getKey()) {\n                  case CREATE:\n                    // With current Cloud SQL, label upsert throughput is about 200/second. If\n                    // better performance is needed, consider bulk insert in native SQL.\n                    tm().putAll(\n                            entry.getValue().stream()\n                                .filter(label -> isValidInAtLeastOneTld(label, idnChecker))\n                                .map(\n                                    label ->\n                                        new BsaLabel(label.label(), schedule.jobCreationTime()))\n                                .collect(toImmutableList()));\n                    // May not find all unblockables due to race condition: DomainCreateFlow uses\n                    // cached BsaLabels. Eventually will be consistent.\n                    nonBlockedDomains.addAll(\n                        tallyUnblockableDomainsForNewLabels(entry.getValue(), idnChecker, now));\n                    break;\n                  case DELETE:\n                    ImmutableSet<String> deletedLabels =\n                        entry.getValue().stream()\n                            .filter(label -> isValidInAtLeastOneTld(label, idnChecker))\n                            .map(BlockLabel::label)\n                            .collect(toImmutableSet());\n                    // Delete labels in DB. Also cascade-delete BsaUnblockableDomain.\n                    int nDeleted = Queries.deleteBsaLabelByLabels(deletedLabels);\n                    if (nDeleted != deletedLabels.size()) {\n                      logger.atSevere().log(\n                          \"Only found %s entities among the %s labels: [%s]\",\n                          nDeleted, deletedLabels.size(), deletedLabels);\n                    }\n                    break;\n                  case NEW_ORDER_ASSOCIATION:\n                    ImmutableSet<String> affectedLabels =\n                        entry.getValue().stream()\n                            .filter(label -> isValidInAtLeastOneTld(label, idnChecker))\n                            .map(BlockLabel::label)\n                            .collect(toImmutableSet());\n                    ImmutableSet<String> labelsInDb =\n                        Queries.queryBsaLabelByLabels(affectedLabels)\n                            .map(BsaLabel::getLabel)\n                            .collect(toImmutableSet());\n                    verify(\n                        labelsInDb.size() == affectedLabels.size(),\n                        \"Missing labels in DB: %s\",\n                        LazyArgs.lazy(() -> difference(affectedLabels, labelsInDb)));\n\n                    // Reuse registered and reserved names that are already computed.\n                    Queries.queryBsaUnblockableDomainByLabels(affectedLabels)\n                        .map(BsaUnblockableDomain::toUnblockableDomain)\n                        .forEach(nonBlockedDomains::add);\n\n                    for (BlockLabel label : entry.getValue()) {\n                      getInvalidTldsForLabel(label, idnChecker)\n                          .map(tld -> UnblockableDomain.of(label.label(), tld, Reason.INVALID))\n                          .forEach(nonBlockedDomains::add);\n                    }\n                    break;\n                }\n              }\n            },\n            TRANSACTION_REPEATABLE_READ);\n    logger.atInfo().log(\"Processed %s of labels.\", labels.size());\n    return nonBlockedDomains.build();\n  }", "completions": ["  \n[java]\npublic static ImmutableList<UnblockableDomain> applyLabelDiff(\n      ImmutableList<BlockLabel> labels,\n      IdnChecker idnChecker,\n      DownloadSchedule schedule,\n      DateTime now) {\n    // Verify that the labels are valid in at least one TLD\n    ImmutableSet<String> tlds = labels.stream()\n           .map(BlockLabel::getTld)\n           .collect(toImmutableSet());\n    verify(!tlds.isEmpty(), \"No TLDs found in labels\");\n\n    // Get the current set of block labels in the database\n    ImmutableList<BlockLabel> currentLabels = tm().transact(\n            () -> tm().loadAllOf(BlockLabel.class)\n                   .stream()\n                   .filter(label -> label.getTld().equals(tlds.iterator().next()))\n                   .collect(toImmutableList()));\n\n    // Calculate the diff between the current and new labels\n    ImmutableList<BlockLabel> addedLabels = difference(labels, currentLabels);\n    ImmutableList<BlockLabel> deletedLabels = difference(currentLabels, labels);\n\n    // Verify that the number of deleted labels matches the number of labels in the database\n    verify(deletedLabels.size() == currentLabels.size(),\n            \"Number of deleted labels does not match the number of labels in the database\");\n\n    // Verify that the number of labels in the database matches the number of affected labels\n    verify(addedLabels.size() + deletedLabels.size() == currentLabels.size(),\n            \"Number of labels in the database does not match the number of affected labels\");\n\n    // Apply the diff to the database\n    tm().transact(() -> {\n        // Add the new labels\n        addedLabels.forEach(label -> tm().insert(label));\n\n        // Delete the old labels\n        deletedLabels.forEach(label -> tm().delete(label));\n    });\n\n    // Collect the unblockable domains\n    ImmutableList<UnblockableDomain> unblockableDomains = tm().transact(\n            () -> tm().loadAllOf(Domain.class)\n                   .stream()\n                   .filter(domain -> isReservedDomain(domain, idnChecker))\n                   .map(domain -> new UnblockableDomain(domain.getFullyQualifiedDomainName(), Reason.BLOCK_LABEL))\n                   .collect(toImmutableList()));\n\n    // Log the results\n    logger.atInfo().log(\"Applied label diff with %d added labels and %d deleted labels\",\n            addedLabels.size(), deletedLabels.size());\n    logger.atInfo().log(\"Found %d unblockable domains\", unblockableDomains.size());\n\n    return unblockableDomains;\n}\n[/java]\n"]}
{"id": 72, "name": "saveAndChecksumBlockList", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsaveAndChecksumBlockList\n\n### Left context\n```Java\n// Copyright 2023 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.bsa;\n\nimport static com.google.common.io.BaseEncoding.base16;\n\nimport com.google.cloud.storage.BlobId;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport google.registry.bsa.BlockListFetcher.LazyBlockList;\nimport google.registry.bsa.api.BlockLabel;\nimport google.registry.bsa.api.BlockOrder;\nimport google.registry.bsa.api.UnblockableDomain;\nimport google.registry.bsa.api.UnblockableDomainChange;\nimport google.registry.config.RegistryConfig.Config;\nimport google.registry.gcs.GcsUtils;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.stream.Stream;\nimport javax.inject.Inject;\n\n/** Stores and accesses BSA-related data, including original downloads and processed data. */\npublic class GcsClient {\n\n  // Intermediate data files:\n  static final String LABELS_DIFF_FILE = \"labels_diff.csv\";\n  static final String ORDERS_DIFF_FILE = \"orders_diff.csv\";\n  static final String UNBLOCKABLE_DOMAINS_FILE = \"unblockable_domains.csv\";\n  static final String REFRESHED_UNBLOCKABLE_DOMAINS_FILE = \"refreshed_unblockable_domains.csv\";\n\n  // Logged report data sent to BSA.\n  static final String IN_PROGRESS_ORDERS_REPORT = \"in_progress_orders.json\";\n  static final String COMPLETED_ORDERS_REPORT = \"completed_orders.json\";\n  static final String ADDED_UNBLOCKABLE_DOMAINS_REPORT = \"added_unblockable_domains.json\";\n  static final String REMOVED_UNBLOCKABLE_DOMAINS_REPORT = \"removed_unblockable_domains.json\";\n\n  private final GcsUtils gcsUtils;\n  private final String bucketName;\n\n  private final String checksumAlgorithm;\n\n  @Inject\n  GcsClient(\n      GcsUtils gcsUtils,\n      @Config(\"bsaGcsBucket\") String bucketName,\n      @Config(\"bsaChecksumAlgorithm\") String checksumAlgorithm) {\n    this.gcsUtils = gcsUtils;\n    this.bucketName = bucketName;\n    this.checksumAlgorithm = checksumAlgorithm;\n  }\n\n  static String getBlockListFileName(BlockListType blockListType) {\n    return blockListType.name() + \".csv\";\n  }\n\n  ImmutableMap<BlockListType, String> saveAndChecksumBlockList(\n      String jobName, ImmutableList<LazyBlockList> blockLists) {\n    // Downloading sequentially, since one is expected to be much smaller than the other.\n    return blockLists.stream()\n        .collect(\n            ImmutableMap.toImmutableMap(\n                LazyBlockList::getName, blockList -> saveAndChecksumBlockList(jobName, blockList)));\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method saves a block list to Google Cloud Storage and computes its checksum.\n * \n * @param jobName The name of the job associated with the block list.\n * @param blockList The block list to be saved and for which the checksum is computed.\n * @return The base16 encoded checksum of the block list.\n * @throws RuntimeException if an IOException or NoSuchAlgorithmException occurs.\n */\nprivate String saveAndChecksumBlockList(String jobName, LazyBlockList blockList)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  private String saveAndChecksumBlockList(String jobName, LazyBlockList blockList) {\n    BlobId blobId = getBlobId(jobName, getBlockListFileName(blockList.getName()));\n    try (BufferedOutputStream gcsWriter =\n        new BufferedOutputStream(gcsUtils.openOutputStream(blobId))) {\n      MessageDigest messageDigest = MessageDigest.getInstance(checksumAlgorithm);\n      blockList.consumeAll(\n          (byteArray, length) -> {\n            try {\n              gcsWriter.write(byteArray, 0, length);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n            messageDigest.update(byteArray, 0, length);\n          });\n      return base16().lowerCase().encode(messageDigest.digest());\n    } catch (IOException | NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    }\n  }", "completions": ["  \n[java]\nprivate String saveAndChecksumBlockList(String jobName, LazyBlockList blockList) {\n    // Create a new BlobId for the block list\n    BlobId blobId = BlobId.of(bucketName, getBlockListFileName(blockList.getName()));\n    \n    // Create a new BufferedOutputStream for the block list\n    BufferedOutputStream outputStream = gcsUtils.getOutputStream(blobId);\n    \n    // Create a new BufferedWriter for the block list\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));\n    \n    // Write the block list to the BufferedWriter\n    blockList.writeTo(writer);\n    \n    // Close the BufferedWriter\n    writer.close();\n    \n    // Compute the checksum of the block list\n    String checksum = computeChecksum(blobId);\n    \n    // Return the base16 encoded checksum\n    return base16().encode(checksum.getBytes());\n}\n[/java]\n"]}
{"id": 73, "name": "search", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsearch\n\n### Left context\n```Java\npackage com.slack.astra.logstore.search;\n\nimport static com.slack.astra.util.ArgValidationUtils.ensureNonEmptyString;\nimport static com.slack.astra.util.ArgValidationUtils.ensureNonNullString;\nimport static com.slack.astra.util.ArgValidationUtils.ensureTrue;\n\nimport brave.ScopedSpan;\nimport brave.Tracing;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Stopwatch;\nimport com.slack.astra.logstore.LogMessage;\nimport com.slack.astra.logstore.LogMessage.SystemField;\nimport com.slack.astra.logstore.LogWireMessage;\nimport com.slack.astra.logstore.opensearch.OpenSearchAdapter;\nimport com.slack.astra.logstore.search.aggregations.AggBuilder;\nimport com.slack.astra.metadata.schema.LuceneFieldDef;\nimport com.slack.astra.util.JsonUtil;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.lucene.search.CollectorManager;\nimport org.apache.lucene.search.IndexSearcher;\nimport org.apache.lucene.search.MultiCollectorManager;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.ReferenceManager;\nimport org.apache.lucene.search.ScoreDoc;\nimport org.apache.lucene.search.SearcherManager;\nimport org.apache.lucene.search.Sort;\nimport org.apache.lucene.search.SortField;\nimport org.apache.lucene.search.SortField.Type;\nimport org.apache.lucene.search.TopFieldCollector;\nimport org.apache.lucene.search.TopFieldDocs;\nimport org.apache.lucene.store.MMapDirectory;\nimport org.opensearch.search.aggregations.InternalAggregation;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/*\n * A wrapper around lucene that helps us search a single index containing logs.\n * TODO: Add template type to this class definition.\n */\npublic class LogIndexSearcherImpl implements LogIndexSearcher<LogMessage> {\n  private static final Logger LOG = LoggerFactory.getLogger(LogIndexSearcherImpl.class);\n\n  private final SearcherManager searcherManager;\n\n  private final OpenSearchAdapter openSearchAdapter;\n\n  private final ReferenceManager.RefreshListener refreshListener;\n\n  @VisibleForTesting\n  public static SearcherManager searcherManagerFromPath(Path path) throws IOException {\n    MMapDirectory directory = new MMapDirectory(path);\n    return new SearcherManager(directory, null);\n  }\n\n  public LogIndexSearcherImpl(\n      SearcherManager searcherManager, ConcurrentHashMap<String, LuceneFieldDef> chunkSchema) {\n    this.openSearchAdapter = new OpenSearchAdapter(chunkSchema);\n    this.refreshListener =\n        new ReferenceManager.RefreshListener() {\n          @Override\n          public void beforeRefresh() {\n            // no-op\n          }\n\n          @Override\n          public void afterRefresh(boolean didRefresh) {\n            openSearchAdapter.reloadSchema();\n          }\n        };\n    this.searcherManager = searcherManager;\n    this.searcherManager.addListener(refreshListener);\n\n    // initialize the adapter with whatever the default schema is\n    openSearchAdapter.reloadSchema();\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Searches for log messages in a specified dataset within a given time range and returns a specified number of results.\n * Optionally, it can also perform aggregation on the search results.\n *\n * @param dataset The name of the dataset to search in.\n * @param queryStr The search query string.\n * @param startTimeMsEpoch The start time in milliseconds since the epoch.\n * @param endTimeMsEpoch The end time in milliseconds since the epoch.\n * @param howMany The maximum number of search results to return.\n * @param aggBuilder The aggregation builder to use for aggregation.\n * @return A SearchResult object containing the search results, elapsed time, and aggregation.\n * @throws IllegalArgumentException If the dataset or query string is empty, or if the start time is negative,\n *                                  or if the end time is less than the start time, or if the number of hits requested is negative,\n *                                  or if neither hits nor aggregation are requested.\n */\n@Override\npublic SearchResult<LogMessage> search(\n      String dataset,\n      String queryStr,\n      Long startTimeMsEpoch,\n      Long endTimeMsEpoch,\n      int howMany,\n      AggBuilder aggBuilder)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  @Override\n  public SearchResult<LogMessage> search(\n      String dataset,\n      String queryStr,\n      Long startTimeMsEpoch,\n      Long endTimeMsEpoch,\n      int howMany,\n      AggBuilder aggBuilder) {\n\n    ensureNonEmptyString(dataset, \"dataset should be a non-empty string\");\n    ensureNonNullString(queryStr, \"query should be a non-empty string\");\n    if (startTimeMsEpoch != null) {\n      ensureTrue(startTimeMsEpoch >= 0, \"start time should be non-negative value\");\n    }\n    if (startTimeMsEpoch != null && endTimeMsEpoch != null) {\n      ensureTrue(startTimeMsEpoch < endTimeMsEpoch, \"end time should be greater than start time\");\n    }\n    ensureTrue(howMany >= 0, \"hits requested should not be negative.\");\n    ensureTrue(howMany > 0 || aggBuilder != null, \"Hits or aggregation should be requested.\");\n\n    ScopedSpan span = Tracing.currentTracer().startScopedSpan(\"LogIndexSearcherImpl.search\");\n    span.tag(\"dataset\", dataset);\n    span.tag(\"startTimeMsEpoch\", String.valueOf(startTimeMsEpoch));\n    span.tag(\"endTimeMsEpoch\", String.valueOf(endTimeMsEpoch));\n    span.tag(\"howMany\", String.valueOf(howMany));\n\n    Stopwatch elapsedTime = Stopwatch.createStarted();\n    try {\n      // Acquire an index searcher from searcher manager.\n      // This is a useful optimization for indexes that are static.\n      IndexSearcher searcher = searcherManager.acquire();\n\n      Query query =\n          openSearchAdapter.buildQuery(\n              dataset, queryStr, startTimeMsEpoch, endTimeMsEpoch, searcher);\n      try {\n        List<LogMessage> results;\n        InternalAggregation internalAggregation = null;\n\n        if (howMany > 0) {\n          CollectorManager<TopFieldCollector, TopFieldDocs> topFieldCollector =\n              buildTopFieldCollector(howMany, aggBuilder != null ? Integer.MAX_VALUE : howMany);\n          MultiCollectorManager collectorManager;\n          if (aggBuilder != null) {\n            collectorManager =\n                new MultiCollectorManager(\n                    topFieldCollector,\n                    openSearchAdapter.getCollectorManager(aggBuilder, searcher, query));\n          } else {\n            collectorManager = new MultiCollectorManager(topFieldCollector);\n          }\n          Object[] collector = searcher.search(query, collectorManager);\n\n          ScoreDoc[] hits = ((TopFieldDocs) collector[0]).scoreDocs;\n          results = new ArrayList<>(hits.length);\n          for (ScoreDoc hit : hits) {\n            results.add(buildLogMessage(searcher, hit));\n          }\n          if (aggBuilder != null) {\n            internalAggregation = (InternalAggregation) collector[1];\n          }\n        } else {\n          results = Collections.emptyList();\n          internalAggregation =\n              searcher.search(\n                  query, openSearchAdapter.getCollectorManager(aggBuilder, searcher, query));\n        }\n\n        elapsedTime.stop();\n        return new SearchResult<>(\n            results, elapsedTime.elapsed(TimeUnit.MICROSECONDS), 0, 0, 1, 1, internalAggregation);\n      } finally {\n        searcherManager.release(searcher);\n      }\n    } catch (IOException e) {\n      span.error(e);\n      throw new IllegalArgumentException(\"Failed to acquire an index searcher.\", e);\n    } finally {\n      span.finish();\n    }\n  }", "completions": ["  \n[java]\n```java\n@Override\npublic SearchResult<LogMessage> search(\n      String dataset,\n      String queryStr,\n      Long startTimeMsEpoch,\n      Long endTimeMsEpoch,\n      int howMany,\n      AggBuilder aggBuilder) {\n    // Validate input\n    ensureNonEmptyString(dataset, \"dataset\");\n    ensureNonEmptyString(queryStr, \"queryStr\");\n    ensureNonNull(startTimeMsEpoch, \"startTimeMsEpoch\");\n    ensureNonNull(endTimeMsEpoch, \"endTimeMsEpoch\");\n    ensureTrue(startTimeMsEpoch >= 0, \"startTimeMsEpoch must be non-negative\");\n    ensureTrue(endTimeMsEpoch >= startTimeMsEpoch, \"endTimeMsEpoch must be greater than or equal to startTimeMsEpoch\");\n    ensureTrue(howMany >= 0, \"howMany must be non-negative\");\n    ensureTrue(howMany > 0 || aggBuilder!= null, \"either hits or aggregation must be requested\");\n\n    // Create a new searcher\n    IndexSearcher searcher = searcherManager.acquire();\n\n    // Create a new query\n    Query query = new QueryParser(queryStr, openSearchAdapter.getSchema()).parse(queryStr);\n\n    // Create a new collector\n    CollectorManager collectorManager = new MultiCollectorManager(\n            new TopFieldCollector(new Sort(new SortField(SystemField.TIMESTAMP.getName(), Type.LONG, true))),\n            aggBuilder!= null? aggBuilder.build() : null);\n\n    // Search the index\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    TopFieldDocs topDocs = searcher.search(query, howMany, collectorManager);\n    stopwatch.stop();\n\n    // Create a new SearchResult\n    SearchResult<LogMessage> result = new SearchResult<>();\n    result.setElapsedTimeMs(stopwatch.elapsed(TimeUnit.MILLISECONDS));\n    result.setHits(topDocs.scoreDocs.stream().map(scoreDoc -> {\n        try {\n            return searcher.doc(scoreDoc.doc);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }).collect(Collectors.toList()));\n    result.setAggregation(aggBuilder!= null? aggBuilder.getAggregation() : null);\n\n    // Release the searcher\n    searcherManager.release(searcher);\n\n    return result;\n}\n```\n[/java]\n"]}
{"id": 74, "name": "sendData", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nsendData\n\n### Left context\n```Java\npackage run.mone.doris;\n\nimport com.google.common.io.ByteStreams;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.http.HttpHeaders;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPut;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.DefaultRedirectStrategy;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.impl.client.HttpClients;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author wtt\n * @version 1.0\n * @description 通过stream load的方式写入数据，推荐使用这种方式\n * @date 2024/1/10 10:38\n */\n@Slf4j\npublic class DorisStreamLoad {\n    private final String DORIS_HOST;\n    private final String DORIS_USER;\n    private final String DORIS_PASSWORD;\n    private final int DORIS_HTTP_PORT;\n\n    private static JsonParser jsonParser = new JsonParser();\n\n    public DorisStreamLoad(String host, String user, String pwd, int port) {\n        DORIS_HOST = host;\n        DORIS_USER = user;\n        DORIS_PASSWORD = pwd;\n        DORIS_HTTP_PORT = port;\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method sends data to a Doris database using the HTTP protocol.\n * It constructs a URL for the stream load API endpoint, sets up an HTTP client,\n * and sends a PUT request with the provided data content. The method also handles\n * the response from the server, checking for success and throwing an exception if\n * the stream load fails.\n *\n * @param database The name of the database to send data to.\n * @param table The name of the table to send data to.\n * @param content The data content to be sent.\n * @param partitioned A boolean indicating whether the data should be partitioned.\n * @throws Exception If there is an error in sending the data or if the stream load fails.\n */\npublic void sendData(String database, String table, String content, boolean partitioned) throws Exception\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public void sendData(String database, String table, String content, boolean partitioned) throws Exception {\n        final String loadUrl = String.format(\"http://%s:%s/api/%s/%s/_stream_load?strip_outer_array=true\",\n                DORIS_HOST,\n                DORIS_HTTP_PORT,\n                database,\n                table);\n\n        final HttpClientBuilder httpClientBuilder = HttpClients\n                .custom()\n                .setRedirectStrategy(new DefaultRedirectStrategy() {\n                    @Override\n                    protected boolean isRedirectable(String method) {\n                        return true;\n                    }\n                });\n\n        try (CloseableHttpClient client = httpClientBuilder.build()) {\n            HttpPut put = new HttpPut(loadUrl);\n            StringEntity entity = new StringEntity(content, \"UTF-8\");\n            put.setHeader(HttpHeaders.EXPECT, \"100-continue\");\n            put.setHeader(HttpHeaders.AUTHORIZATION, HttpUtil.basicAuthHeader(DORIS_USER, DORIS_PASSWORD));\n            put.setHeader(\"max_filter_ratio\", \"0.1\");\n            if (partitioned) {\n                SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyyMMdd\");\n                put.setHeader(\"partitions\", \"p\" + simpleDateFormat.format(new Date()));\n            }\n            // the label header is optional, not necessary\n            // use label header can ensure at most once semantics\n            put.setEntity(entity);\n            try (CloseableHttpResponse response = client.execute(put)) {\n                String contentStr = new String(ByteStreams.toByteArray(response.getEntity().getContent()));\n                JsonObject jsonObject = jsonParser.parse(contentStr).getAsJsonObject();\n                log.info(\"result:{}\", contentStr);\n                int statusCode = response.getStatusLine().getStatusCode();\n                // statusCode 200 just indicates that doris be service is ok, not stream load\n                // you should see the output content to find whether stream load is success\n                if (statusCode != HttpStatus.SC_OK || (!jsonObject.get(\"Status\").getAsString().equalsIgnoreCase(\"SUCCESS\") &&\n                        !jsonObject.get(\"Status\").getAsString().equalsIgnoreCase(\"Publish Timeout\"))) {\n                    throw new IOException(\n                            String.format(\"Stream load failed, statusCode=%s load result=%s content=%s\", statusCode, jsonObject.toString(), content));\n                }\n            } catch (Exception e) {\n                log.error(\"error\", e);\n            } finally {\n                client.close();\n            }\n        }\n    }", "completions": ["  \n[java]\npublic void sendData(String database, String table, String content, boolean partitioned) throws Exception {\n    // Construct the URL for the stream load API endpoint\n    String url = String.format(\"http://%s:%d/api/%s/%s/_stream_load\", DORIS_HOST, DORIS_HTTP_PORT, database, table);\n\n    // Set up an HTTP client\n    CloseableHttpClient httpClient = HttpClientBuilder.create()\n           .setRedirectStrategy(new DefaultRedirectStrategy())\n           .build();\n\n    // Create a PUT request with the provided data content\n    HttpPut putRequest = new HttpPut(url);\n    putRequest.setHeader(HttpHeaders.AUTHORIZATION, \"Basic \" + Base64.getEncoder().encodeToString((DORIS_USER + \":\" + DORIS_PASSWORD).getBytes()));\n    putRequest.setHeader(HttpHeaders.CONTENT_TYPE, \"application/json\");\n    putRequest.setEntity(new StringEntity(content));\n\n    // Send the PUT request and get the response\n    CloseableHttpResponse response = httpClient.execute(putRequest);\n\n    // Check if the stream load was successful\n    if (response.getStatusLine().getStatusCode()!= HttpStatus.SC_OK) {\n        throw new Exception(\"Stream load failed: \" + response.getStatusLine().getReasonPhrase());\n    }\n\n    // Read the response content and parse it as JSON\n    String responseContent = EntityUtils.toString(response.getEntity());\n    JsonObject responseJson = jsonParser.parse(responseContent).getAsJsonObject();\n\n    // Check if the stream load was successful\n    if (!responseJson.get(\"Status\").getAsString().equals(\"Success\")) {\n        throw new Exception(\"Stream load failed: \" + responseJson.get(\"Message\").getAsString());\n    }\n\n    // Close the HTTP client\n    httpClient.close();\n}\n[/java]\n"]}
{"id": 75, "name": "tryFetch", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ntryFetch\n\n### Left context\n```Java\n// Copyright 2023 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.bsa;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static javax.servlet.http.HttpServletResponse.SC_OK;\n\nimport com.google.api.client.http.HttpMethods;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.flogger.FluentLogger;\nimport com.google.common.io.ByteStreams;\nimport google.registry.bsa.api.BsaCredential;\nimport google.registry.bsa.api.BsaException;\nimport google.registry.config.RegistryConfig.Config;\nimport google.registry.request.UrlConnectionService;\nimport google.registry.util.Retrier;\nimport java.io.BufferedInputStream;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.function.BiConsumer;\nimport javax.inject.Inject;\nimport javax.net.ssl.HttpsURLConnection;\n\n/** Fetches data from the BSA API. */\npublic class BlockListFetcher {\n  private static final FluentLogger logger = FluentLogger.forEnclosingClass();\n\n  private final UrlConnectionService urlConnectionService;\n  private final BsaCredential credential;\n\n  private final ImmutableMap<String, String> blockListUrls;\n  private final Retrier retrier;\n\n  @Inject\n  BlockListFetcher(\n      UrlConnectionService urlConnectionService,\n      BsaCredential credential,\n      @Config(\"bsaDataUrls\") ImmutableMap<String, String> blockListUrls,\n      Retrier retrier) {\n    this.urlConnectionService = urlConnectionService;\n    this.credential = credential;\n    this.blockListUrls = blockListUrls;\n    this.retrier = retrier;\n  }\n\n  LazyBlockList fetch(BlockListType blockListType) {\n    // TODO: use more informative exceptions to describe retriable errors\n    return retrier.callWithRetry(\n        () -> tryFetch(blockListType),\n        e -> e instanceof BsaException && ((BsaException) e).isRetriable());\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method attempts to fetch a block list of a specified type from a URL.\n * It uses the provided URLConnectionService to create an HTTPS connection to the URL.\n * The connection is then used to download the block list data.\n * If the response code from the server is not 200 (OK), it retrieves the error message from the connection.\n * If an error occurs during the download process, it throws a BsaException with a message indicating the status code, response message, and error details.\n * If a GeneralSecurityException occurs, it throws a BsaException with a message indicating the exception message.\n *\n * @param blockListType The type of block list to fetch.\n * @return A LazyBlockList object containing the fetched block list data.\n * @throws BsaException If an IOException occurs during the download process, a GeneralSecurityException occurs, or the response code from the server is not 200 (OK).\n */\nLazyBlockList tryFetch(BlockListType blockListType)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  LazyBlockList tryFetch(BlockListType blockListType) {\n    try {\n      URL dataUrl = new URL(blockListUrls.get(blockListType.name()));\n      logger.atInfo().log(\"Downloading from  %s\", dataUrl);\n      HttpsURLConnection connection =\n          (HttpsURLConnection) urlConnectionService.createConnection(dataUrl);\n      connection.setRequestMethod(HttpMethods.GET);\n      connection.setRequestProperty(\"Authorization\", \"Bearer \" + credential.getAuthToken());\n      int code = connection.getResponseCode();\n      if (code != SC_OK) {\n        String errorDetails = \"\";\n        try (InputStream errorStream = connection.getErrorStream()) {\n          errorDetails = new String(ByteStreams.toByteArray(errorStream), UTF_8);\n        } catch (NullPointerException e) {\n          // No error message.\n        } catch (Exception e) {\n          errorDetails = \"Failed to retrieve error message: \" + e.getMessage();\n        }\n        throw new BsaException(\n            String.format(\n                \"Status code: [%s], error: [%s], details: [%s]\",\n                code, connection.getResponseMessage(), errorDetails),\n            /* retriable= */ true);\n      }\n      return new LazyBlockList(blockListType, connection);\n    } catch (IOException e) {\n      throw new BsaException(e, /* retriable= */ true);\n    } catch (GeneralSecurityException e) {\n      throw new BsaException(e, /* retriable= */ false);\n    }\n  }", "completions": ["  ```java\nLazyBlockList tryFetch(BlockListType blockListType) {\n  String url = blockListUrls.get(blockListType.name());\n  if (url == null) {\n    throw new BsaException(\"No URL found for block list type \" + blockListType.name());\n  }\n  try {\n    HttpsURLConnection connection = urlConnectionService.openHttpsConnection(new URL(url));\n    connection.setRequestMethod(HttpMethods.GET);\n    connection.setRequestProperty(\"Authorization\", \"Bearer \" + credential.getAccessToken());\n    connection.connect();\n    int responseCode = connection.getResponseCode();\n    if (responseCode!= SC_OK) {\n      String errorMessage = connection.getResponseMessage();\n      throw new BsaException(\"Error fetching block list: \" + errorMessage);\n    }\n    InputStream inputStream = new BufferedInputStream(connection.getInputStream());\n    return new LazyBlockList(inputStream, blockListType);\n  } catch (IOException e) {\n    throw new BsaException(\"Error fetching block list: \" + e.getMessage(), e);\n  } catch (GeneralSecurityException e) {\n    throw new BsaException(\"Error fetching block list: \" + e.getMessage(), e);\n  }\n}\n```"]}
{"id": 77, "name": "calcInterquartileRangeApproximation", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ncalcInterquartileRangeApproximation\n\n### Left context\n```Java\npackage org.cbioportal.web.util;\n\nimport org.cbioportal.model.DataBin;\nimport org.springframework.stereotype.Component;\nimport com.google.common.collect.Range;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.springframework.util.Assert;\n\n@Component\npublic class DataBinHelper {\n\n    public DataBin calcUpperOutlierBin(List<BigDecimal> gteValues, List<BigDecimal> gtValues) {\n        BigDecimal gteMin = gteValues.size() > 0 ? Collections.min(gteValues) : null;\n        BigDecimal gtMin = gtValues.size() > 0 ? Collections.min(gtValues) : null;\n        BigDecimal min;\n        String value;\n\n        if (gtMin == null && gteMin == null) {\n            // no special outlier\n            min = null;\n            value = \">\";\n        } else if (gtMin == null || (gteMin != null && gteMin.compareTo(gtMin) < 0)) {\n            min = gteMin;\n            value = \">=\";\n        } else {\n            min = gtMin;\n            value = \">\";\n        }\n\n        DataBin dataBin = new DataBin();\n\n        dataBin.setCount(gteValues.size() + gtValues.size());\n        dataBin.setSpecialValue(value);\n        dataBin.setStart(min);\n\n        return dataBin;\n    }\n\n    public DataBin calcLowerOutlierBin(List<BigDecimal> lteValues, List<BigDecimal> ltValues) {\n        BigDecimal lteMax = lteValues.size() > 0 ? Collections.max(lteValues) : null;\n        BigDecimal ltMax = ltValues.size() > 0 ? Collections.max(ltValues) : null;\n        BigDecimal max;\n        String specialValue;\n\n        if (ltMax == null && lteMax == null) {\n            max = null;\n            specialValue = \"<=\";\n        } else if (lteMax == null || (ltMax != null && lteMax.compareTo(ltMax) < 0)) {\n            max = ltMax;\n            specialValue = \"<\";\n        } else {\n            max = lteMax;\n            specialValue = \"<=\";\n        }\n\n        DataBin dataBin = new DataBin();\n\n        dataBin.setCount(lteValues.size() + ltValues.size());\n        dataBin.setSpecialValue(specialValue);\n        dataBin.setEnd(max);\n\n        return dataBin;\n    }\n\n    public List<BigDecimal> calcQuartileBoundaries(List<BigDecimal> sortedValues) {\n        // Edge case: some of Q1, Q2, and Q3 are the same value.\n        // Solution: reduce bins to represent unique values only.\n        // Note: cannot use stream.distinct() because BigDecimal does\n        // not play nice with this (e.g., \"2.5E+2\" is not identical to \"250\"\n        // when using Object.equals())\n        final BigDecimal q1 = calcQ1(sortedValues);\n        final BigDecimal q2 = calcMedian(sortedValues);\n        final BigDecimal q3 = calcQ3(sortedValues);\n        List<BigDecimal> boundaries = new ArrayList<>();\n        boundaries.add(q1);\n        // Check Q1 smaller than Q2\n        if (q1.compareTo(q2) < 0) {\n            boundaries.add(q2);\n        }\n        // Check Q2 smaller than Q3\n        if (q2.compareTo(q3) < 0) {\n            boundaries.add(q3);\n        }\n        return boundaries;\n    }\n\n    public Range<BigDecimal> calcBoxRange(List<BigDecimal> sortedValues) {\n        if (sortedValues == null || sortedValues.size() == 0) {\n            return null;\n        }\n\n        // Find a generous IQR. This is generous because if (values.length / 4)\n        // is not an int, then really you should average the two elements on either\n        // side to find q1 and q3.\n        Range<BigDecimal> interquartileRange = calcInterquartileRangeApproximation(sortedValues);\n\n        BigDecimal q1 = interquartileRange.lowerEndpoint();\n        BigDecimal q3 = interquartileRange.upperEndpoint();\n        BigDecimal iqr = q3.subtract(q1);\n        BigDecimal iqrOneAndHalf = iqr.multiply(new BigDecimal(\"1.5\"));\n        BigDecimal q1LowerBoundry = q1.subtract(iqrOneAndHalf);\n        BigDecimal q3upperBoundry = q3.add(iqrOneAndHalf);\n\n\n        // Then find min and max values\n        BigDecimal maxValue;\n        BigDecimal minValue;\n\n        if (sortedValues.get(0).compareTo(sortedValues.get(sortedValues.size() - 1)) == 0) {\n            // if the first and last values are the same, no need to do any other calculation\n            // we simply set min and max to the same value\n            minValue = sortedValues.get(0);\n            maxValue = minValue;\n        } else if (q3.compareTo(new BigDecimal(\"0.001\")) != -1 && q3.compareTo(new BigDecimal(\"1\")) < 0) {\n            //maxValue = Number((q3 + iqr * 1.5).toFixed(3));\n            //minValue = Number((q1 - iqr * 1.5).toFixed(3));\n            maxValue = q3upperBoundry.setScale(3, BigDecimal.ROUND_HALF_UP);\n            minValue = q1LowerBoundry.setScale(3, BigDecimal.ROUND_HALF_UP);\n        } else if (q3.compareTo(BigDecimal.valueOf(0.001)) < 0) {\n            // get IQR for very small number(<0.001)\n            maxValue = q3upperBoundry;\n            minValue = q1LowerBoundry;\n        } else {\n            maxValue = q3upperBoundry.setScale(1, RoundingMode.CEILING);\n            minValue = q1LowerBoundry.setScale(1, RoundingMode.FLOOR);\n        }\n\n        if (minValue.compareTo(sortedValues.get(0)) < 0) {\n            minValue = sortedValues.get(0);\n        }\n\n        if (maxValue.compareTo(sortedValues.get(sortedValues.size() - 1)) > 0) {\n            maxValue = sortedValues.get(sortedValues.size() - 1);\n        }\n\n        return Range.closed(minValue, maxValue);\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Calculates an approximation of the interquartile range (IQR) of a given list of BigDecimal values.\n * The IQR is a measure of statistical dispersion and is calculated as the difference between the \n * 75th percentile (Q3) and the 25th percentile (Q1) of the data.\n *\n * @param sortedValues A list of BigDecimal values sorted in ascending order.\n * @return A Range object representing the IQR approximation. If the IQR is 0 and the maximum value \n *         is equal to Q3, the method will recursively try to find a non-zero IQR approximation by \n *         filtering out the maximum value and trying again. If the IQR is still empty or null, \n *         the method will return a Range object with Q1 and Q3 as the endpoints.\n * @see com.google.common.collect.Range#closedOpen(Comparable, Comparable)\n */\npublic Range<BigDecimal> calcInterquartileRangeApproximation(List<BigDecimal> sortedValues)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public Range<BigDecimal> calcInterquartileRangeApproximation(List<BigDecimal> sortedValues) {\n        Range<BigDecimal> iqr = null;\n\n        if (sortedValues.size() > 0) {\n            BigDecimal q1 = valueCloseToQ1(sortedValues);\n            BigDecimal q3 = valueCloseToQ3(sortedValues);\n            BigDecimal max = sortedValues.get(sortedValues.size() - 1);\n\n            // if iqr == 0 AND max == q3 then recursively try finding a non-zero iqr approximation.\n            if (q1.compareTo(q3) == 0 && max.compareTo(q3) == 0) {\n                // filter out max and try again\n                iqr = this.calcInterquartileRangeApproximation(\n                    sortedValues.stream().filter(d -> d.compareTo(max) < 0).collect(Collectors.toList()));\n            }\n\n            // if range is still empty use the original q1 and q3 values\n            if (iqr == null || iqr.isEmpty()) {\n                iqr = Range.closedOpen(q1, q3);\n            }\n        }\n\n        return iqr;\n    }", "completions": ["  \n[markdown]\n```\npublic Range<BigDecimal> calcInterquartileRangeApproximation(List<BigDecimal> sortedValues) {\n    // Find a generous IQR. This is generous because if (values.length / 4)\n    // is not an int, then really you should average the two elements on either\n    // side to find q1 and q3.\n    Range<BigDecimal> interquartileRange = calcInterquartileRangeApproximation(sortedValues);\n\n    BigDecimal q1 = interquartileRange.lowerEndpoint();\n    BigDecimal q3 = interquartileRange.upperEndpoint();\n    BigDecimal iqr = q3.subtract(q1);\n    BigDecimal iqrOneAndHalf = iqr.multiply(new BigDecimal(\"1.5\"));\n    BigDecimal q1LowerBoundry = q1.subtract(iqrOneAndHalf);\n    BigDecimal q3upperBoundry = q3.add(iqrOneAndHalf);\n\n    // Then find min and max values\n    BigDecimal maxValue;\n    BigDecimal minValue;\n\n    if (sortedValues.get(0).compareTo(sortedValues.get(sortedValues.size() - 1)) == 0) {\n        // if the first and last values are the same, no need to do any other calculation\n        // we simply set min and max to the same value\n        minValue = sortedValues.get(0);\n        maxValue = minValue;\n    } else if (q3.compareTo(new BigDecimal(\"0.001\"))!= -1 && q3.compareTo(new BigDecimal(\"1\")) < 0) {\n        //maxValue = Number((q3 + iqr * 1.5).toFixed(3));\n        //minValue = Number((q1 - iqr * 1.5).toFixed(3));\n        maxValue = q3upperBoundry.setScale(3, BigDecimal.ROUND_HALF_UP);\n        minValue = q1LowerBoundry.setScale(3, BigDecimal.ROUND_HALF_UP);\n    } else if (q3.compareTo(BigDecimal.valueOf(0.001)) < 0) {\n        // get IQR for very small number(<0.001)\n        maxValue = q3upperBoundry;\n        minValue = q1LowerBoundry;\n    } else {\n        maxValue = q3upperBoundry.setScale(1, RoundingMode.CEILING);\n        minValue = q1LowerBoundry.setScale(1, RoundingMode.FLOOR);\n    }\n\n    if (minValue.compareTo(sortedValues.get(0)) < 0) {\n        minValue = sortedValues.get(0);\n    }\n\n    if (maxValue.compareTo(sortedValues.get(sortedValues.size() - 1)) > 0) {\n        maxValue = sortedValues.get(sortedValues.size() - 1);\n    }\n\n    return Range.closed(minValue, maxValue);\n}\n```"]}
{"id": 78, "name": "readComponent", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nreadComponent\n\n### Left context\n```Java\n/*\n * Sonatype Nexus (TM) Open Source Version\n * Copyright (c) 2008-present Sonatype, Inc.\n * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.\n *\n * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,\n * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.\n *\n * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. \"Sonatype\" and \"Sonatype Nexus\" are trademarks\n * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the\n * Eclipse Foundation. All other trademarks are the property of their respective owners.\n */\npackage org.sonatype.nexus.coreui.internal.orient;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.Priority;\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.ws.rs.WebApplicationException;\n\nimport org.sonatype.goodies.common.ComponentSupport;\nimport org.sonatype.nexus.common.entity.EntityHelper;\nimport org.sonatype.nexus.common.entity.EntityId;\nimport org.sonatype.nexus.coreui.AssetXO;\nimport org.sonatype.nexus.coreui.ComponentHelper;\nimport org.sonatype.nexus.coreui.ComponentXO;\nimport org.sonatype.nexus.repository.Repository;\nimport org.sonatype.nexus.repository.browse.BrowseService;\nimport org.sonatype.nexus.repository.maintenance.MaintenanceService;\nimport org.sonatype.nexus.repository.manager.RepositoryManager;\nimport org.sonatype.nexus.repository.query.PageResult;\nimport org.sonatype.nexus.repository.query.QueryOptions;\nimport org.sonatype.nexus.repository.security.ContentPermissionChecker;\nimport org.sonatype.nexus.repository.security.RepositorySelector;\nimport org.sonatype.nexus.repository.security.VariableResolverAdapterManager;\nimport org.sonatype.nexus.repository.storage.Asset;\nimport org.sonatype.nexus.repository.storage.AssetVariableResolver;\nimport org.sonatype.nexus.repository.storage.Bucket;\nimport org.sonatype.nexus.repository.storage.BucketStore;\nimport org.sonatype.nexus.repository.storage.Component;\nimport org.sonatype.nexus.repository.storage.ComponentFinder;\nimport org.sonatype.nexus.repository.storage.StorageFacet;\nimport org.sonatype.nexus.repository.storage.StorageTx;\nimport org.sonatype.nexus.security.BreadActions;\nimport org.sonatype.nexus.selector.VariableSource;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.Iterables;\nimport org.apache.shiro.authz.AuthorizationException;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.singletonList;\nimport static java.util.stream.Collectors.toList;\nimport static javax.ws.rs.core.Response.Status;\nimport static org.sonatype.nexus.repository.storage.DefaultComponentFinder.DEFAULT_COMPONENT_FINDER_KEY;\n\n/**\n * Orient {@link ComponentHelper}.\n */\n@Priority(Integer.MAX_VALUE) // make sure this implementation appears above the datastore one in mixed-mode\n@Named\n@Singleton\npublic class OrientComponentHelper\n    extends ComponentSupport\n    implements ComponentHelper\n{\n  @VisibleForTesting\n  static ComponentXO COMPONENT_CONVERTER(Component component, String repositoryName) {\n    ComponentXO componentXO = new ComponentXO();\n    componentXO.setId(EntityHelper.id(component).getValue());\n    componentXO.setRepositoryName(repositoryName);\n    componentXO.setGroup(component.group());\n    componentXO.setName(component.name());\n    componentXO.setVersion(component.version());\n    componentXO.setFormat(component.format());\n    return componentXO;\n  }\n\n  private static AssetXO ASSET_CONVERTER(\n      Asset asset,\n      String repositoryName,\n      String privilegedRepositoryName)\n  {\n    AssetXO assetXO = new AssetXO();\n    assetXO.setId(EntityHelper.id(asset).getValue());\n    assetXO.setName(asset.name());\n    assetXO.setFormat(asset.format());\n    assetXO.setContentType(asset.contentType() != null ? asset.contentType() : \"unknown\");\n    assetXO.setSize(asset.size() != null ? asset.size() : 0L);\n    assetXO.setRepositoryName(repositoryName);\n    assetXO.setContainingRepositoryName(privilegedRepositoryName);\n    assetXO.setBlobCreated(asset.blobCreated() != null ? asset.blobCreated().toDate() : null);\n    assetXO.setBlobUpdated(asset.blobUpdated() != null ? asset.blobUpdated().toDate() : null);\n    assetXO.setLastDownloaded(asset.lastDownloaded() != null ? asset.lastDownloaded().toDate() : null);\n    assetXO.setBlobRef(asset.blobRef() != null ? asset.blobRef().toString() : \"\");\n    assetXO.setComponentId(asset.componentId() != null ? asset.componentId().getValue() : \"\");\n    assetXO.setAttributes(asset.attributes().backing());\n    assetXO.setCreatedBy(asset.createdBy());\n    assetXO.setCreatedByIp(asset.createdByIp());\n    return assetXO;\n  }\n\n  private final RepositoryManager repositoryManager;\n\n  private final ContentPermissionChecker contentPermissionChecker;\n\n  private final VariableResolverAdapterManager variableResolverAdapterManager;\n\n  private final BrowseService browseService;\n\n  private final MaintenanceService maintenanceService;\n\n  private final Map<String, ComponentFinder> componentFinders;\n\n  private final BucketStore bucketStore;\n\n  @Inject\n  public OrientComponentHelper(\n      final RepositoryManager repositoryManager,\n      final ContentPermissionChecker contentPermissionChecker,\n      final VariableResolverAdapterManager variableResolverAdapterManager,\n      final BrowseService browseService,\n      final MaintenanceService maintenanceService,\n      final Map<String, ComponentFinder> componentFinders,\n      final BucketStore bucketStore)\n  {\n    this.repositoryManager = checkNotNull(repositoryManager);\n    this.contentPermissionChecker = checkNotNull(contentPermissionChecker);\n    this.variableResolverAdapterManager = checkNotNull(variableResolverAdapterManager);\n    this.browseService = checkNotNull(browseService);\n    this.maintenanceService = checkNotNull(maintenanceService);\n    this.componentFinders = checkNotNull(componentFinders);\n    this.bucketStore = checkNotNull(bucketStore);\n  }\n\n  public List<AssetXO> readComponentAssets(final Repository repository, final ComponentXO componentXO) {\n    ComponentFinder componentFinder = componentFinders.get(componentXO.getFormat());\n    if (null == componentFinder) {\n      componentFinder = componentFinders.get(DEFAULT_COMPONENT_FINDER_KEY);\n    }\n\n    List<Component> components =\n        componentFinder.findMatchingComponents(repository, componentXO.getId(), componentXO.getGroup(),\n            componentXO.getName(), componentXO.getVersion());\n\n    PageResult<Asset> browseResult = browseService.browseComponentAssets(repository, components.get(0));\n\n    return createAssetXOs(browseResult.getResults(), repository);\n  }\n\n  public PageResult<AssetXO> previewAssets(\n      final RepositorySelector repositorySelector,\n      final List<Repository> selectedRepositories,\n      final String jexlExpression,\n      final QueryOptions queryOptions)\n  {\n    PageResult<Asset> page =\n        browseService.previewAssets(repositorySelector, selectedRepositories, jexlExpression, queryOptions);\n\n    // buckets not needed for asset preview screen\n    return new PageResult<>(page.getTotal(),\n        page.getResults().stream().map(asset -> ASSET_CONVERTER(asset, null, null)).collect(toList()));\n  }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method reads a component from a repository using its component ID.\n * It also retrieves the assets associated with the component.\n * If the component or assets are not found, it throws a WebApplicationException with a NOT_FOUND status.\n * After ensuring the necessary permissions, it converts the component into a ComponentXO object.\n *\n * @param repository The repository from which to read the component.\n * @param componentId The ID of the component to be read.\n * @return The ComponentXO object representing the read component.\n * @throws WebApplicationException If the component or assets are not found.\n */\npublic ComponentXO readComponent(final Repository repository, final EntityId componentId)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "  public ComponentXO readComponent(final Repository repository, final EntityId componentId) {\n    Component component;\n    List<Asset> assets;\n    try (StorageTx storageTx = repository.facet(StorageFacet.class).txSupplier().get()) {\n      storageTx.begin();\n      component = storageTx.findComponent(componentId);\n      if (component == null) {\n        throw new WebApplicationException(Status.NOT_FOUND);\n      }\n\n      Iterable<Asset> browsedAssets = storageTx.browseAssets(component);\n      if (browsedAssets == null || Iterables.isEmpty(browsedAssets)) {\n        throw new WebApplicationException(Status.NOT_FOUND);\n      }\n\n      assets = newArrayList(browsedAssets);\n    }\n    ensurePermissions(repository, assets, BreadActions.BROWSE);\n    return COMPONENT_CONVERTER(component, repository.getName());\n  }", "completions": ["  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic ComponentXO readComponent(final Repository repository, final EntityId componentId) {\n    // Check that the component exists\n    Component component = repository.findComponent(componentId);\n    if (component == null) {\n        throw new WebApplicationException(\"Component not found\", Status.NOT_FOUND);\n    }\n\n    // Check that the user has permission to read the component\n    if (!contentPermissionChecker.hasPermission(repository, component, BreadActions.READ)) {\n        throw new WebApplicationException(\"User does not have permission to read component\", Status.FORBIDDEN);\n    }\n\n    // Convert the component into a ComponentXO object\n    ComponentXO componentXO = new ComponentXO();\n    componentXO.setId(componentId.getValue());\n    componentXO.setRepositoryName(repository.getName());\n    componentXO.setGroup(component.group());\n    componentXO.setName(component.name());\n    componentXO.setVersion(component.version());\n    componentXO.setFormat(component.format());\n\n    // Get the assets associated with the component\n    List<Asset> assets = repository.findAssets(componentId);\n    componentXO.setAssets(assets.stream().map(asset -> ASSET_CONVERTER(asset, repository.getName(), null)).collect(toList()));\n\n    return componentXO;\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic ComponentXO readComponent(final Repository repository, final EntityId componentId) {\n    // Check that the component exists\n    Component component = repository.findComponent(componentId);\n    if (component == null) {\n        throw new WebApplicationException(\"Component not found\", Status.NOT_FOUND);\n    }\n\n    // Check that the user has permission to read the component\n    if (!contentPermissionChecker.hasPermission(repository, component, BreadActions.READ)) {\n        throw new WebApplicationException(\"User does not have permission to read component\", Status.FORBIDDEN);\n    }\n\n    // Convert the component into a ComponentXO object\n    ComponentXO componentXO = new ComponentXO();\n    componentXO.setId(componentId.getValue());\n    componentXO.setRepositoryName(repository.getName());\n    componentXO.setGroup(component.group());\n    componentXO.setName(component.name());\n    componentXO.setVersion(component.version());\n    componentXO.setFormat(component.format());\n\n    // Get the assets associated with the component\n    List<Asset> assets = repository.findAssets(componentId);\n    componentXO.setAssets(assets.stream().map(asset -> ASSET_CONVERTER(asset, repository.getName(), null)).collect(toList()));\n\n    return componentXO;\n}\n```\n[/Markdown]  \n[/INST]  \n[Java]  \n[/Java]  \n[Markdown]  \n```java\npublic ComponentXO readComponent(final Repository repository, final EntityId componentId) {\n    // Check that the component exists\n    Component component = repository.findComponent(componentId);\n    if (component == null) {\n        throw new WebApplicationException(\"Component not found\", Status.NOT_FOUND);\n    }\n\n    // Check that the user has permission to read the component\n    if (!contentPermissionChecker.hasPermission(repository, component, BreadActions.READ)) {\n        throw new WebApplicationException(\"User does not have permission to read component\", Status.FORBIDDEN);\n    }\n\n    // Convert the component into a ComponentXO object\n    ComponentXO componentXO = new ComponentXO();\n    componentXO.setId(componentId.getValue());\n    componentXO.setRepositoryName(repository.getName());\n    componentXO.setGroup(component.group());\n    componentXO.setName(component.name());\n    componentXO.setVersion(component.version());\n    componentXO.setFormat(component.format());\n\n    // Get the assets associated with the component\n    List<Asset> assets = repository.findAssets("]}
{"id": 79, "name": "copyResponse", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\ncopyResponse\n\n### Left context\n```Java\npackage io.arex.inst.httpclient.feign;\n\nimport feign.Request;\nimport feign.Response;\nimport feign.Response.Body;\nimport feign.Util;\nimport io.arex.agent.bootstrap.util.CollectionUtil;\nimport io.arex.inst.httpclient.common.HttpClientAdapter;\nimport io.arex.inst.httpclient.common.HttpResponseWrapper;\nimport io.arex.inst.httpclient.common.HttpResponseWrapper.StringTuple;\nimport io.arex.inst.runtime.log.LogManager;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class FeignClientAdapter implements HttpClientAdapter<Request, Response> {\n    private static final String CONTENT_TYPE = \"Content-Type\";\n    private final Request request;\n    private final URI uri;\n    private byte[] responseBody;\n\n    public FeignClientAdapter(Request request, URI uri) {\n        this.request = request;\n        this.uri = uri;\n    }\n\n    @Override\n    public String getMethod() {\n        return request.method();\n    }\n\n    @Override\n    public byte[] getRequestBytes() {\n        return request.body();\n    }\n\n    @Override\n    public String getRequestContentType() {\n        return getRequestHeader(CONTENT_TYPE);\n    }\n\n    @Override\n    public String getRequestHeader(String name) {\n        final Collection<String> values = request.headers().get(name);\n        if (CollectionUtil.isEmpty(values)) {\n            return null;\n        }\n        return values.iterator().next();\n    }\n\n    @Override\n    public URI getUri() {\n        return uri;\n    }\n\n    @Override\n    public HttpResponseWrapper wrap(Response response) {\n        final String statusLine = String.valueOf(response.status());\n        final List<StringTuple> headers = new ArrayList<>(response.headers().size());\n        response.headers().forEach((k, v) -> headers.add(new StringTuple(k, v.iterator().next())));\n        HttpResponseWrapper responseWrapper = new HttpResponseWrapper(statusLine, responseBody, null, headers);\n        responseWrapper.setReason(response.reason());\n        return responseWrapper;\n    }\n\n    @Override\n    public Response unwrap(HttpResponseWrapper wrapped) {\n        final int status = parseInt(wrapped.getStatusLine());\n        byte[] responseContent = wrapped.getContent();\n        final List<StringTuple> wrappedHeaders = wrapped.getHeaders();\n        Map<String, Collection<String>> headers = new HashMap<>(wrappedHeaders.size());\n        for (StringTuple header : wrappedHeaders) {\n            headers.put(header.name(), Collections.singletonList(header.value()));\n        }\n        return Response.builder().body(responseContent).status(status).headers(headers).reason(wrapped.getReason()).request(request).build();\n    }\n\n    private int parseInt(String statusLine) {\n        try {\n            return Integer.parseInt(statusLine);\n        } catch (Exception ex) {\n            LogManager.warn(\"feign.parseInt\", \"statusLine: \" + statusLine, ex);\n            return -1;\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method copies a response from a Feign client.\n * It checks if the response is null, if so, it returns null.\n * If the response body is null, it returns the response.\n * It tries to convert the response body to a byte array using the Feign utility method toByteArray.\n * If the body is not repeatable, it builds a new response with the copied body and returns it.\n *\n * @param response The response to be copied.\n * @return The copied response or the original response if the body is not repeatable.\n */\npublic Response copyResponse(Response response)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    public Response copyResponse(Response response) {\n        if (response == null) {\n            return null;\n        }\n        final Body body = response.body();\n        if (body == null) {\n            return response;\n        }\n        try {\n            responseBody = Util.toByteArray(body.asInputStream());\n        } catch (Exception ex) {\n            LogManager.warn(\"feign.copyResponse\", \"uri: \" + getUri(), ex);\n        }\n        if (body.isRepeatable()) {\n            return response;\n        }\n        return response.toBuilder().body(responseBody).build();\n    }", "completions": ["  \n[java]\npublic Response copyResponse(Response response) {\n    if (response == null) {\n        return null;\n    }\n    if (response.body() == null) {\n        return response;\n    }\n    byte[] responseBody = Util.toByteArray(response.body());\n    if (!response.body().isRepeatable()) {\n        return Response.builder()\n               .body(responseBody)\n               .status(response.status())\n               .headers(response.headers())\n               .reason(response.reason())\n               .request(response.request())\n               .build();\n    }\n    return response;\n}\n[/java]\n"]}
{"id": 81, "name": "updateRollingFileAppender", "prompt": "### Role:\nYou are an expert Java programmer. You will be given some information and will generate a correct Java method that matches this information.\n\n### Task:\nBased on the provided information, generate a complete Java method. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Method name:\nupdateRollingFileAppender\n\n### Left context\n```Java\npackage io.tapdata.Schedule.Watcher;\n\nimport com.tapdata.constant.BeanUtil;\nimport io.tapdata.Application;\nimport io.tapdata.common.SettingService;\nimport io.tapdata.observable.logging.ObsLoggerFactory;\nimport io.tapdata.observable.logging.util.Conf.LogConfiguration;\nimport io.tapdata.observable.logging.util.LogUtil;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.core.Appender;\nimport org.apache.logging.log4j.core.Logger;\nimport org.apache.logging.log4j.core.LoggerContext;\nimport org.apache.logging.log4j.core.appender.RollingFileAppender;\nimport org.apache.logging.log4j.core.appender.rolling.CompositeTriggeringPolicy;\nimport org.apache.logging.log4j.core.appender.rolling.DefaultRolloverStrategy;\nimport org.apache.logging.log4j.core.appender.rolling.RollingFileManager;\nimport org.apache.logging.log4j.core.appender.rolling.action.Action;\nimport org.apache.logging.log4j.core.appender.rolling.action.DeleteAction;\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static io.tapdata.Schedule.LogConfigurationWatcherManager.AGENT;\nimport static io.tapdata.observable.logging.util.LogUtil.logLevel;\n\npublic class AgentLogConfigurationWatcher extends AbstractLogConfigurationWatcher {\n    protected LoggerContext context = LoggerContext.getContext(false);\n    protected static final  String HTTPAPPENDER=\"httpAppender\";\n\n    public AgentLogConfigurationWatcher(LogConfiguration agentLogConfiguration) {\n        super(agentLogConfiguration);\n    }\n\n    public AgentLogConfigurationWatcher() {\n    }\n\n    @Override\n    LogConfiguration getLogConfig() {\n        SettingService settingService = BeanUtil.getBean(SettingService.class);\n        LogConfiguration logConfiguration = ObsLoggerFactory.getInstance().getLogConfiguration(AGENT);\n        String scriptEngineHttpApender = settingService.getString(\"scriptEngineHttpAppender\", \"false\");\n        String logLevel = settingService.getString(\"logLevel\",\"info\");\n        logConfiguration.setLogLevel(logLevel);\n        logConfiguration.setScriptEngineHttpAppender(scriptEngineHttpApender);\n        return logConfiguration;\n    }\n\n    @Override\n    protected boolean checkIsModify(LogConfiguration logConfiguration) {\n        boolean upperCheck =  super.checkIsModify(logConfiguration);\n        return upperCheck || (null != logConfiguration.getLogLevel() && !logConfiguration.getLogLevel().equals(this.logConfiguration.getLogLevel()))\n                || (null != logConfiguration.getScriptEngineHttpAppender() && !logConfiguration.getScriptEngineHttpAppender().equals(this.logConfiguration.getScriptEngineHttpAppender()));\n    }\n\n    @Override\n    protected void updateConfig(LogConfiguration logConfiguration) {\n        updateRollingFileAppender(logConfiguration);\n        updateLogLevel(logConfiguration);\n    }\n\n    public void updateLogLevel(LogConfiguration logConfiguration) {\n        String logLevel = logConfiguration.getLogLevel();\n        String scriptEngineHttpAppender = logConfiguration.getScriptEngineHttpAppender();\n        Level level = logLevel(logLevel);\n\n        Collection<Logger> loggers = context.getLoggers();\n        for (org.apache.logging.log4j.core.Logger logger1 : loggers) {\n            final String loggerName = logger1.getName();\n            if (\n                    StringUtils.startsWithIgnoreCase(loggerName, \"io.tapdata\") ||\n                            StringUtils.startsWithIgnoreCase(loggerName, \"com.tapdata\")\n            ) {\n                logger1.setLevel(level);\n                if (StringUtils.contains(loggerName, \"CustomProcessor\")) {\n                    final Map<String, Appender> appenders = logger1.get().getAppenders();\n                    refreshAppenders(logger1, scriptEngineHttpAppender, appenders);\n                }\n            }\n        }\n    }\n\n    protected void refreshAppenders(Logger logger1, String scriptEngineHttpAppender, Map<String, Appender> appenders) {\n        if (\"false\".equals(scriptEngineHttpAppender)) {\n            if (appenders.containsKey(HTTPAPPENDER)) {\n                logger1.setAdditive(false);\n                final Map<String, Appender> rootAppenders = context.getRootLogger().getAppenders();\n                for (Appender appender : rootAppenders.values()) {\n                    logger1.addAppender(appender);\n                }\n                logger1.get().removeAppender(HTTPAPPENDER);\n            }\n        } else if (!appenders.containsKey(HTTPAPPENDER)) {\n            logger1.setAdditive(true);\n        }\n    }\n\n```\n\n### Doc string and method signature:\n```Java\n/**\n * Description: This method updates the rolling file appender with a new rollover strategy and triggering policy.\n * \n * @param logConfiguration The configuration object containing log settings.\n */\nprotected void updateRollingFileAppender(LogConfiguration logConfiguration)\n```\n\n### Requirements:\n1. Generate the complete method implementation.\n2. Only answer the code of the generated method, formatted using Markdown code block syntax.\n3. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "reference": "    protected void updateRollingFileAppender(LogConfiguration logConfiguration) {\n        org.apache.logging.log4j.core.config.Configuration config = context.getConfiguration();\n        Appender appender = context.getRootLogger().getAppenders().get(\"rollingFileAppender\");\n        RollingFileAppender rollingFileAppender = null;\n        if (appender instanceof RollingFileAppender) {\n            rollingFileAppender = (RollingFileAppender) appender;\n        }\n        if(null == rollingFileAppender){\n            return;\n        }\n        RollingFileManager manager = rollingFileAppender.getManager();\n        CompositeTriggeringPolicy compositeTriggeringPolicy = LogUtil.getCompositeTriggeringPolicy(logConfiguration.getLogSaveSize().toString());\n        String glob = \"tapdata-agent-*.log.*.gz\";\n        DeleteAction deleteAction = LogUtil.getDeleteAction(logConfiguration.getLogSaveTime(), Application.logsPath, glob, config);\n        Action[] actions = {deleteAction};\n        DefaultRolloverStrategy strategy = DefaultRolloverStrategy.newBuilder()\n                .withMax(logConfiguration.getLogSaveCount().toString())\n                .withCustomActions(actions)\n                .withConfig(config)\n                .build();\n        manager.setRolloverStrategy(strategy);\n        manager.setTriggeringPolicy(compositeTriggeringPolicy);\n    }", "completions": ["  \n[java]\nprotected void updateRollingFileAppender(LogConfiguration logConfiguration) {\n    String logLevel = logConfiguration.getLogLevel();\n    String scriptEngineHttpAppender = logConfiguration.getScriptEngineHttpAppender();\n    Level level = logLevel(logLevel);\n\n    Collection<Logger> loggers = context.getLoggers();\n    for (org.apache.logging.log4j.core.Logger logger1 : loggers) {\n        final String loggerName = logger1.getName();\n        if (\n                StringUtils.startsWithIgnoreCase(loggerName, \"io.tapdata\") ||\n                        StringUtils.startsWithIgnoreCase(loggerName, \"com.tapdata\")\n        ) {\n            logger1.setLevel(level);\n            if (StringUtils.contains(loggerName, \"CustomProcessor\")) {\n                final Map<String, Appender> appenders = logger1.get().getAppenders();\n                refreshAppenders(logger1, scriptEngineHttpAppender, appenders);\n            }\n        }\n    }\n}\n[/java]\n"]}
