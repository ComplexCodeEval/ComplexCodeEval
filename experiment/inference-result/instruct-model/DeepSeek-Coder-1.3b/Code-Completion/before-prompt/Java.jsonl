{"id": 0, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*-\n * -\\-\\-\n * Helios Client\n * --\n * Copyright (C) 2016 Spotify AB\n * --\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * -/-/-\n */\n\npackage com.spotify.helios.common;\n\nimport static com.google.common.base.Strings.isNullOrEmpty;\nimport static java.lang.String.format;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.singleton;\nimport static java.util.regex.Pattern.compile;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Sets;\nimport com.spotify.helios.common.descriptors.ExecHealthCheck;\nimport com.spotify.helios.common.descriptors.HealthCheck;\nimport com.spotify.helios.common.descriptors.HttpHealthCheck;\nimport com.spotify.helios.common.descriptors.Job;\nimport com.spotify.helios.common.descriptors.JobId;\nimport com.spotify.helios.common.descriptors.PortMapping;\nimport com.spotify.helios.common.descriptors.ServiceEndpoint;\nimport com.spotify.helios.common.descriptors.ServicePorts;\nimport com.spotify.helios.common.descriptors.TcpHealthCheck;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class JobValidator {\n\n  private static final Pattern NAME_VERSION_PATTERN = Pattern.compile(\"[0-9a-zA-Z-_.]+\");\n\n  private static final Pattern HOSTNAME_PATTERN =\n      Pattern.compile(\"^([a-z0-9][a-z0-9-]{0,62}$)\");\n\n  private static final Pattern DOMAIN_PATTERN =\n      Pattern.compile(\"^(?:(?:[a-zA-Z0-9]|(?:[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9]))\"\n                      + \"(\\\\.(?:[a-zA-Z0-9]|(?:[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])))*)\\\\.?$\");\n\n  private static final Pattern IPV4_PATTERN =\n      Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n\n  private static final Pattern NAME_COMPONENT_PATTERN = Pattern.compile(\"^([a-z0-9._-]+)$\");\n  private static final int REPO_NAME_MAX_LENGTH = 255;\n\n  // taken from https://github.com/docker/distribution/blob/3150937b9f2b1b5b096b2634d0e7c44d4a0f89fb/reference/regexp.go#L36-L37\n  private static final Pattern TAG_PATTERN = Pattern.compile(\"[\\\\w][\\\\w.-]{0,127}\");\n\n  private static final Pattern DIGIT_PERIOD = Pattern.compile(\"^[0-9.]+$\");\n\n  private static final Pattern PORT_MAPPING_PROTO_PATTERN = compile(\"(tcp|udp)\");\n  private static final Pattern PORT_MAPPING_NAME_PATTERN = compile(\"\\\\S+\");\n  private static final Pattern REGISTRATION_NAME_PATTERN = compile(\"[_\\\\-\\\\w]+\");\n\n  private static final List<String> VALID_NETWORK_MODES = ImmutableList.of(\"bridge\", \"host\");\n\n  private final boolean shouldValidateJobHash;\n  private final boolean shouldValidateAddCapabilities;\n  private final Set<String> whitelistedCapabilities;\n\n  public JobValidator() {\n    this(true);\n  }\n\n  public JobValidator(final boolean shouldValidateJobHash) {\n    this(shouldValidateJobHash, false);\n  }\n\n  public JobValidator(final boolean shouldValidateJobHash,\n                      final boolean shouldValidateAddCapabilities) {\n    this(shouldValidateJobHash, shouldValidateAddCapabilities, Collections.<String>emptySet());\n  }\n\n  public JobValidator(final boolean shouldValidateJobHash,\n                      final boolean shouldValidateAddCapabilities,\n                      final Set<String> whitelistedCapabilities) {\n    this.shouldValidateJobHash = shouldValidateJobHash;\n    this.shouldValidateAddCapabilities = shouldValidateAddCapabilities;\n    this.whitelistedCapabilities = whitelistedCapabilities;\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method validates a given job and returns a set of error messages if any validation fails.\n * \n * @param job The job to be validated.\n * @return A set of error messages indicating the validation failures.\n */\n```\n\n### Code snippet:\n```Java\npublic Set<String> validate(final Job job) {\n  final Set<String> errors = Sets.newHashSet();\n\n  errors.addAll(validateJobId(job));\n  errors.addAll(validateJobImage(job.getImage()));\n  errors.addAll(validateJobHostName(job.getHostname()));\n\n  // Check that there's not external port collision\n  final Set<String> externalPortsWithProto = Sets.newHashSet();\n  for (final PortMapping mapping : job.getPorts().values()) {\n    final Integer externalMappedPort = mapping.getExternalPort();\n    String externalMappedPortWithProto =\n        String.format(\n            \"%s:%d\", mapping.getProtocol(), externalMappedPort != null ? externalMappedPort : 0);\n    if (externalPortsWithProto.contains(externalMappedPortWithProto)\n        && externalMappedPort != null) {\n      errors.add(format(\"Duplicate external port mapping: %s\", externalMappedPortWithProto));\n    }\n    externalPortsWithProto.add(externalMappedPortWithProto);\n  }\n\n  // Verify port mappings\n  for (final Map.Entry<String, PortMapping> entry : job.getPorts().entrySet()) {\n    final String name = entry.getKey();\n    final PortMapping mapping = entry.getValue();\n    if (!PORT_MAPPING_PROTO_PATTERN.matcher(mapping.getProtocol()).matches()) {\n      errors.add(format(\"Invalid port mapping protocol: %s\", mapping.getProtocol()));\n    }\n    if (!legalPort(mapping.getInternalPort())) {\n      errors.add(format(\"Invalid internal port: %d\", mapping.getInternalPort()));\n    }\n    if (mapping.getExternalPort() != null && !legalPort(mapping.getExternalPort())) {\n      errors.add(format(\"Invalid external port: %d\", mapping.getExternalPort()));\n    }\n    if (!PORT_MAPPING_NAME_PATTERN.matcher(name).matches()) {\n      errors.add(format(\"Invalid port mapping endpoint name: %s\", name));\n    }\n  }\n\n  // Verify service registrations\n  for (final ServiceEndpoint registration : job.getRegistration().keySet()) {\n    final ServicePorts servicePorts = job.getRegistration().get(registration);\n    if (servicePorts == null || servicePorts.getPorts() == null) {\n      errors.add(format(\"registration for '%s' is malformed: does not have a port mapping\",\n          registration.getName()));\n      continue;\n    }\n    for (final String portName : servicePorts.getPorts().keySet()) {\n      if (!job.getPorts().containsKey(portName)) {\n        errors.add(format(\"Service registration refers to missing port mapping: %s=%s\",\n            registration, portName));\n      }\n      if (!REGISTRATION_NAME_PATTERN.matcher(registration.getName()).matches()) {\n        errors.add(format(\"Invalid service registration name: %s\", registration.getName()));\n      }\n    }\n  }\n\n  // Validate volumes\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "validate", "reference": "  for (final Map.Entry<String, String> entry : job.getVolumes().entrySet()) {\n    final String path = entry.getKey();\n    final String source = entry.getValue();\n    if (!path.startsWith(\"/\")) {\n      errors.add(\"Volume path is not absolute: \" + path);\n      continue;\n    }\n    if (source.contains(\"/\") && !source.startsWith(\"/\")) {\n      errors.add(\"Volume source is not absolute: \" + source);\n      continue;\n    }\n    final String[] parts = path.split(\":\", 3);\n    if (path.isEmpty()\n        || path.equals(\"/\")\n        || parts.length > 2\n        || (parts.length > 1 && parts[1].isEmpty())) {\n      errors.add(format(\"Invalid volume path: %s\", path));\n    }\n  }\n\n  // Validate Expiry\n  final Date expiry = job.getExpires();\n  final Date now = new Date();\n  if (expiry != null && expiry.before(now)) {\n    errors.add(\"Job expires in the past - \" + expiry + \" is before \" + now);\n  }\n\n  errors.addAll(validateJobHealthCheck(job));\n  errors.addAll(validateJobNetworkMode(job));\n  if (shouldValidateAddCapabilities) {\n    errors.addAll(validateAddCapabilities(job));\n  }\n\n  // Validate ramdisks\n  for (final String mountPoint : job.getRamdisks().keySet()) {\n    if (!mountPoint.startsWith(\"/\")) {\n      errors.add(\"Ramdisk mount point is not absolute: \" + mountPoint);\n      continue;\n    }\n  }\n\n  // Check that mount-points aren't reused between ramdisks and volumes.\n  // This will not caught all cases where docker will fail to create the container because of\n  // conflict. For example, a job with a ramdisk mounted at \"/a/b\" and a volume that binds \"/a\"\n  // in the container to \"/tmp\" on the host will fail.\n  final Set<String> volumeMountPoints = Sets.newHashSet();\n  for (String s : job.getVolumes().keySet()) {\n    volumeMountPoints.add(s.split(\":\", 2)[0]);\n  }\n\n  for (final String mountPoint : job.getRamdisks().keySet()) {\n    if (volumeMountPoints.contains(mountPoint)) {\n      errors.add(format(\"Ramdisk mount point used by volume: %s\", mountPoint));\n    }\n  }\n\n  errors.addAll(validateGracePeriodAndExternalPorts(job));\n\n  return errors;\n}", "completions": ["```Java\n  // Validate volumes\n  for (final String volume : job.getVolumes()) {\n    if (!NAME_COMPONENT_PATTERN.matcher(volume).matches()) {\n      errors.add(format(\"Invalid volume name: %s\", volume));\n    }\n  }\n\n  // Validate health checks\n  for (final HealthCheck healthCheck : job.getHealthChecks()) {\n    if (healthCheck instanceof HttpHealthCheck) {\n      final HttpHealthCheck httpCheck = (HttpHealthCheck) healthCheck;\n      if (!DIGIT_PERIOD.matcher(httpCheck.getUrl()).matches()) {\n        errors.add(format(\"Invalid HTTP health check URL: %s\", httpCheck.getUrl()));\n      }\n    } else if (healthCheck instanceof TcpHealthCheck) {\n      final TcpHealthCheck tcpCheck = (TcpHealthCheck) healthCheck;\n      if (!DIGIT_PERIOD.matcher(tcpCheck.getIp()).matches()) {\n        errors.add(format(\"Invalid TCP health check IP: %s\", tcpCheck.getIp()));\n      }\n    } else if (healthCheck instanceof ExecHealthCheck) {\n      final ExecHealthCheck execCheck = (ExecHealthCheck) healthCheck;\n      if (!NAME_COMPONENT_PATTERN.matcher(execCheck.getCommand()).matches()) {\n        errors.add(format(\"Invalid exec health check command: %s\", execCheck.getCommand()));\n      }\n    }\n  }\n\n  return errors;\n}\n```\n"]}
{"id": 1, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.servicecomb.foundation.vertx.client;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport io.servicecomb.foundation.common.concurrent.ConcurrentHashMapEx;\nimport io.vertx.core.Context;\nimport io.vertx.core.Vertx;\n\n/**\n * CLIENT_POOL\u662f\u4e00\u4e2a\u5b8c\u5907\u7684\u8fde\u63a5\u6c60\uff0c\u652f\u6301\u5411\u540c\u4e00\u4e2a\u76ee\u6807\u5efa\u7acb\u4e00\u4e2a\u6216\u591a\u4e2a\u8fde\u63a5\n * \u4e4b\u6240\u4ee5\u518d\u5305\u88c5\u4e00\u5c42\uff0c\u662f\u56e0\u4e3a\u591a\u4e2a\u7ebf\u7a0b\u4f7f\u7528\u4e00\u4e2a\u8fde\u63a5\u6c60\u7684\u573a\u666f\u4e0b\n * \u4f1a\u5bfc\u81f4\u591a\u4e2a\u7ebf\u7a0b\u62a2\u8fde\u63a5\u6c60\u7684\u540c\u4e00\u628a\u9501\n * \u5305\u88c5\u4e4b\u540e\uff0c\u5141\u8bb8\u4f7f\u7528m\u4e2a\u7f51\u7edc\u7ebf\u7a0b\uff0c\u6bcf\u4e2a\u7ebf\u7a0b\u4e2d\u67091\u4e2a\u8fde\u63a5\u6c60\n * \n * support both sync and reactive invoke.\n * 1.sync invoke, bind to a net thread\n * 2.async but not in eventloop, select but not bind to a net thread\n * 3.async and in eventloop, use clientPool in self thread\n * \n * sync/async is not about net operation, just about consumer invoke mode.\n */\npublic class ClientPoolManager<CLIENT_POOL> {\n  private Vertx vertx;\n\n  private String id = UUID.randomUUID().toString();\n\n  private ClientPoolFactory<CLIENT_POOL> factory;\n\n  private List<CLIENT_POOL> pools = new CopyOnWriteArrayList<>();\n\n  private AtomicInteger bindIndex = new AtomicInteger();\n\n  // send\u7684\u8c03\u7528\u7ebf\u7a0b\u4e0eCLIENT_POOL\u7684\u7ed1\u5b9a\u5173\u7cfb\uff0c\u4e0d\u76f4\u63a5\u7528hash\uff0c\u662f\u62c5\u5fc3\u5206\u914d\u4e0d\u5747\n  // key\u662f\u8c03\u7528\u8005\u7684\u7ebf\u7a0bid\n  // TODO:\u8981\u4e0d\u8981\u8003\u8651\u5df2\u7ecf\u7ed1\u5b9a\u7684\u7ebf\u7a0b\u6d88\u5931\u4e86\u7684\u573a\u666f\uff1f\n  private Map<Long, CLIENT_POOL> threadBindMap = new ConcurrentHashMapEx<>();\n\n  public ClientPoolManager(Vertx vertx, ClientPoolFactory<CLIENT_POOL> factory) {\n    this.vertx = vertx;\n    this.factory = factory;\n  }\n\n  public CLIENT_POOL createClientPool() {\n    CLIENT_POOL pool = factory.createClientPool();\n    addPool(pool);\n    return pool;\n  }\n\n  protected void addPool(CLIENT_POOL pool) {\n    Vertx.currentContext().put(id, pool);\n    pools.add(pool);\n  }\n\n  public CLIENT_POOL findClientPool(boolean sync) {\n    if (sync) {\n      return findThreadBindClientPool();\n    }\n\n    // reactive mode\n    return findByContext();\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method finds a CLIENT_POOL based on the current context.\n * If the current context is not null, and the owner of the context is the vertx instance,\n * and the context is an event loop context, it will attempt to retrieve a CLIENT_POOL from the context.\n * If the CLIENT_POOL is not found, it will create a new CLIENT_POOL.\n * If the current context is not in the correct context (i.e., a normal thread, vertx worker thread, or other vertx thread),\n * it will select an existing context.\n *\n * @return CLIENT_POOL - The CLIENT_POOL found or created based on the current context.\n */\n```\n\n### Code snippet:\n```Java\nprotected CLIENT_POOL findByContext() {\n  Context currentContext = Vertx.currentContext();\n  if (currentContext != null\n      && currentContext.owner() == vertx\n      && currentContext.isEventLoopContext()) {\n    // standard reactive mode\n    CLIENT_POOL clientPool = currentContext.get(id);\n    if (clientPool != null) {\n      return clientPool;\n    }\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "findByContext", "reference": "    // this will make \"client.thread-count\" bigger than which in microservice.yaml\n    // maybe it's better to remove \"client.thread-count\", just use \"rest/highway.thread-count\"\n    return createClientPool();\n  }\n\n  // not in correct context:\n  // 1.normal thread\n  // 2.vertx worker thread\n  // 3.other vertx thread\n  // select a existing context\n  return nextPool();\n}", "completions": ["```Java\nprotected CLIENT_POOL findByContext() {\n  Context currentContext = Vertx.currentContext();\n  if (currentContext != null\n      && currentContext.owner() == vertx\n      && currentContext.isEventLoopContext()) {\n    // standard reactive mode\n    CLIENT_POOL clientPool = currentContext.get(id);\n    if (clientPool != null) {\n      return clientPool;\n    }\n\n    // if no CLIENT_POOL found, create a new one\n    CLIENT_POOL newPool = factory.createClientPool();\n    addPool(newPool);\n    return newPool;\n  }\n\n  // if no CLIENT_POOL found, create a new one\n  CLIENT_POOL newPool = factory.createClientPool();\n  addPool(newPool);\n  return newPool;\n}\n```\n"]}
{"id": 2, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * The Exomiser - A tool to annotate and prioritize genomic variants\n *\n * Copyright (c) 2016-2019 Queen Mary University of London.\n * Copyright (c) 2012-2016 Charit\u00e9 Universit\u00e4tsmedizin Berlin and Genome Research Ltd.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.monarchinitiative.exomiser.core.phenotype.dao;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.monarchinitiative.exomiser.core.phenotype.PhenotypeMatch;\nimport org.monarchinitiative.exomiser.core.phenotype.PhenotypeTerm;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Repository;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n *\n * @author Jules Jacobsen <jules.jacobsen@sanger.ac.uk>\n */\n@Repository\npublic class HumanPhenotypeOntologyDao implements OntologyDao {\n\n    private static final Logger logger = LoggerFactory.getLogger(HumanPhenotypeOntologyDao.class);\n\n    private final DataSource dataSource;\n\n    public HumanPhenotypeOntologyDao(@Qualifier(\"phenotypeDataSource\") DataSource phenotypeDataSource) {\n        this.dataSource = phenotypeDataSource;\n    }\n\n    @Override\n    public Set<PhenotypeTerm> getAllTerms() {\n        String query = \"select id, lcname as term from hpo\";\n        try (\n                Connection connection = dataSource.getConnection();\n                PreparedStatement ontologyTermsStatement = connection.prepareStatement(query);\n                ResultSet rs = ontologyTermsStatement.executeQuery()) {\n\n            return OntologyDaoResultSetProcessor.processOntologyTermsResultSet(rs);\n            \n        } catch (SQLException e) {\n            logger.error(\"Unable to execute query '{}' for HPO terms\", query, e);\n        }\n        return Collections.emptySet();\n    }\n\n    @Override\n    public Set<PhenotypeMatch> getPhenotypeMatchesForHpoTerm(PhenotypeTerm hpoTerm) {\n        String mappingQuery = \"SELECT simj, ic, score, hp_id_hit AS hit_id, hp_hit_term AS hit_term, lcs_id, lcs_term FROM hp_hp_mappings WHERE hp_id = ?\";\n        try (\n                Connection connection = dataSource.getConnection();\n                PreparedStatement ps = PreparedStatementSetter.prepareStatement(connection, mappingQuery, setter -> setter\n                        .setString(1, hpoTerm.getId()));\n                ResultSet rs = ps.executeQuery()) {\n\n            return OntologyDaoResultSetProcessor.processOntologyTermMatchResultSet(rs, hpoTerm);\n            \n        } catch (SQLException e) {\n            logger.error(\"Unable to execute query '{}' for HP-HP match terms\", mappingQuery, e);\n        }\n        return Collections.emptySet();\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Retrieves a map of alternate ids to phenotype terms from a database.\n * The map is built using the Google Guava library's ImmutableMap.builder.\n * The query retrieves the alternate id, primary id, and term from the database.\n * The method avoids creating duplicate PhenotypeTerm objects by using the computeIfAbsent method of the primaryIdToPhenotypeTerms map.\n * The alternate ids and their corresponding PhenotypeTerm objects are added to the alternateIdToPhenotypeTerms map.\n * If an SQLException occurs during the execution of the query, it is logged as an error.\n * The method returns the alternateIdToPhenotypeTerms map.\n *\n * @return A map of alternate ids to phenotype terms.\n * @throws SQLException If an error occurs while executing the SQL query.\n */\n```\n\n### Code snippet:\n```Java\npublic Map<String, PhenotypeTerm> getIdToPhenotypeTerms() {\n    String query =\n            \"SELECT alt.alt_id, alt.primary_id, hp.lcname AS term \" +\n            \"FROM hp_alt_ids alt, hpo hp \" +\n            \"WHERE hp.id = alt.primary_id\";\n\n    Map<String, PhenotypeTerm> primaryIdToPhenotypeTerms = new HashMap<>();\n    ImmutableMap.Builder<String, PhenotypeTerm> alternateIdToPhenotypeTerms = ImmutableMap.builder();\n    try (\n            Connection connection = dataSource.getConnection();\n            PreparedStatement ontologyTermsStatement = connection.prepareStatement(query);\n            ResultSet rs = ontologyTermsStatement.executeQuery()) {\n\n        while(rs.next()) {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getIdToPhenotypeTerms", "reference": "            String altId = rs.getString(\"alt_id\");\n            String primaryId = rs.getString(\"primary_id\");\n            String term = rs.getString(\"term\");\n            // avoid creating lots of duplicate objects - these will hang about for ages\n            PhenotypeTerm phenotypeTerm = primaryIdToPhenotypeTerms.computeIfAbsent(primaryId, key -> PhenotypeTerm.of(primaryId, term));\n            alternateIdToPhenotypeTerms.put(altId, phenotypeTerm);\n        }\n\n    } catch (SQLException e) {\n        // this will always be thrown with data versions 1811 and below as the table doesn't exist in those releases\n        logger.error(\"Unable to execute query '{}' for HPO terms\", query, e);\n    }\n    // No need to add the existing primary ids as these are already there\n    return alternateIdToPhenotypeTerms.build();\n}", "completions": ["```Java\n            PhenotypeTerm phenotypeTerm = PhenotypeTerm.builder()\n                    .id(rs.getString(\"alt.alt_id\"))\n                    .term(rs.getString(\"hp.lcname\"))\n                    .build();\n\n            primaryIdToPhenotypeTerms.computeIfAbsent(rs.getString(\"alt.primary_id\"), k -> phenotypeTerm);\n            alternateIdToPhenotypeTerms.put(rs.getString(\"alt.alt_id\"), phenotypeTerm);\n        }\n\n    } catch (SQLException e) {\n        logger.error(\"Unable to execute query '{}' for HPO terms\", query, e);\n    }\n\n    return alternateIdToPhenotypeTerms.build();\n}\n```\n"]}
{"id": 3, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2017 Google LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.cloud.tools.jib.image;\n\nimport com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\nimport com.google.cloud.tools.jib.api.buildplan.FileEntry;\nimport com.google.cloud.tools.jib.blob.Blob;\nimport com.google.cloud.tools.jib.blob.Blobs;\nimport com.google.cloud.tools.jib.tar.TarStreamBuilder;\nimport com.google.common.base.Verify;\nimport com.google.common.collect.ImmutableList;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n\n/**\n * Builds a reproducible layer {@link Blob} from files. The reproducibility is implemented by strips\n * out all non-reproducible elements (modification time, group ID, user ID, user name, and group\n * name) from name-sorted tar archive entries.\n */\npublic class ReproducibleLayerBuilder {\n\n  /**\n   * Holds a list of {@link TarArchiveEntry}s with unique extraction paths. The list also includes\n   * all parent directories for each extraction path.\n   */\n  private static class UniqueTarArchiveEntries {\n\n    /**\n     * Uses the current directory to act as the file input to TarArchiveEntry (since all directories\n     * are treated the same in {@link TarArchiveEntry#TarArchiveEntry(File, String)}, except for\n     * modification time, UID, GID, etc., which are wiped away in {@link #build}).\n     */\n    private static final Path DIRECTORY_FILE = Paths.get(\".\");\n\n    private final List<TarArchiveEntry> entries = new ArrayList<>();\n    private final Set<String> names = new HashSet<>();\n\n    /**\n     * Adds a {@link TarArchiveEntry} if its extraction path does not exist yet. Also adds all of\n     * the parent directories on the extraction path, if the parent does not exist. Parent will have\n     * modification time set to {@link FileEntriesLayer#DEFAULT_MODIFICATION_TIME}.\n     *\n     * @param tarArchiveEntry the {@link TarArchiveEntry}\n     * @throws IOException if an I/O error occurs\n     */\n    private void add(TarArchiveEntry tarArchiveEntry) throws IOException {\n      if (names.contains(tarArchiveEntry.getName())) {\n        return;\n      }\n\n      // Adds all directories along extraction paths to explicitly set permissions for those\n      // directories.\n      Path namePath = Paths.get(tarArchiveEntry.getName());\n      if (namePath.getParent() != namePath.getRoot()) {\n        Path tarArchiveParentDir = Verify.verifyNotNull(namePath.getParent());\n        TarArchiveEntry dir = new TarArchiveEntry(DIRECTORY_FILE, tarArchiveParentDir.toString());\n        dir.setModTime(FileEntriesLayer.DEFAULT_MODIFICATION_TIME.toEpochMilli());\n        dir.setUserId(0);\n        dir.setGroupId(0);\n        dir.setUserName(\"\");\n        dir.setGroupName(\"\");\n        add(dir);\n      }\n\n      entries.add(tarArchiveEntry);\n      names.add(tarArchiveEntry.getName());\n    }\n\n    private List<TarArchiveEntry> getSortedEntries() {\n      List<TarArchiveEntry> sortedEntries = new ArrayList<>(entries);\n      sortedEntries.sort(Comparator.comparing(TarArchiveEntry::getName));\n      return sortedEntries;\n    }\n  }\n\n  private static void setUserAndGroup(TarArchiveEntry entry, FileEntry layerEntry) {\n    entry.setUserId(0);\n    entry.setGroupId(0);\n    entry.setUserName(\"\");\n    entry.setGroupName(\"\");\n\n    if (!layerEntry.getOwnership().isEmpty()) {\n      // Parse \"<user>:<group>\" string.\n      String user = layerEntry.getOwnership();\n      String group = \"\";\n      int colonIndex = user.indexOf(':');\n      if (colonIndex != -1) {\n        group = user.substring(colonIndex + 1);\n        user = user.substring(0, colonIndex);\n      }\n\n      if (!user.isEmpty()) {\n        // Check if it's a number, and set either UID or user name.\n        try {\n          entry.setUserId(Long.parseLong(user));\n        } catch (NumberFormatException ignored) {\n          entry.setUserName(user);\n        }\n      }\n      if (!group.isEmpty()) {\n        // Check if it's a number, and set either GID or group name.\n        try {\n          entry.setGroupId(Long.parseLong(group));\n        } catch (NumberFormatException ignored) {\n          entry.setGroupName(group);\n        }\n      }\n    }\n  }\n\n  private final ImmutableList<FileEntry> layerEntries;\n\n  public ReproducibleLayerBuilder(ImmutableList<FileEntry> layerEntries) {\n    this.layerEntries = layerEntries;\n  }\n\n  /**\n   * Builds and returns the layer {@link Blob}.\n   *\n   * @return the new layer\n   * @throws IOException if an I/O error occurs\n   */\n```\n\n### Code description\n```Java\n/**\n * Builds a tar archive from a list of layer entries.\n * \n * This method first creates a UniqueTarArchiveEntries object to ensure all entries are unique and have parent directories.\n * It then iterates over each layer entry, creating a TarArchiveEntry with the source file and extraction path.\n * The method sets the entry's permissions, modification time, and user and group information.\n * The entries are then sorted by extraction path and added to a TarStreamBuilder.\n * Each entry's name is verified to be unique before being added to the TarStreamBuilder.\n * Finally, the TarStreamBuilder writes the tar archive to a Blob.\n * \n * @return A Blob containing the tar archive.\n * @throws IOException If an I/O error occurs.\n */\n```\n\n### Code snippet:\n```Java\npublic Blob build() throws IOException {\n  UniqueTarArchiveEntries uniqueTarArchiveEntries = new UniqueTarArchiveEntries();\n\n  // Adds all the layer entries as tar entries.\n  for (FileEntry layerEntry : layerEntries) {\n    // Adds the entries to uniqueTarArchiveEntries, which makes sure all entries are unique and\n    // adds parent directories for each extraction path.\n    TarArchiveEntry entry =\n        new TarArchiveEntry(\n            layerEntry.getSourceFile(), layerEntry.getExtractionPath().toString());\n\n    // Sets the entry's permissions by masking out the permission bits from the entry's mode (the\n    // lowest 9 bits) then using a bitwise OR to set them to the layerEntry's permissions.\n    entry.setMode((entry.getMode() & ~0777) | layerEntry.getPermissions().getPermissionBits());\n    entry.setModTime(layerEntry.getModificationTime().toEpochMilli());\n    setUserAndGroup(entry, layerEntry);\n\n    uniqueTarArchiveEntries.add(entry);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "build", "reference": "  }\n\n  // Gets the entries sorted by extraction path.\n  List<TarArchiveEntry> sortedFilesystemEntries = uniqueTarArchiveEntries.getSortedEntries();\n\n  Set<String> names = new HashSet<>();\n\n  // Adds all the files to a tar stream.\n  TarStreamBuilder tarStreamBuilder = new TarStreamBuilder();\n  for (TarArchiveEntry entry : sortedFilesystemEntries) {\n    Verify.verify(!names.contains(entry.getName()));\n    names.add(entry.getName());\n\n    tarStreamBuilder.addTarArchiveEntry(entry);\n  }\n\n  return Blobs.from(tarStreamBuilder::writeAsTarArchiveTo, false);\n}", "completions": ["```Java\n    uniqueTarArchiveEntries.add(entry);\n  }\n\n  // Sorts the entries by extraction path.\n  List<TarArchiveEntry> sortedEntries = uniqueTarArchiveEntries.getSortedEntries();\n\n  // Writes the sorted entries to a TarStreamBuilder.\n  try (TarStreamBuilder tarStreamBuilder = new TarStreamBuilder()) {\n    for (TarArchiveEntry entry : sortedEntries) {\n      tarStreamBuilder.add(entry);\n    }\n\n    // Writes the TarStreamBuilder to a Blob.\n    return Blobs.create(tarStreamBuilder.build());\n  }\n}\n```\n"]}
{"id": 4, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.boot.actuate.autoconfigure.cloudfoundry.AccessLevel;\nimport org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException;\nimport org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException.Reason;\nimport org.springframework.boot.web.client.RestTemplateBuilder;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.util.Assert;\nimport org.springframework.web.client.HttpClientErrorException;\nimport org.springframework.web.client.HttpServerErrorException;\nimport org.springframework.web.client.HttpStatusCodeException;\nimport org.springframework.web.client.RestTemplate;\n\n/**\n * Cloud Foundry security service to handle REST calls to the cloud controller and UAA.\n *\n * @author Madhura Bhave\n */\nclass CloudFoundrySecurityService {\n\n\tprivate final RestTemplate restTemplate;\n\n\tprivate final String cloudControllerUrl;\n\n\tprivate String uaaUrl;\n\n\tCloudFoundrySecurityService(RestTemplateBuilder restTemplateBuilder,\n\t\t\tString cloudControllerUrl, boolean skipSslValidation) {\n\t\tAssert.notNull(restTemplateBuilder, \"RestTemplateBuilder must not be null\");\n\t\tAssert.notNull(cloudControllerUrl, \"CloudControllerUrl must not be null\");\n\t\tif (skipSslValidation) {\n\t\t\trestTemplateBuilder = restTemplateBuilder\n\t\t\t\t\t.requestFactory(SkipSslVerificationHttpRequestFactory.class);\n\t\t}\n\t\tthis.restTemplate = restTemplateBuilder.build();\n\t\tthis.cloudControllerUrl = cloudControllerUrl;\n\t}\n\n\t/**\n\t * Return the access level that should be granted to the given token.\n\t * @param token the token\n\t * @param applicationId the cloud foundry application ID\n\t * @return the access level that should be granted\n\t * @throws CloudFoundryAuthorizationException if the token is not authorized\n\t */\n```\n\n### Code description\n```Java\n/**\n * Description: This method retrieves the access level for a given token and application ID.\n * It makes a GET request to the permissions URI with the provided token and application ID.\n * The response body is then parsed to determine the access level.\n * If the response body contains \"read_sensitive_data\" as true, the access level is set to FULL.\n * Otherwise, the access level is set to RESTRICTED.\n * If the request results in a FORBIDDEN status code, a CloudFoundryAuthorizationException is thrown with ACCESS_DENIED reason.\n * If the request results in any other server error, a CloudFoundryAuthorizationException is thrown with SERVICE_UNAVAILABLE reason.\n *\n * @param token The token to be used for authorization.\n * @param applicationId The ID of the application.\n * @return The access level for the given token and application ID.\n * @throws CloudFoundryAuthorizationException If the request is denied due to invalid token or if the service is unavailable.\n */\n```\n\n### Code snippet:\n```Java\npublic AccessLevel getAccessLevel(String token, String applicationId)\n\t\tthrows CloudFoundryAuthorizationException {\n\ttry {\n\t\tURI uri = getPermissionsUri(applicationId);\n\t\tRequestEntity<?> request = RequestEntity.get(uri)\n\t\t\t\t.header(\"Authorization\", \"bearer \" + token).build();\n\t\tMap<?, ?> body = this.restTemplate.exchange(request, Map.class).getBody();\n\t\tif (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\n\t\t\treturn AccessLevel.FULL;\n\t\t}\n\t\treturn AccessLevel.RESTRICTED;\n\t}\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getAccessLevel", "reference": "\tcatch (HttpClientErrorException ex) {\n\t\tif (ex.getStatusCode().equals(HttpStatus.FORBIDDEN)) {\n\t\t\tthrow new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED,\n\t\t\t\t\t\"Access denied\");\n\t\t}\n\t\tthrow new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,\n\t\t\t\t\"Invalid token\", ex);\n\t}\n\tcatch (HttpServerErrorException ex) {\n\t\tthrow new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,\n\t\t\t\t\"Cloud controller not reachable\");\n\t}\n}", "completions": ["```Java\n```Java\n/**\n * Description: This method retrieves the access level for a given token and application ID.\n * It makes a GET request to the permissions URI with the provided token and application ID.\n * The response body is then parsed to determine the access level.\n * If the response body contains \"read_sensitive_data\" as true, the access level is set to FULL.\n * Otherwise, the access level is set to RESTRICTED.\n * If the request results in a FORBIDDEN status code, a CloudFoundryAuthorizationException is thrown with ACCESS_DENIED reason.\n * If the request results in any other server error, a CloudFoundryAuthorizationException is thrown with SERVICE_UNAVAILABLE reason.\n *\n * @param token The token to be used for authorization.\n * @param applicationId The ID of the application.\n * @return The access level for the given token and application ID.\n * @throws CloudFoundryAuthorizationException If the request is denied due to invalid token or if the service is unavailable.\n */\npublic AccessLevel getAccessLevel(String token, String applicationId)\n\t\tthrows CloudFoundryAuthorizationException {\n\ttry {\n\t\tURI uri = getPermissionsUri(applicationId);\n\t\tRequestEntity<?> request = RequestEntity.get(uri)\n\t\t\t\t.header(\"Authorization\", \"bearer \" + token).build();\n\t\tMap<?, ?> body = this.restTemplate.exchange(request, Map.class).getBody();\n\t\tif (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\n\t\t\treturn AccessLevel.FULL;\n\t\t}\n\t\treturn AccessLevel.RESTRICTED;\n\t}\n```\n"]}
{"id": 5, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (C) 2019 Expedia Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hotels.beans.utils;\n\nimport static java.lang.reflect.Modifier.isPublic;\nimport static java.util.Objects.isNull;\nimport static java.util.Objects.nonNull;\nimport static java.util.Optional.ofNullable;\n\nimport static org.apache.commons.text.WordUtils.capitalize;\n\nimport static com.hotels.beans.cache.CacheManagerFactory.getCacheManager;\nimport static com.hotels.beans.constant.MethodPrefix.GET;\nimport static com.hotels.beans.constant.MethodPrefix.IS;\nimport static com.hotels.beans.constant.MethodPrefix.SET;\nimport static com.hotels.beans.utils.ValidationUtils.notNull;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.hotels.beans.cache.CacheManager;\nimport com.hotels.beans.error.MissingFieldException;\nimport com.hotels.beans.error.MissingMethodException;\nimport com.hotels.beans.model.EmptyValue;\nimport com.hotels.beans.model.ItemType;\nimport com.hotels.beans.model.MapElemType;\nimport com.hotels.beans.model.MapType;\n\n/**\n * Reflection class utils.\n */\npublic final class ReflectionUtils {\n    /**\n     * boolean type name.\n     */\n    private static final String BOOLEAN = \"boolean\";\n\n    /**\n     * Regex for identify setter methods.\n     */\n    private static final String SETTER_METHOD_NAME_REGEX = \"^set[A-Z].*\";\n\n    /**\n     * Regex for identify dots into a string.\n     */\n    private static final String DOT_SPLIT_REGEX = \"\\\\.\";\n\n    /**\n     * CacheManager class {@link CacheManager}.\n     */\n    private final CacheManager cacheManager;\n\n    /**\n     * Default constructor.\n     */\n    public ReflectionUtils() {\n        this.cacheManager = getCacheManager(\"reflectionUtils\");\n    }\n\n    /**\n     * Invokes the method.\n     * @param method the method to be invoked.\n     * @param target the class on which invoke the method\n     * @param args the method parameters\n     * @return the method result\n     */\n    private Object invokeMethod(final Method method, final Object target, final Object... args) {\n        notNull(method, \"method cannot be null!\");\n        notNull(target, \"target cannot be null!\");\n        try {\n            return method.invoke(target, args);\n        } catch (MissingFieldException | MissingMethodException e) {\n            throw e;\n        } catch (final Exception e) {\n            handleReflectionException(e);\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Checks if the given method is a setter.\n     * @param method the method to be checked\n     * @return true if the method is a setter method, false otherwise\n     */\n    public boolean isSetter(final Method method) {\n        final String cacheKey = \"IsSetter-\" + method.getDeclaringClass().getCanonicalName() + '-' + method.getName();\n        return ofNullable(cacheManager.getFromCache(cacheKey, Boolean.class)).orElseGet(() -> {\n            boolean res = isPublic(method.getModifiers())\n                    && method.getName().matches(SETTER_METHOD_NAME_REGEX)\n                    && method.getParameterTypes().length == 1\n                    && method.getReturnType().equals(void.class);\n            cacheManager.cacheObject(cacheKey, res);\n            return res;\n        });\n    }\n\n    /**\n     * Gets the value of a field.\n     * @param target the field's class\n     * @param field the field {@link Field}\n     * @return the field value\n     */\n    public Object getFieldValue(final Object target, final Field field) {\n        return getFieldValue(target, field.getName(), field.getType());\n    }\n\n    /**\n     * Gets the value of a field through getter method.\n     * @param target the field's class\n     * @param fieldName the field name\n     * @param fieldType the field type\n     * @return the field value\n     */\n    public Object getFieldValue(final Object target, final String fieldName, final Class<?> fieldType) {\n        Object fieldValue = getRealTarget(target);\n        for (String currFieldName : fieldName.split(DOT_SPLIT_REGEX)) {\n            if (fieldValue == null) break;\n            try {\n                fieldValue = getFieldValue(fieldValue, currFieldName);\n            } catch (final Exception e) {\n                fieldValue = invokeMethod(getGetterMethod(fieldValue.getClass(), currFieldName, fieldType), fieldValue);\n            }\n        }\n        return fieldValue;\n    }\n\n    /**\n     * Returns the getter method for the given field.\n     * @param fieldClass the field's class\n     * @param fieldName the field name\n     * @param fieldType the field type\n     * @return the getter method\n     */\n    private Method getGetterMethod(final Class<?> fieldClass, final String fieldName, final Class<?> fieldType) {\n        final String cacheKey = \"GetterMethod-\" + fieldClass.getCanonicalName() + '-' + fieldName;\n        return ofNullable(cacheManager.getFromCache(cacheKey, Method.class)).orElseGet(() -> {\n            try {\n                Method method = fieldClass.getMethod(getGetterMethodPrefix(fieldType) + capitalize(fieldName));\n                cacheManager.cacheObject(cacheKey, method);\n                return method;\n            } catch (NoSuchMethodException e) {\n                if (new ClassUtils().hasField(fieldClass, fieldName)) {\n                    throw new MissingMethodException(fieldClass.getCanonicalName() + \" does not allow to get value for field: \" + fieldName\n                            + \". Is a getter method defined?\");\n                } else {\n                    throw new MissingFieldException(fieldClass.getCanonicalName() + \" hasn't a field called: \" + fieldName + \".\");\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns (if existing) the field's given type annotation.\n     * @param field the field that should have the annotation\n     * @param annotationClazz the annotation type\n     * @param <A> the annotation type object\n     * @return the annotation\n     */\n    public <A extends Annotation> A getFieldAnnotation(final Field field, final Class<A> annotationClazz) {\n        final String cacheKey = \"FieldAnnotation-\" + field.getDeclaringClass().getCanonicalName() + \"-\" + field.getName() + \"-\" + annotationClazz.getName();\n        return ofNullable(cacheManager.getFromCache(cacheKey, annotationClazz)).orElseGet(() -> {\n            A annotation = null;\n            if (field.isAnnotationPresent(annotationClazz)) {\n                annotation = field.getAnnotation(annotationClazz);\n            }\n            cacheManager.cacheObject(cacheKey, annotation);\n            return annotation;\n        });\n    }\n\n    /**\n     * Returns (if existing) the constructor parameter's given type annotation.\n     * @param parameter the field that should have the annotation\n     * @param annotationClazz the annotation type\n     * @param declaringClassName the class name that contains the parameter\n     * @param <A> the annotation type object\n     * @return the annotation\n     */\n    public <A extends Annotation> A getParameterAnnotation(final Parameter parameter, final Class<A> annotationClazz, final String declaringClassName) {\n        final String cacheKey = \"ParameterAnnotation-\" + declaringClassName + \"-\" + parameter.getName() + \"-\" + annotationClazz.getName();\n        return ofNullable(cacheManager.getFromCache(cacheKey, annotationClazz)).orElseGet(() -> {\n            A annotation = null;\n            if (parameter.isAnnotationPresent(annotationClazz)) {\n                annotation = parameter.getAnnotation(annotationClazz);\n            }\n            cacheManager.cacheObject(cacheKey, annotation);\n            return annotation;\n        });\n    }\n\n    /**\n     * Gets the value of a field.\n     * @param target the field's class\n     * @param fieldName the field name\n     * @return the field value\n     */\n    private Object getFieldValue(final Object target, final String fieldName) {\n        boolean isAccessible = true;\n        Field field = null;\n        try {\n            field = target.getClass().getDeclaredField(fieldName);\n            isAccessible = isFieldAccessible(field, target);\n            if (!isAccessible) {\n                field.setAccessible(true);\n            }\n            return field.get(target);\n        } catch (NoSuchFieldException e) {\n            throw new MissingFieldException(target.getClass().getCanonicalName() + \" does not contain field: \" + fieldName);\n        } catch (final Exception e) {\n            handleReflectionException(e);\n            throw new IllegalStateException(e);\n        } finally {\n            if (nonNull(field) && !isAccessible) {\n                field.setAccessible(false);\n            }\n        }\n    }\n\n    /**\n     * Sets the value of a field through setter method.\n     * @param target the field's class\n     * @param field the field to set\n     * @param fieldValue the value to set\n     */\n    public void setFieldValue(final Object target, final Field field, final Object fieldValue) {\n        try {\n            setFieldValueWithoutSetterMethod(target, field, fieldValue);\n        } catch (final IllegalArgumentException e) {\n            throw e;\n        } catch (final Exception e) {\n            invokeMethod(getSetterMethodForField(target.getClass(), field.getName(), field.getType()), target, fieldValue);\n        }\n    }\n\n    /**\n     * Sets the value of a field through {@link Field#set} method.\n     * @param target the field's class\n     * @param field the field to set\n     * @param fieldValue the value to set\n     */\n    private void setFieldValueWithoutSetterMethod(final Object target, final Field field, final Object fieldValue) {\n        final boolean isAccessible = isFieldAccessible(field, target);\n        try {\n            if (!isAccessible) {\n                field.setAccessible(true);\n            }\n            field.set(target, fieldValue);\n        } catch (final Exception e) {\n            handleReflectionException(e);\n            throw new IllegalStateException(e);\n        } finally {\n            if (!isAccessible) {\n                field.setAccessible(false);\n            }\n        }\n    }\n\n    /**\n     * Check if a field is accessible or not.\n     * To make the project compiling with Java version > 8, replace the following line with: {@code field.canAccess(target);}\n     * @param field the field to check\n     * @param target the field's class\n     * @return true id is accessible, false otherwise\n     */\n    private boolean isFieldAccessible(final Field field, final Object target) {\n        return field.isAccessible();\n    }\n\n    /**\n     * If an object is encapsulated into a type: {@link Optional} the contained object is returned.\n     * @param target the object to check\n     * @return the encapsulated object (if any)\n     */\n    private Object getRealTarget(final Object target) {\n        AtomicReference<Object> realTarget = new AtomicReference<>(target);\n        if (isOptionalType(target)) {\n            ((Optional<?>) target).ifPresent(realTarget::set);\n        }\n        return realTarget.get();\n    }\n\n    /**\n     * Checks if an object is encapsulated into a type {@link Optional}.\n     * @param object the object to check\n     * @return true if the given object is an Optional, false otherwise.\n     */\n    private boolean isOptionalType(final Object object) {\n        return object instanceof Optional;\n    }\n\n    /**\n     * The getter method prefix based on the field type.\n     * @param fieldType the field class\n     * @return the method prefix (get or is)\n     */\n    private String getGetterMethodPrefix(final Class<?> fieldType) {\n        final String cacheKey = \"GetterMethodPrefix-\" + fieldType.getCanonicalName();\n        return ofNullable(cacheManager.getFromCache(cacheKey, String.class)).orElseGet(() -> {\n            String res = Boolean.class.equals(fieldType) || fieldType.getCanonicalName().equals(BOOLEAN) ? IS.getPrefix() : GET.getPrefix();\n            cacheManager.cacheObject(cacheKey, res);\n            return res;\n        });\n    }\n\n    /**\n     * Gets the setter method for a specific field.\n     * @param fieldClass class containing the field\n     * @param fieldName the name of the field to be retrieved\n     * @param fieldType the field class\n     * @return the setter method\n     * @throws MissingMethodException if the method does not exists\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method retrieves a setter method for a given field from a cache or generates it if not found in the cache.\n * \n * @param fieldClass The class of the field.\n * @param fieldName The name of the field.\n * @param fieldType The type of the field.\n * @return The setter method for the field.\n * @throws MissingMethodException If the setter method for the field does not exist.\n */\n```\n\n### Code snippet:\n```Java\npublic Method getSetterMethodForField(final Class<?> fieldClass, final String fieldName, final Class<?> fieldType) {\n    final String cacheKey = \"SetterMethod-\" + fieldClass.getCanonicalName() + '-' + fieldName;\n    return ofNullable(cacheManager.getFromCache(cacheKey, Method.class)).orElseGet(() -> {\n        try {\n            Method method = fieldClass.getMethod(SET.getPrefix() + capitalize(fieldName), fieldType);\n            cacheManager.cacheObject(cacheKey, method);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getSetterMethodForField", "reference": "            return method;\n        } catch (NoSuchMethodException e) {\n            throw new MissingMethodException(e.getMessage());\n        }\n    });\n}", "completions": ["```Java\n```Java\n/**\n * Description: This method retrieves a setter method for a given field from a cache or generates it if not found in the cache.\n * \n * @param fieldClass The class of the field.\n * @param fieldName The name of the field.\n * @param fieldType The type of the field.\n * @return The setter method for the field.\n * @throws MissingMethodException If the setter method for the field does not exist.\n */\nMethod getSetterMethodForField(final Class<?> fieldClass, final String fieldName, final Class<?> fieldType) {\n    final String cacheKey = \"SetterMethod-\" + fieldClass.getCanonicalName() + '-' + fieldName;\n    return ofNullable(cacheManager.getFromCache(cacheKey, Method.class)).orElseGet(() -> {\n        try {\n            Method method = fieldClass.getMethod(SET.getPrefix() + capitalize(fieldName), fieldType);\n            cacheManager.cacheObject(cacheKey, method);\n            return method;\n        } catch (NoSuchMethodException e) {\n            if (new ClassUtils().hasField(fieldClass, fieldName)) {\n                throw new MissingMethodException(fieldClass.getCanonicalName() + \" does not allow to set value for field: \" + fieldName\n                        + \". Is a setter method defined?\");\n            } else {\n                throw new MissingFieldException(fieldClass.getCanonicalName() + \" hasn't a field called: \" + fieldName + \".\");\n            }\n        }\n    });\n}\n```\n"]}
{"id": 6, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.cloudfoundry.identity.uaa.provider.oauth;\n\nimport org.cloudfoundry.identity.uaa.oauth.pkce.verifiers.S256PkceVerifier;\nimport org.cloudfoundry.identity.uaa.provider.AbstractExternalOAuthIdentityProviderDefinition;\nimport org.cloudfoundry.identity.uaa.provider.IdentityProvider;\nimport org.cloudfoundry.identity.uaa.provider.IdentityProviderProvisioning;\nimport org.cloudfoundry.identity.uaa.provider.OIDCIdentityProviderDefinition;\nimport org.cloudfoundry.identity.uaa.util.SessionUtils;\nimport org.cloudfoundry.identity.uaa.util.UaaRandomStringUtil;\nimport org.cloudfoundry.identity.uaa.util.UaaUrlUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.dao.IncorrectResultSizeDataAccessException;\nimport org.springframework.security.oauth2.common.util.RandomValueStringGenerator;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.ofNullable;\nimport static org.cloudfoundry.identity.uaa.constants.OriginKeys.OAUTH20;\nimport static org.cloudfoundry.identity.uaa.constants.OriginKeys.OIDC10;\n\npublic class ExternalOAuthProviderConfigurator implements IdentityProviderProvisioning {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(ExternalOAuthProviderConfigurator.class);\n\n    private final IdentityProviderProvisioning providerProvisioning;\n    private final OidcMetadataFetcher oidcMetadataFetcher;\n    private final UaaRandomStringUtil uaaRandomStringUtil;\n\n    public ExternalOAuthProviderConfigurator(\n            final @Qualifier(\"identityProviderProvisioning\") IdentityProviderProvisioning providerProvisioning,\n            final OidcMetadataFetcher oidcMetadataFetcher,\n            final UaaRandomStringUtil uaaRandomStringUtil) {\n        this.providerProvisioning = providerProvisioning;\n        this.oidcMetadataFetcher = oidcMetadataFetcher;\n        this.uaaRandomStringUtil = uaaRandomStringUtil;\n    }\n\n    protected OIDCIdentityProviderDefinition overlay(OIDCIdentityProviderDefinition definition) {\n        try {\n            oidcMetadataFetcher.fetchMetadataAndUpdateDefinition(definition);\n            return definition;\n        } catch (OidcMetadataFetchingException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Generates the authentication URL for an external OAuth identity provider.\n * \n * This method constructs the authentication URL for an external OAuth identity provider by appending query parameters to the base URL of the identity provider.\n * The parameters include the client ID, response type, redirect URI, state, and optional code challenge and code challenge method for PKCE, scopes, and nonce for OIDC.\n * \n * @param definition The definition of the external OAuth identity provider.\n * @param idpOriginKey The key identifying the origin of the identity provider.\n * @param request The HTTP servlet request.\n * @return The authentication URL for the external OAuth identity provider.\n * @throws IllegalArgumentException if the response type or relying party ID is null.\n */\n```\n\n### Code snippet:\n```Java\npublic String getIdpAuthenticationUrl(\n        final AbstractExternalOAuthIdentityProviderDefinition definition,\n        final String idpOriginKey,\n        final HttpServletRequest request) {\n    var idpUrlBase = getIdpUrlBase(definition);\n    var callbackUrl = getCallbackUrlForIdp(idpOriginKey, UaaUrlUtils.getBaseURL(request));\n    var responseType = URLEncoder.encode(definition.getResponseType(), StandardCharsets.UTF_8);\n    var relyingPartyId = definition.getRelyingPartyId();\n\n    var state = generateStateParam();\n    SessionUtils.setStateParam(request.getSession(), SessionUtils.stateParameterAttributeKeyForIdp(idpOriginKey), state);\n\n    UriComponentsBuilder uriBuilder = UriComponentsBuilder\n            .fromUriString(idpUrlBase)\n            .queryParam(\"client_id\", relyingPartyId)\n            .queryParam(\"response_type\", responseType)\n            .queryParam(\"redirect_uri\", callbackUrl)\n            .queryParam(\"state\", state);\n\n    // no client-secret, switch to PKCE and treat client as public, same logic is implemented in spring security\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getIdpAuthenticationUrl", "reference": "    // https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#initiating-the-authorization-request\n    if (definition.getRelyingPartySecret() == null) {\n        var pkceVerifier = new S256PkceVerifier();\n        var codeVerifier = generateCodeVerifier();\n        var codeChallenge = pkceVerifier.compute(codeVerifier);\n        SessionUtils.setStateParam(request.getSession(), SessionUtils.codeVerifierParameterAttributeKeyForIdp(idpOriginKey), codeVerifier);\n        uriBuilder.queryParam(\"code_challenge\", codeChallenge);\n        uriBuilder.queryParam(\"code_challenge_method\", pkceVerifier.getCodeChallengeMethod());\n    }\n\n    if (!CollectionUtils.isEmpty(definition.getScopes())) {\n        uriBuilder.queryParam(\"scope\", URLEncoder.encode(String.join(\" \", definition.getScopes()), StandardCharsets.UTF_8));\n    }\n\n    if (OIDCIdentityProviderDefinition.class.equals(definition.getParameterizedClass())) {\n        var nonceGenerator = new RandomValueStringGenerator(12);\n        uriBuilder.queryParam(\"nonce\", nonceGenerator.generate());\n    }\n\n    return uriBuilder.build().toUriString();\n}", "completions": ["```Java\n```Java\n    var clientSecret = definition.getClientSecret();\n    var codeChallenge = ofNullable(definition.getCodeChallenge())\n            .map(challenge -> URLEncoder.encode(challenge, StandardCharsets.UTF_8))\n            .orElse(null);\n    var codeChallengeMethod = ofNullable(definition.getCodeChallengeMethod())\n            .map(URLEncoder::encode)\n            .orElse(null);\n    var scopes = ofNullable(definition.getScopes())\n            .map(Arrays::toString)\n            .orElse(null);\n    var nonce = ofNullable(definition.getNonce())\n            .map(URLEncoder::encode)\n            .orElse(null);\n\n    uriBuilder.queryParam(\"client_secret\", clientSecret)\n            .queryParam(\"code_challenge\", codeChallenge)\n            .queryParam(\"code_challenge_method\", codeChallengeMethod)\n            .queryParam(\"scope\", scopes)\n            .queryParam(\"nonce\", nonce);\n\n    return uriBuilder.build().toString();\n}\n```\n```\n"]}
{"id": 7, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.jsoup.nodes;\n\nimport org.jsoup.helper.ChangeNotifyingArrayList;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\nimport org.jsoup.select.QueryParser;\nimport org.jsoup.select.Selector;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport static org.jsoup.internal.Normalizer.normalize;\n\n/**\n * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and\n * other elements).\n * \n * From an Element, you can extract data, traverse the node graph, and manipulate the HTML.\n * \n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Element extends Node {\n    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n    private Tag tag;\n    private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n    List<Node> childNodes;\n    private Attributes attributes;\n    private String baseUri;\n\n    /**\n     * Create a new, standalone element.\n     * @param tag tag name\n     */\n    public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }\n\n    /**\n     * Create a new, standalone Element. (Standalone in that is has no parent.)\n     * \n     * @param tag tag of this element\n     * @param baseUri the base URI\n     * @param attributes initial attributes\n     * @see #appendChild(Node)\n     * @see #appendElement(String)\n     */\n    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }\n    \n    /**\n     * Create a new Element from a tag and a base URI.\n     * \n     * @param tag element tag\n     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n     *            string, but not null.\n     * @see Tag#valueOf(String, ParseSettings)\n     */\n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the name of the tag for this element. E.g. {@code div}\n     * \n     * @return the tag name\n     */\n    public String tagName() {\n        return tag.getName();\n    }\n\n    /**\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     */\n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n    \n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    /**\n     * Clears the cached shadow child elements.\n     */\n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    /**\n     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n     * @return child text nodes. If this element has no text nodes, returns an\n     * empty list.\n     * </p>\n     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n     * <ul>\n     *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n     *     <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n     *     <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n     *     <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n     * </ul>\n     */\n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    /**\n     * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n     * </p>\n     * @return child data nodes. If this element has no data nodes, returns an\n     * empty list.\n     * @see #data()\n     */\n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    /**\n     * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n     * may include this element, or any of its children.\n     * <p>\n     * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n     * multiple filters can be combined, e.g.:\n     * </p>\n     * <ul>\n     * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n     * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n     * </ul>\n     * <p>\n     * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n     * </p>\n     * \n     * @param cssQuery a {@link Selector} CSS-like query\n     * @return elements that match the query (empty if none match)\n     * @see org.jsoup.select.Selector\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n     */\n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    /**\n     * Find the first Element that matches the {@link Selector} CSS query, with this element as the starting context.\n     * <p>This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query\n     * execution stops on the first hit.</p>\n     * @param cssQuery cssQuery a {@link Selector} CSS-like query\n     * @return the first matching element, or <b>{@code null}</b> if there is no match.\n     */\n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    /**\n     * Check if this element matches the given {@link Selector} CSS query.\n     * @param cssQuery a {@link Selector} CSS query\n     * @return if this element matches the query\n     */\n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    /**\n     * Check if this element matches the given evaluator.\n     * @param evaluator an element evaluator\n     * @return if this element matches\n     */\n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }\n    \n    /**\n     * Add a node child node to this element.\n     * \n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     */\n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        // was - Node#addChildren(child). short-circuits an array create and a loop.\n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    /**\n     * Add this element to the supplied parent element, as its next child.\n     *\n     * @param parent element to which this element will be appended\n     * @return this element, so that you can continue modifying the element\n     */\n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    /**\n     * Add a node to the start of this element's children.\n     * \n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     */\n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the last child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the first child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    /**\n     * Create and append a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    /**\n     * Create and prepend a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    /**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    /**\n     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n     *\n     * @param html HTML to add before this element\n     * @return this element, for chaining\n     * @see #after(String)\n     */\n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this element\n     * @return this Element, for chaining\n     * @see #after(Node)\n     */\n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this element (as a following sibling).\n     *\n     * @param html HTML to add after this element\n     * @return this element, for chaining\n     * @see #before(String)\n     */\n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this element\n     * @return this element, for chaining\n     * @see #before(Node)\n     */\n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    /**\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     */\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    /**\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     */\n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    /**\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * </p>\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     */\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    /**\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     */\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    /**\n     * Gets the first element sibling of this element.\n     * @return the first sibling that is an element (aka the parent's first element child) \n     */\n    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    /**\n     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        for (int i = 0; i < elements.size(); i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n     * use {@link Document#getElementById(String)}\n     * @param id The ID to search for.\n     * @return The first matching element by ID, starting with this element, or null if none found.\n     */\n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    /**\n     * Find elements that have this class, including or under this element. Case insensitive.\n     * <p>\n     * Elements can have multiple classes (e.g. {@code <div class=\"header round first\">}. This method\n     * checks each class, so you can find the above with {@code el.getElementsByClass(\"header\");}.\n     * \n     * @param className the name of the class to search for.\n     * @return elements with the supplied class name, empty if none\n     * @see #hasClass(String)\n     * @see #classNames()\n     */\n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    /**\n     * Find elements that have a named attribute set. Case insensitive.\n     *\n     * @param key name of the attribute, e.g. {@code href}\n     * @return elements that have this attribute, empty if none\n     */\n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    /**\n     * Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements\n     * that have HTML5 datasets.\n     * @param keyPrefix name prefix of the attribute e.g. {@code data-}\n     * @return elements that have attribute names that start with with the prefix, empty if none.\n     */\n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    /**\n     * Find elements that have an attribute with the specific value. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that have this attribute with this value, empty if none\n     */\n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    /**\n     * Find elements that either do not have this attribute, or have it with a different value. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that do not have a matching attribute\n     */\n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    /**\n     * Find elements that have attributes that start with the value prefix. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param valuePrefix start of attribute value\n     * @return elements that have attributes that start with the value prefix\n     */\n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    /**\n     * Find elements that have attributes that end with the value suffix. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param valueSuffix end of the attribute value\n     * @return elements that have attributes that end with the value suffix\n     */\n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    /**\n     * Find elements that have attributes whose value contains the match string. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param match substring of value to search for\n     * @return elements that have attributes containing this text\n     */\n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    /**\n     * Find elements that have attributes whose values match the supplied regular expression.\n     * @param key name of the attribute\n     * @param pattern compiled regular expression to match against attribute values\n     * @return elements that have attributes matching this regular expression\n     */\n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    /**\n     * Find elements that have attributes whose values match the supplied regular expression.\n     * @param key name of the attribute\n     * @param regex regular expression to match against attribute values. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements that have attributes matching this regular expression\n     */\n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    /**\n     * Find elements whose sibling index is less than the supplied index.\n     * @param index 0-based index\n     * @return elements less than index\n     */\n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    /**\n     * Find elements whose sibling index is greater than the supplied index.\n     * @param index 0-based index\n     * @return elements greater than index\n     */\n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    /**\n     * Find elements whose sibling index is equal to the supplied index.\n     * @param index 0-based index\n     * @return elements equal to index\n     */\n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    /**\n     * Find elements that contain the specified string. The search is case insensitive. The text may appear directly\n     * in the element, or in any of its descendants.\n     * @param searchText to look for in the element's text\n     * @return elements that contain the string, case insensitive.\n     * @see Element#text()\n     */\n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    /**\n     * Find elements that directly contain the specified string. The search is case insensitive. The text must appear directly\n     * in the element, not in any of its descendants.\n     * @param searchText to look for in the element's own text\n     * @return elements that contain the string, case insensitive.\n     * @see Element#ownText()\n     */\n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    /**\n     * Find elements whose text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     */\n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    /**\n     * Find elements whose text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     */\n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    /**\n     * Find elements whose own text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     */\n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    /**\n     * Find elements whose text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     */\n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    /**\n     * Find all elements under this element (including self, and children of children).\n     * \n     * @return all elements\n     */\n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    /**\n     * Gets the combined text of this element and all its children. Whitespace is normalized and trimmed.\n     * <p>\n     * For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code \"Hello there now!\"}\n     *\n     * @return unencoded text, or empty string if none.\n     * @see #ownText()\n     * @see #textNodes()\n     */\n```\n\n### Code description\n```Java\n/**\n * This method returns a string representation of the text content of the HTML document.\n * It uses the NodeTraversor.traverse method from the org.jsoup.select package to traverse the document.\n * During the traversal, it checks if the current node is a TextNode or an Element.\n * If it's a TextNode, it appends the normalized text to the accumulator.\n * If it's an Element, it checks if the accumulator is not empty, the element is a block element, or the element's tag name is \"br\".\n * If any of these conditions are met and the last character in the accumulator is not a whitespace, it appends a space to the accumulator.\n * Finally, it returns the accumulated text after trimming leading and trailing whitespaces.\n *\n * @return A string representation of the text content of the HTML document.\n */\n```\n\n### Code snippet:\n```Java\npublic String text() {\n    final StringBuilder accum = new StringBuilder();\n    NodeTraversor.traverse(new NodeVisitor() {\n        public void head(Node node, int depth) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "text", "reference": "                    (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                    !TextNode.lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n        }\n\n        public void tail(Node node, int depth) {\n        }\n    }, this);\n    return accum.toString().trim();\n}", "completions": ["```markdown\n```java\n/**\n * This method returns a string representation of the text content of the HTML document.\n * It uses the NodeTraversor.traverse method from the org.jsoup.select package to traverse the document.\n * During the traversal, it checks if the current node is a TextNode or an Element.\n * If it's a TextNode, it appends the normalized text to the accumulator.\n * If it's an Element, it checks if the accumulator is not empty, the element is a block element, or the element's tag name is \"br\".\n * If any of these conditions are met and the last character in the accumulator is not a whitespace, it appends a space to the accumulator.\n * Finally, it returns the accumulated text after trimming leading and trailing whitespaces.\n *\n * @return A string representation of the text content of the HTML document.\n */\npublic String text() {\n    final StringBuilder accum = new StringBuilder();\n    NodeTraversor.traverse(new NodeVisitor() {\n        public void head(Node node, int depth) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n                        !element.isBlock() &&\n                        !element.tagName().equals(\"br\")) {\n                    accum.append(' ');\n                }\n                accum.append(element.text());\n            }\n        }\n    });\n    return accum.toString().trim();\n}\n```\n```\n"]}
{"id": 8, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.apache.archiva.repository.content.maven2;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.archiva.model.ArtifactReference;\nimport org.apache.archiva.repository.ManagedRepositoryContent;\nimport org.apache.archiva.repository.content.PathParser;\nimport org.apache.archiva.repository.layout.LayoutException;\nimport org.apache.archiva.repository.metadata.MetadataTools;\nimport org.apache.commons.lang.StringUtils;\n\n/**\n * RepositoryRequest is used to determine the type of request that is incoming, and convert it to an appropriate\n * ArtifactReference.\n */\npublic class RepositoryRequest\n{\n    private PathParser defaultPathParser = new DefaultPathParser();\n\n    public RepositoryRequest()\n    {\n        // no op\n    }\n\n    /**\n     * Takes an incoming requested path (in \"/\" format) and gleans the layout\n     * and ArtifactReference appropriate for that content.\n     *\n     * @param requestedPath the relative path to the content.\n     * @return the ArtifactReference for the requestedPath.\n     * @throws org.apache.archiva.repository.layout.LayoutException if the request path is not layout valid.\n     */\n    public ArtifactReference toArtifactReference( String requestedPath )\n        throws LayoutException\n    {\n        if ( StringUtils.isBlank( requestedPath ) )\n        {\n            throw new LayoutException( \"Blank request path is not a valid.\" );\n        }\n\n        String path = requestedPath;\n        while ( path.startsWith( \"/\" ) )\n        {\n            path = path.substring( 1 );\n\n            // Only slash? that's bad, mmm-kay?\n            if ( \"/\".equals( path ) )\n            {\n                throw new LayoutException( \"Invalid request path: Slash only.\" );\n            }\n        }\n\n        if ( isDefault( path ) )\n        {\n            return defaultPathParser.toArtifactReference( path );\n        }\n        else if ( isLegacy( path ) )\n        {\n            throw new LayoutException( \"Legacy Maven1 repository not supported anymore.\" );\n        }\n        else\n        {\n            throw new LayoutException( \"Not a valid request path layout, too short.\" );\n        }\n    }\n\n    /**\n     * <p>\n     * Tests the path to see if it conforms to the expectations of a metadata request.\n     * </p>\n     * <p>\n     * NOTE: This does a cursory check on the path's last element.  A result of true\n     * from this method is not a guarantee that the metadata is in a valid format, or\n     * that it even contains data.\n     * </p>\n     *\n     * @param requestedPath the path to test.\n     * @return true if the requestedPath is likely a metadata request.\n     */\n    public boolean isMetadata( String requestedPath )\n    {\n        return requestedPath.endsWith( \"/\" + MetadataTools.MAVEN_METADATA );\n    }\n\n    /**\n     * @param requestedPath\n     * @return true if the requestedPath is likely an archetype catalog request.\n     */\n    public boolean isArchetypeCatalog( String requestedPath )\n    {\n        return requestedPath.endsWith( \"/\" + MetadataTools.MAVEN_ARCHETYPE_CATALOG );\n    }\n\n    /**\n     * <p>\n     * Tests the path to see if it conforms to the expectations of a support file request.\n     * </p>\n     * <p>\n     * Tests for <code>.sha1</code>, <code>.md5</code>, <code>.asc</code>, and <code>.php</code>.\n     * </p>\n     * <p>\n     * NOTE: This does a cursory check on the path's extension only.  A result of true\n     * from this method is not a guarantee that the support resource is in a valid format, or\n     * that it even contains data.\n     * </p>\n     *\n     * @param requestedPath the path to test.\n     * @return true if the requestedPath is likely that of a support file request.\n     */\n    public boolean isSupportFile( String requestedPath )\n    {\n        int idx = requestedPath.lastIndexOf( '.' );\n        if ( idx <= 0 )\n        {\n            return false;\n        }\n\n        String ext = requestedPath.substring( idx );\n        return ( \".sha1\".equals( ext ) || \".md5\".equals( ext ) || \".asc\".equals( ext ) || \".pgp\".equals( ext ) );\n    }\n\n    public boolean isMetadataSupportFile( String requestedPath )\n    {\n        if ( isSupportFile( requestedPath ) )\n        {\n            String basefilePath = StringUtils.substring( requestedPath, 0, requestedPath.lastIndexOf( '.' ) );\n            if ( isMetadata( basefilePath ) )\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * <p>\n     * Tests the path to see if it conforms to the expectations of a default layout request.\n     * </p>\n     * <p>\n     * NOTE: This does a cursory check on the count of path elements only.  A result of\n     * true from this method is not a guarantee that the path sections are valid and\n     * can be resolved to an artifact reference.  use {@link #toArtifactReference(String)}\n     * if you want a more complete analysis of the validity of the path.\n     * </p>\n     *\n     * @param requestedPath the path to test.\n     * @return true if the requestedPath is likely that of a default layout request.\n     */\n```\n\n### Code description\n```Java\n/**\n * Checks if the given path is a default path.\n *\n * @param requestedPath The path to check.\n * @return True if the path is default, false otherwise.\n *\n * This method uses the StringUtils.isBlank method from the Apache Commons Lang library to check if the requestedPath is blank.\n * If the requestedPath is blank, it returns false.\n * The path is split into parts using StringUtils.splitPreserveAllTokens method.\n * If the number of parts is more than 3, it returns true.\n * If the number of parts is 3, it checks if the path is a metadata file or a checksum of a metadata file.\n * If the path is a metadata file or a checksum of a metadata file, it returns true. Otherwise, it returns false.\n * If the number of parts is less than 3, it returns false.\n */\n```\n\n### Code snippet:\n```Java\npublic boolean isDefault( String requestedPath )\n{\n    if ( StringUtils.isBlank( requestedPath ) )\n    {\n        return false;\n    }\n\n    String pathParts[] = StringUtils.splitPreserveAllTokens( requestedPath, '/' );\n    if ( pathParts.length > 3 )\n    {\n        return true;\n    }\n    else if ( pathParts.length == 3 )\n    {\n        // check if artifact-level metadata (ex. eclipse/jdtcore/maven-metadata.xml)\n        if ( isMetadata( requestedPath ) )\n        {\n            return true;\n        }\n        else\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "isDefault", "reference": "        {\n            // check if checksum of artifact-level metadata (ex. eclipse/jdtcore/maven-metadata.xml.sha1)\n            int idx = requestedPath.lastIndexOf( '.' );\n            if ( idx > 0 )\n            {\n                String base = requestedPath.substring( 0, idx );\n                if ( isMetadata( base ) && isSupportFile( requestedPath ) )\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n    else\n    {\n        return false;\n    }\n}", "completions": ["```Java\n```Java\n        return true;\n    }\n\n    return false;\n}\n```\n"]}
{"id": 9, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2015-2017 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hawkular.apm.server.api.utils.zipkin;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\nimport org.apache.http.impl.EnglishReasonPhraseCatalog;\nimport org.hawkular.apm.api.model.Constants;\nimport org.hawkular.apm.server.api.model.zipkin.BinaryAnnotation;\nimport org.hawkular.apm.server.api.model.zipkin.Span;\n\n/**\n * @author Pavol Loffay\n */\npublic class SpanHttpDeriverUtil {\n    private static final Logger log = Logger.getLogger(SpanHttpDeriverUtil.class.getName());\n\n    private static final Set<String> HTTP_METHODS = Collections.unmodifiableSet(\n            new HashSet<>(Arrays.asList(\"GET\", \"PUT\", \"POST\", \"DELETE\", \"HEAD\", \"TRACE\", \"OPTIONS\")));\n\n\n    private SpanHttpDeriverUtil() {}\n\n    /**\n     * Method returns list of http status codes.\n     *\n     * @param binaryAnnotations zipkin binary annotations\n     * @return http status codes\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method retrieves a list of HTTP status codes from a list of binary annotations.\n * It iterates over the binary annotations, checks if the key matches the HTTP status code key and if the value is not null.\n * If the key and value are valid, it converts the value to an integer and retrieves the English description of the HTTP status code using the getReason method of the EnglishReasonPhraseCatalog.\n * If the HTTP status code is valid, it creates a new HttpCode object with the code and description and adds it to the list of HTTP codes.\n *\n * @param binaryAnnotations The list of binary annotations to process.\n * @return A list of HttpCode objects representing the HTTP status codes found in the binary annotations.\n */\n```\n\n### Code snippet:\n```Java\npublic static List<HttpCode> getHttpStatusCodes(List<BinaryAnnotation> binaryAnnotations) {\n    if (binaryAnnotations == null) {\n        return Collections.emptyList();\n    }\n\n    List<HttpCode> httpCodes = new ArrayList<>();\n\n    for (BinaryAnnotation binaryAnnotation: binaryAnnotations) {\n        if (Constants.ZIPKIN_BIN_ANNOTATION_HTTP_STATUS_CODE.equals(binaryAnnotation.getKey()) &&\n                binaryAnnotation.getValue() != null) {\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getHttpStatusCodes", "reference": "            String strHttpCode = binaryAnnotation.getValue();\n            Integer httpCode = toInt(strHttpCode.trim());\n\n            if (httpCode != null) {\n                String description = EnglishReasonPhraseCatalog.INSTANCE.getReason(httpCode, Locale.ENGLISH);\n                httpCodes.add(new HttpCode(httpCode, description));\n            }\n        }\n\n    }\n    return httpCodes;\n}", "completions": ["```Java\n            int httpStatusCode = Integer.parseInt(binaryAnnotation.getValue().toString());\n            String httpStatusDescription = EnglishReasonPhraseCatalog.INSTANCE.getReason(httpStatusCode);\n\n            if (httpStatusCode >= 100 && httpStatusCode < 600 && HTTP_METHODS.contains(binaryAnnotation.getKey())) {\n                HttpCode httpCode = new HttpCode(httpStatusCode, httpStatusDescription);\n                httpCodes.add(httpCode);\n            }\n        }\n    }\n\n    return httpCodes;\n}\n```\n"]}
{"id": 10, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.config.utils;\n\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.config.ReferenceConfigBase;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\nimport org.apache.dubbo.rpc.service.Destroyable;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * A simple util class for cache {@link ReferenceConfigBase}.\n * <p>\n * {@link ReferenceConfigBase} is a heavy Object, it's necessary to cache these object\n * for the framework which create {@link ReferenceConfigBase} frequently.\n * <p>\n * You can implement and use your own {@link ReferenceConfigBase} cache if you need use complicate strategy.\n */\npublic class ReferenceConfigCache {\n    public static final String DEFAULT_NAME = \"_DEFAULT_\";\n    /**\n     * Create the key with the <b>Group</b>, <b>Interface</b> and <b>version</b> attribute of {@link ReferenceConfigBase}.\n     * <p>\n     * key example: <code>group1/org.apache.dubbo.foo.FooService:1.0.0</code>.\n     */\n    public static final KeyGenerator DEFAULT_KEY_GENERATOR = referenceConfig -> {\n        String iName = referenceConfig.getInterface();\n        if (StringUtils.isBlank(iName)) {\n            Class<?> clazz = referenceConfig.getInterfaceClass();\n            iName = clazz.getName();\n        }\n        if (StringUtils.isBlank(iName)) {\n            throw new IllegalArgumentException(\"No interface info in ReferenceConfig\" + referenceConfig);\n        }\n\n        StringBuilder ret = new StringBuilder();\n        if (!StringUtils.isBlank(referenceConfig.getGroup())) {\n            ret.append(referenceConfig.getGroup()).append(\"/\");\n        }\n        ret.append(iName);\n        if (!StringUtils.isBlank(referenceConfig.getVersion())) {\n            ret.append(\":\").append(referenceConfig.getVersion());\n        }\n        return ret.toString();\n    };\n\n    static final ConcurrentMap<String, ReferenceConfigCache> CACHE_HOLDER = new ConcurrentHashMap<String, ReferenceConfigCache>();\n    private final String name;\n    private final KeyGenerator generator;\n\n    private final ConcurrentMap<String, ReferenceConfigBase<?>> referredReferences = new ConcurrentHashMap<>();\n\n    private final ConcurrentMap<Class<?>, ConcurrentMap<String, Object>> proxies = new ConcurrentHashMap<>();\n\n    private ReferenceConfigCache(String name, KeyGenerator generator) {\n        this.name = name;\n        this.generator = generator;\n    }\n\n    /**\n     * Get the cache use default name and {@link #DEFAULT_KEY_GENERATOR} to generate cache key.\n     * Create cache if not existed yet.\n     */\n    public static ReferenceConfigCache getCache() {\n        return getCache(DEFAULT_NAME);\n    }\n\n    /**\n     * Get the cache use specified name and {@link KeyGenerator}.\n     * Create cache if not existed yet.\n     */\n    public static ReferenceConfigCache getCache(String name) {\n        return getCache(name, DEFAULT_KEY_GENERATOR);\n    }\n\n    /**\n     * Get the cache use specified {@link KeyGenerator}.\n     * Create cache if not existed yet.\n     */\n    public static ReferenceConfigCache getCache(String name, KeyGenerator keyGenerator) {\n        return CACHE_HOLDER.computeIfAbsent(name, k -> new ReferenceConfigCache(k, keyGenerator));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(ReferenceConfigBase<T> referenceConfig) {\n        String key = generator.generateKey(referenceConfig);\n        Class<?> type = referenceConfig.getInterfaceClass();\n\n        proxies.computeIfAbsent(type, _t -> new ConcurrentHashMap<>());\n\n        ConcurrentMap<String, Object> proxiesOfType = proxies.get(type);\n        proxiesOfType.computeIfAbsent(key, _k -> {\n            Object proxy = referenceConfig.get();\n            referredReferences.put(key, referenceConfig);\n            return proxy;\n        });\n\n        return (T) proxiesOfType.get(key);\n    }\n\n    /**\n     * Fetch cache with the specified key. The key is decided by KeyGenerator passed-in. If the default KeyGenerator is\n     * used, then the key is in the format of <code>group/interfaceClass:version</code>\n     *\n     * @param key  cache key\n     * @param type object class\n     * @param <T>  object type\n     * @return object from the cached ReferenceConfigBase\n     * @see KeyGenerator#generateKey(ReferenceConfigBase)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(String key, Class<T> type) {\n        Map<String, Object> proxiesOfType = proxies.get(type);\n        if (CollectionUtils.isEmptyMap(proxiesOfType)) {\n            return null;\n        }\n        return (T) proxiesOfType.get(key);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(String key) {\n        ReferenceConfigBase<?> rc = referredReferences.get(key);\n        if (rc == null) {\n            return null;\n        }\n\n        return (T) get(key, rc.getInterfaceClass());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> List<T> getAll(Class<T> type) {\n        Map<String, Object> proxiesOfType = proxies.get(type);\n        if (CollectionUtils.isEmptyMap(proxiesOfType)) {\n            return Collections.emptyList();\n        }\n\n        List<T> proxySet = new ArrayList<>();\n        proxiesOfType.values().forEach(obj -> proxySet.add((T) obj));\n        return proxySet;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(Class<T> type) {\n        Map<String, Object> proxiesOfType = proxies.get(type);\n        if (CollectionUtils.isEmptyMap(proxiesOfType)) {\n            return null;\n        }\n\n        return (T) proxiesOfType.values().iterator().next();\n    }\n\n    public void destroy(String key, Class<?> type) {\n        ReferenceConfigBase<?> rc = referredReferences.remove(key);\n        if (rc == null) {\n            return;\n        }\n\n        ApplicationModel.getConfigManager().removeConfig(rc);\n        rc.destroy();\n\n        Map<String, Object> proxiesOftype = proxies.get(type);\n        if (CollectionUtils.isNotEmptyMap(proxiesOftype)) {\n            proxiesOftype.remove(key);\n            if (proxiesOftype.isEmpty()) {\n                proxies.remove(type);\n            }\n        }\n    }\n\n    public void destroy(Class<?> type) {\n        Map<String, Object> proxiesOfType = proxies.remove(type);\n        proxiesOfType.forEach((k, v) -> {\n            ReferenceConfigBase rc = referredReferences.remove(k);\n            rc.destroy();\n        });\n    }\n\n    /**\n     * clear and destroy one {@link ReferenceConfigBase} in the cache.\n     *\n     * @param referenceConfig use for create key.\n     */\n    public <T> void destroy(ReferenceConfigBase<T> referenceConfig) {\n        String key = generator.generateKey(referenceConfig);\n        Class<?> type = referenceConfig.getInterfaceClass();\n\n        destroy(key, type);\n    }\n\n    /**\n     * clear and destroy all {@link ReferenceConfigBase} in the cache.\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method destroys all references and proxies.\n * It first checks if the referredReferences map is empty. If it is, the method returns immediately.\n * If the referredReferences map is not empty, it iterates over each entry in the map, calling the destroy method on the referenceConfig and removing the config from the ApplicationModel's config manager.\n * It then iterates over each entry in the proxies map, casting the value to a Destroyable and calling the $destroy method.\n * Finally, it clears both the referredReferences and proxies maps.\n *\n * @param referredReferences A map of reference configurations.\n * @param proxies A map of proxy objects.\n * @see org.apache.dubbo.rpc.model.ApplicationModel#getConfigManager()\n */\n```\n\n### Code snippet:\n```Java\npublic void destroyAll() {\n    if (CollectionUtils.isEmptyMap(referredReferences)) {\n        return;\n    }\n\n    referredReferences.forEach((_k, referenceConfig) -> {\n        referenceConfig.destroy();\n        ApplicationModel.getConfigManager().removeConfig(referenceConfig);\n    });\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "destroyAll", "reference": "    proxies.forEach((_type, proxiesOfType) -> {\n        proxiesOfType.forEach((_k, v) -> {\n            Destroyable proxy = (Destroyable) v;\n            proxy.$destroy();\n        });\n    });\n\n    referredReferences.clear();\n    proxies.clear();\n}", "completions": ["```Java\n```Java\npublic void destroyAll() {\n    if (CollectionUtils.isEmptyMap(referredReferences)) {\n        return;\n    }\n\n    referredReferences.forEach((_k, referenceConfig) -> {\n        referenceConfig.destroy();\n        ApplicationModel.getConfigManager().removeConfig(referenceConfig);\n    });\n\n    proxies.values().forEach(proxiesOfType -> {\n        proxiesOfType.forEach((_k, proxy) -> {\n            if (proxy instanceof Destroyable) {\n                ((Destroyable) proxy).destroy();\n            }\n        });\n    });\n\n    referredReferences.clear();\n    proxies.clear();\n}\n```\n```\n"]}
{"id": 11, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.dubbo.rpc.filter;\n\nimport com.alibaba.dubbo.common.Constants;\nimport com.alibaba.dubbo.common.extension.Activate;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.dubbo.common.logger.Logger;\nimport com.alibaba.dubbo.common.logger.LoggerFactory;\nimport com.alibaba.dubbo.common.utils.ConcurrentHashSet;\nimport com.alibaba.dubbo.common.utils.ConfigUtils;\nimport com.alibaba.dubbo.common.utils.NamedThreadFactory;\nimport com.alibaba.dubbo.rpc.Filter;\nimport com.alibaba.dubbo.rpc.Invocation;\nimport com.alibaba.dubbo.rpc.Invoker;\nimport com.alibaba.dubbo.rpc.Result;\nimport com.alibaba.dubbo.rpc.RpcContext;\nimport com.alibaba.dubbo.rpc.RpcException;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Record access log for the service.\n * <p>\n * Logger key is <code><b>dubbo.accesslog</b></code>.\n * In order to configure access log appear in the specified appender only, additivity need to be configured in log4j's\n * config file, for example:\n * <code>\n * <pre>\n * &lt;logger name=\"<b>dubbo.accesslog</b>\" <font color=\"red\">additivity=\"false\"</font>&gt;\n *    &lt;level value=\"info\" /&gt;\n *    &lt;appender-ref ref=\"foo\" /&gt;\n * &lt;/logger&gt;\n * </pre></code>\n */\n@Activate(group = Constants.PROVIDER, value = Constants.ACCESS_LOG_KEY)\npublic class AccessLogFilter implements Filter {\n\n    private static final Logger logger = LoggerFactory.getLogger(AccessLogFilter.class);\n\n    private static final String ACCESS_LOG_KEY = \"dubbo.accesslog\";\n\n    private static final String FILE_DATE_FORMAT = \"yyyyMMdd\";\n\n    private static final String MESSAGE_DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    private static final int LOG_MAX_BUFFER = 5000;\n\n    private static final long LOG_OUTPUT_INTERVAL = 5000;\n\n    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();\n\n    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(\"Dubbo-Access-Log\", true));\n\n    private volatile ScheduledFuture<?> logFuture = null;\n\n    private void init() {\n        if (logFuture == null) {\n            synchronized (logScheduled) {\n                if (logFuture == null) {\n                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);\n                }\n            }\n        }\n    }\n\n    private void log(String accesslog, String logmessage) {\n        init();\n        Set<String> logSet = logQueue.get(accesslog);\n        if (logSet == null) {\n            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());\n            logSet = logQueue.get(accesslog);\n        }\n        if (logSet.size() < LOG_MAX_BUFFER) {\n            logSet.add(logmessage);\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * This method is used to invoke a remote service and log the access details.\n * It uses the com.alibaba.fastjson.JSON.toJSONString method to convert the arguments to a JSON string.\n * It also uses the com.alibaba.dubbo.common.logger.LoggerFactory.getLogger method to get a logger for logging the access details.\n *\n * @param invoker The invoker object that contains the details of the remote service.\n * @param inv The invocation object that contains the details of the method invocation.\n * @return The result of the method invocation.\n * @throws RpcException If there is an error during the remote procedure call.\n */\n```\n\n### Code snippet:\n```Java\npublic Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n    try {\n        String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);\n        if (ConfigUtils.isNotEmpty(accesslog)) {\n            RpcContext context = RpcContext.getContext();\n            String serviceName = invoker.getInterface().getName();\n            String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);\n            StringBuilder sn = new StringBuilder();\n            sn.append(\"[\").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(\"] \").append(context.getRemoteHost()).append(\":\").append(context.getRemotePort())\n                    .append(\" -> \").append(context.getLocalHost()).append(\":\").append(context.getLocalPort())\n                    .append(\" - \");\n            if (null != group && group.length() > 0) {\n                sn.append(group).append(\"/\");\n            }\n            sn.append(serviceName);\n            if (null != version && version.length() > 0) {\n                sn.append(\":\").append(version);\n            }\n            sn.append(\" \");\n            sn.append(inv.getMethodName());\n            sn.append(\"(\");\n            Class<?>[] types = inv.getParameterTypes();\n            if (types != null && types.length > 0) {\n                boolean first = true;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "invoke", "reference": "                for (Class<?> type : types) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        sn.append(\",\");\n                    }\n                    sn.append(type.getName());\n                }\n            }\n            sn.append(\") \");\n            Object[] args = inv.getArguments();\n            if (args != null && args.length > 0) {\n                sn.append(JSON.toJSONString(args));\n            }\n            String msg = sn.toString();\n            if (ConfigUtils.isDefault(accesslog)) {\n                LoggerFactory.getLogger(ACCESS_LOG_KEY + \".\" + invoker.getInterface().getName()).info(msg);\n            } else {\n                log(accesslog, msg);\n            }\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Exception in AcessLogFilter of service(\" + invoker + \" -> \" + inv + \")\", t);\n    }\n    return invoker.invoke(inv);\n}", "completions": ["```Java\npublic Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n    try {\n        String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);\n        if (ConfigUtils.isNotEmpty(accesslog)) {\n            RpcContext context = RpcContext.getContext();\n            String serviceName = invoker.getInterface().getName();\n            String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);\n            StringBuilder sn = new StringBuilder();\n            sn.append(\"[\").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(\"] \").append(context.getRemoteHost()).append(\":\").append(context.getRemotePort())\n                    .append(\" -> \").append(context.getLocalHost()).append(\":\").append(context.getLocalPort())\n                    .append(\" - \");\n            if (null != group && group.length() > 0) {\n                sn.append(group).append(\"/\");\n            }\n            sn.append(serviceName);\n            if (null != version && version.length() > 0) {\n                sn.append(\":\").append(version);\n            }\n            sn.append(\" \");\n            sn.append(inv.getMethodName());\n            sn.append(\"(\");\n            Class<?>[] types = inv.getParameterTypes();\n            if (types != null && types.length > 0) {\n                boolean first = true;\n                for (Class<?> type : types) {\n                    if (!first) {\n                        sn.append(\", \");\n                    }\n                    sn.append(type.getName());\n                    first = false;\n                }\n            }\n            sn.append(\")\");\n            String params = JSON.toJSONString(inv.getParameters());\n            if (ConfigUtils.isNotEmpty(params)) {\n                sn.append(\" - \").append(params);\n            }\n            logger.info(sn.toString());\n        }\n        return invoker.invoke(inv);\n    } catch (Exception e) {\n        logger.error(\"Error in invoking \" + invoker.getInterface().getName() + \".\" + inv.getMethodName(), e);\n        throw new RpcException(e.getMessage(), e);\n    }\n}\n```\n"]}
{"id": 12, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright 2016 Twitter. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.twitter.graphjet.algorithms.salsa;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\nimport com.google.common.collect.Lists;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.twitter.graphjet.algorithms.ConnectingUsersWithMetadata;\nimport com.twitter.graphjet.algorithms.NodeInfo;\nimport com.twitter.graphjet.algorithms.RecommendationInfo;\nimport com.twitter.graphjet.algorithms.RecommendationRequest;\nimport com.twitter.graphjet.algorithms.TweetIDMask;\nimport com.twitter.graphjet.algorithms.counting.tweet.TweetRecommendationInfo;\nimport com.twitter.graphjet.bipartite.api.LeftIndexedBipartiteGraph;\nimport com.twitter.graphjet.hashing.SmallArrayBasedLongToDoubleMap;\n\nimport it.unimi.dsi.fastutil.longs.LongArrayList;\n\n/**\n * This class selects the top recommendations from a SALSA run.\n */\npublic class SalsaSelectResults<T extends LeftIndexedBipartiteGraph> {\n  private static final Logger LOG = LoggerFactory.getLogger(\"graph\");\n  private static final TweetIDMask TWEET_ID_MASK = new TweetIDMask();\n\n  private final CommonInternalState<T> salsaInternalState;\n  private final SalsaStats salsaStats;\n\n  /**\n   * Default constructor that requires a {@link CommonInternalState} populated with visited\n   * information to extract recommendations.\n   *\n   * @param salsaInternalState  is the state populated with visited information\n   */\n  public SalsaSelectResults(CommonInternalState<T> salsaInternalState) {\n    this.salsaInternalState = salsaInternalState;\n    this.salsaStats = salsaInternalState.getSalsaStats();\n  }\n\n  /**\n   * Picks the top-k visited nodes in SALSA.\n   */\n```\n\n### Code description\n```Java\n/**\n * Description: This method picks the top nodes based on their weight and filters them if necessary.\n * It also calculates the social proofs for each node and logs the statistics of the SALSA algorithm.\n *\n * @param salsaInternalState The internal state of the SALSA algorithm.\n * @return SalsaResponse The response containing the list of top recommendations and the SALSA statistics.\n * @throws IllegalArgumentException If the salsaInternalState is null.\n * @see com.google.common.collect.Lists#newArrayListWithCapacity(int)\n */\n```\n\n### Code snippet:\n```Java\npublic SalsaResponse pickTopNodes() {\n  int maxNumResults = Math.min(salsaInternalState.getSalsaRequest().getMaxNumResults(),\n    RecommendationRequest.MAX_RECOMMENDATION_RESULTS);\n  PriorityQueue<NodeInfo> topResults = new PriorityQueue<NodeInfo>(maxNumResults);\n\n  int numFilteredNodes = 0;\n  for (NodeInfo nodeInfo : salsaInternalState.getVisitedRightNodes().values()) {\n    if (salsaInternalState.getSalsaRequest().filterResult(\n      nodeInfo.getNodeId(),\n      nodeInfo.getSocialProofs())\n    ) {\n      numFilteredNodes++;\n      continue;\n    }\n    nodeInfo.setWeight(\n        nodeInfo.getWeight() / salsaInternalState.getSalsaStats().getNumRHSVisits());\n    addResultToPriorityQueue(topResults, nodeInfo, maxNumResults);\n  }\n\n  List<RecommendationInfo> outputResults =\n      Lists.newArrayListWithCapacity(topResults.size());\n\n  byte[] validSocialProofs = salsaInternalState.getSalsaRequest().getSocialProofTypes();\n\n  while (!topResults.isEmpty()) {\n    NodeInfo nodeInfo = topResults.poll();\n    outputResults.add(\n      new TweetRecommendationInfo(\n        TWEET_ID_MASK.restore(nodeInfo.getNodeId()),\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "pickTopNodes", "reference": "        nodeInfo.getWeight(),\n        pickTopSocialProofs(nodeInfo.getSocialProofs(), validSocialProofs)));\n  }\n  Collections.reverse(outputResults);\n\n  salsaStats.setNumRightNodesFiltered(numFilteredNodes);\n  salsaStats.setNumRightNodesReached(salsaInternalState.getVisitedRightNodes().size());\n\n  LOG.info(\"SALSA: after running iterations for request_id = \"\n      + salsaInternalState.getSalsaRequest().getQueryNode()\n      + \", we get numSeedNodes = \"\n      + salsaStats.getNumSeedNodes()\n      + \", numDirectNeighbors = \"\n      + salsaStats.getNumDirectNeighbors()\n      + \", numRHSVisits = \"\n      + salsaStats.getNumRHSVisits()\n      + \", numRightNodesReached = \"\n      + salsaStats.getNumRightNodesReached()\n      + \", numRightNodesFiltered = \"\n      + salsaStats.getNumRightNodesFiltered()\n      + \", minVisitsPerRightNode = \"\n      + salsaStats.getMinVisitsPerRightNode()\n      + \", maxVisitsPerRightNode = \"\n      + salsaStats.getMaxVisitsPerRightNode()\n      + \", numOutputResults = \"\n      + outputResults.size()\n  );\n\n  return new SalsaResponse(outputResults, salsaStats);\n}", "completions": ["```Java\n        RecommendationInfo.Type.valueOf(nodeInfo.getType()),\n        nodeInfo.getWeight(),\n        nodeInfo.getSocialProofs(),\n        validSocialProofs\n      )\n    );\n  }\n\n  return new SalsaResponse(\n    outputResults,\n    salsaInternalState.getSalsaStats().getNumRHSVisits(),\n    salsaInternalState.getSalsaStats().getNumLHSVisits()\n  );\n}\n\nprivate void addResultToPriorityQueue(\n  PriorityQueue<NodeInfo> topResults, NodeInfo nodeInfo, int maxNumResults) {\n  if (topResults.size() < maxNumResults) {\n    topResults.add(nodeInfo);\n  } else if (nodeInfo.getWeight() > topResults.peek().getWeight()) {\n    topResults.poll();\n    topResults.add(nodeInfo);\n  }\n}\n```\n"]}
{"id": 13, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.dtstack.flink.sql.side.kudu;\n\nimport com.dtstack.flink.sql.side.AbstractSideTableInfo;\nimport com.dtstack.flink.sql.side.BaseAllReqRow;\nimport com.dtstack.flink.sql.side.FieldInfo;\nimport com.dtstack.flink.sql.side.JoinInfo;\nimport com.dtstack.flink.sql.side.PredicateInfo;\nimport com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;\nimport com.dtstack.flink.sql.side.kudu.utils.KuduUtil;\nimport com.dtstack.flink.sql.util.KrbUtils;\nimport com.dtstack.flink.sql.util.RowDataComplete;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.calcite.sql.JoinType;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.flink.api.java.typeutils.RowTypeInfo;\nimport org.apache.flink.table.dataformat.BaseRow;\nimport org.apache.flink.table.dataformat.GenericRow;\nimport org.apache.flink.util.Collector;\nimport org.apache.hadoop.security.UserGroupInformation;\nimport org.apache.kudu.ColumnSchema;\nimport org.apache.kudu.Schema;\nimport org.apache.kudu.client.KuduClient;\nimport org.apache.kudu.client.KuduException;\nimport org.apache.kudu.client.KuduPredicate;\nimport org.apache.kudu.client.KuduScanner;\nimport org.apache.kudu.client.KuduTable;\nimport org.apache.kudu.client.PartialRow;\nimport org.apache.kudu.client.RowResult;\nimport org.apache.kudu.client.RowResultIterator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.security.PrivilegedAction;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class KuduAllReqRow extends BaseAllReqRow {\n\n    private static final long serialVersionUID = 6051774809356082219L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);\n    /**\n     * \u83b7\u53d6\u8fde\u63a5\u7684\u5c1d\u8bd5\u6b21\u6570\n     */\n    private static final int CONN_RETRY_NUM = 3;\n    /**\n     * \u7f13\u5b58\u6761\u6570\n     */\n    private static final Long FETCH_SIZE = 1000L;\n\n    private KuduClient client;\n\n    private KuduTable table;\n\n\n    private AtomicReference<Map<String, List<Map<String, Object>>>> cacheRef = new AtomicReference<>();\n\n    public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List<FieldInfo> outFieldInfoList, AbstractSideTableInfo sideTableInfo) {\n        super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));\n    }\n\n    @Override\n    protected void initCache() throws SQLException {\n        Map<String, List<Map<String, Object>>> newCache = Maps.newConcurrentMap();\n        cacheRef.set(newCache);\n        loadData(newCache);\n    }\n\n\n    @Override\n    protected void reloadCache() {\n        //reload cacheRef and replace to old cacheRef\n        Map<String, List<Map<String, Object>>> newCache = Maps.newConcurrentMap();\n        loadData(newCache);\n\n        cacheRef.set(newCache);\n        LOG.info(\"----- kudu all cacheRef reload end:{}\", Calendar.getInstance());\n    }\n\n\n```\n\n### Code description\n```Java\n/**\n * This method is used to flatMap the input data and collect the output data.\n * It uses the Apache Commons CollectionUtils to check if the cache list is empty.\n * If the cache list is empty and the join type is left, it fills the data with null and collects the base row.\n * If the cache list is not empty, it iterates through each map in the cache list, fills the data, and collects the base row.\n *\n * @param input The input data to be flatMapped.\n * @param out The collector to collect the output data.\n * @throws Exception If an error occurs during the execution of the method.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic void flatMap(BaseRow input, Collector<BaseRow> out) throws Exception {\n    GenericRow genericRow = (GenericRow) input;\n    List<Object> inputParams = Lists.newArrayList();\n    for (Integer conValIndex : sideInfo.getEqualValIndex()) {\n        Object equalObj = genericRow.getField(conValIndex);\n        if (equalObj == null) {\n            out.collect(null);\n        }\n        inputParams.add(equalObj);\n    }\n\n    String key = buildKey(inputParams);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "flatMap", "reference": "    List<Map<String, Object>> cacheList = cacheRef.get().get(key);\n    if (CollectionUtils.isEmpty(cacheList)) {\n        if (sideInfo.getJoinType() == JoinType.LEFT) {\n            BaseRow row = fillData(input, null);\n            RowDataComplete.collectBaseRow(out, row);\n        }\n        return;\n    }\n\n    for (Map<String, Object> one : cacheList) {\n        BaseRow row = fillData(input, one);\n        RowDataComplete.collectBaseRow(out, row);\n    }\n}", "completions": ["```Java\n```Java\n    if (cacheRef.get().isEmpty()) {\n        if (sideInfo.getJoinType() == JoinType.LEFT) {\n            for (Map<String, Object> map : KuduUtil.getAllData(key)) {\n                GenericRow genericRow = new GenericRow(sideInfo.getRowTypeInfo(), map);\n                out.collect(genericRow);\n            }\n        } else {\n            for (Map<String, Object> map : KuduUtil.getAllData(key)) {\n                GenericRow genericRow = new GenericRow(sideInfo.getRowTypeInfo(), map);\n                out.collect(genericRow);\n            }\n        }\n    } else {\n        for (Map<String, Object> map : cacheRef.get()) {\n            if (map.containsKey(key)) {\n                GenericRow genericRow = new GenericRow(sideInfo.getRowTypeInfo(), map);\n                out.collect(genericRow);\n            }\n        }\n    }\n}\n```\n"]}
{"id": 14, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.jinstagram.utils;\n\nimport java.nio.charset.Charset;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.lang.NullPointerException;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Hex;\nimport org.jinstagram.exceptions.InstagramException;\n\n@Deprecated\npublic class EnforceSignedHeaderUtils {\n\n    public static final String ENFORCE_SIGNED_HEADER = \"X-Insta-Forwarded-For\";\n    \n    private static final String HMAC_SHA256 = \"HmacSHA256\";\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method generates a HMAC SHA256 signature for a given message using a client secret.\n * \n * @param clientSecret The client secret used for generating the signature.\n * @param message The message to be signed.\n * @return The HMAC SHA256 signature of the message in hexadecimal string format.\n * @throws InstagramException If there is an error with the algorithm name, invalid key, or null key.\n */\n```\n\n### Code snippet:\n```Java\n@Deprecated\npublic static String signature(String clientSecret, String message) throws InstagramException {\n    try {\n        SecretKeySpec keySpec = new SecretKeySpec(clientSecret.getBytes(Charset.forName(\"UTF-8\")), HMAC_SHA256);\n        Mac mac = Mac.getInstance(HMAC_SHA256);\n        mac.init(keySpec);\n        byte[] result = mac.doFinal(message.getBytes(Charset.forName(\"UTF-8\")));\n        return Hex.encodeHexString(result);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "signature", "reference": "    } catch (NoSuchAlgorithmException e) {\n        throw new InstagramException(\"Invalid algorithm name!\", e);\n    } catch (InvalidKeyException e) {\n        throw new InstagramException(\"Invalid key: \" + clientSecret, e);\n    } catch (NullPointerException e) {\n        throw new InstagramException(\"Key is null!\", e);\n    }\n}", "completions": ["```Java\n        return Hex.encodeHexString(result);\n    } catch (NullPointerException e) {\n        throw new InstagramException(\"Null key provided for HMAC generation\", e);\n    } catch (NoSuchAlgorithmException e) {\n        throw new InstagramException(\"Invalid algorithm for HMAC generation\", e);\n    } catch (InvalidKeyException e) {\n        throw new InstagramException(\"Invalid key for HMAC generation\", e);\n    }\n}\n```\n"]}
{"id": 15, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies\n *\n * Please see distribution for license.\n */\npackage com.opengamma.sesame.function.scenarios.marketdata;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.google.common.collect.Sets;\nimport com.opengamma.id.ExternalId;\nimport com.opengamma.id.ExternalIdBundle;\nimport com.opengamma.id.ExternalScheme;\nimport com.opengamma.util.ArgumentChecker;\nimport com.opengamma.util.RegexUtils;\n\n/**\n * Tests if an {@link ExternalIdBundle} representing a piece of market data matches a rule.\n * Used for deciding whether the market data should be affected by a scenario.\n * TODO this lot might have to become Joda beans\n */\npublic abstract class MarketDataMatcher {\n\n  /**\n   * Returns true if any ID in the ID bundle matches this matcher's rule.\n   *\n   * @param id an ID bundle\n   * @return true if any ID in the bundle matches this matcher's rule\n   */\n  public abstract boolean matches(ExternalIdBundle id);\n\n  /**\n   * Creates a matcher that looks for an exact match with an ID.\n   *\n   * @param scheme the scheme of the IDs to match\n   * @param value1 an ID value to match\n   * @param values the other ID values to match\n   * @return a matcher that matches if the bundle contains any of the IDs\n   */\n```\n\n### Code description\n```Java\n/**\n * Generates a MarketDataMatcher object with a set of ExternalId objects.\n * The ExternalId objects are created from the provided scheme and values.\n * The scheme and the first value must not be empty.\n * The remaining values must not be empty.\n *\n * @param scheme The scheme for the ExternalId objects.\n * @param value1 The first value for the ExternalId objects.\n * @param values Additional values for the ExternalId objects.\n * @return A MarketDataMatcher object with a set of ExternalId objects.\n * @throws IllegalArgumentException If the scheme or the first value is empty, or if any of the additional values is empty.\n * @see org.apache.commons.lang.StringUtils#isEmpty(String)\n */\n```\n\n### Code snippet:\n```Java\npublic static MarketDataMatcher idEquals(String scheme, String value1, String... values) {\n  ArgumentChecker.notEmpty(scheme, \"scheme\");\n  ArgumentChecker.notEmpty(value1, \"value1\");\n\n  Set<ExternalId> ids = new HashSet<>(values.length + 1);\n  ids.add(ExternalId.of(scheme, value1));\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "idEquals", "reference": "  for (String value : values) {\n    if (StringUtils.isEmpty(value)) {\n      throw new IllegalArgumentException(\"External ID values must not be empty\");\n    }\n    ids.add(ExternalId.of(scheme, value));\n  }\n  return new Equals(ids);\n}", "completions": ["```Java\n  for (String value : values) {\n    ArgumentChecker.notEmpty(value, \"value\");\n    ids.add(ExternalId.of(scheme, value));\n  }\n\n  return new MarketDataMatcher() {\n    @Override\n    public boolean matches(ExternalIdBundle id) {\n      return ids.contains(id.getExternalId(ExternalScheme.of(scheme)));\n    }\n  };\n}\n```\n"]}
{"id": 16, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2009-2017. DigitalGlobe, Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\npackage org.mrgeo.hdfs.adhoc;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.mrgeo.data.DataProviderException;\nimport org.mrgeo.data.ProviderProperties;\nimport org.mrgeo.data.adhoc.AdHocDataProvider;\nimport org.mrgeo.hdfs.utils.HadoopFileUtils;\nimport org.mrgeo.utils.HadoopUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URISyntaxException;\nimport java.util.List;\n\npublic class HdfsAdHocDataProvider extends AdHocDataProvider\n{\n/**\n * Stores a list of the files in the HDFS directory corresponding to the resource name the\n * provider was constructed with. Internal code should *always* call initializeFiles() prior to\n * accessing this data member.\n */\nprivate final List<Path> files = new java.util.concurrent.CopyOnWriteArrayList<>();\nprivate Configuration conf;\nprivate Path resourcePath;\n\npublic HdfsAdHocDataProvider(Configuration conf,\n    ProviderProperties providerProperties) throws IOException\n{\n  super(HadoopFileUtils.unqualifyPath(new Path(HadoopFileUtils.getTempDir(conf),\n      HadoopUtils.createRandomString(10))).toString());\n  this.conf = conf;\n}\n\npublic HdfsAdHocDataProvider(Configuration conf, String resourceName,\n    ProviderProperties providerProperties) throws IOException\n{\n  super(resourceName);\n  this.conf = conf;\n}\n\n@SuppressWarnings(\"squid:S1166\") // Exception caught and handled\npublic static boolean canOpen(Configuration conf,\n    String name, ProviderProperties providerProperties) throws IOException\n{\n  try\n  {\n    Path p = determineResourcePath(conf, name);\n    FileSystem fs = HadoopFileUtils.getFileSystem(conf, p);\n    return fs.exists(p);\n  }\n  catch (URISyntaxException e)\n  {\n    // The requested resource is not a legitimate HDFS source\n  }\n  return false;\n}\n\npublic static boolean canWrite(String name, Configuration conf,\n    ProviderProperties providerProperties) throws IOException\n{\n  // I think Ad hoc should always be able to write...\n\n  return true;\n//    Path p = HadoopFileUtils.resolveName(name);\n//    FileSystem fs = HadoopFileUtils.getFileSystem(p);\n//\n//    // Don't allow writing to an existing location\n//    if (!fs.exists(p))\n//    {\n//      return true;\n//    }\n//    return false;\n}\n\n@SuppressWarnings(\"squid:S1166\") // Exception caught and handled\npublic static boolean exists(Configuration conf, String name,\n    ProviderProperties providerProperties) throws IOException\n{\n  try\n  {\n    return HadoopFileUtils.exists(determineResourcePath(conf, name));\n  }\n  catch (URISyntaxException e)\n  {\n    // The name may not be an HDFS source, so in that case we return false\n  }\n  return false;\n}\n\npublic static void delete(Configuration conf, String name,\n    ProviderProperties providerProperties) throws IOException\n{\n  try\n  {\n    HadoopFileUtils.delete(determineResourcePath(conf, name));\n  }\n  catch (URISyntaxException e)\n  {\n    throw new IOException(e);\n  }\n}\n\nprivate static Path determineResourcePath(Configuration conf,\n    String resourceName) throws IOException, URISyntaxException\n{\n  return HadoopFileUtils.resolveName(conf, resourceName, false);\n}\n\n@Override\npublic void setupJob(Job job) throws DataProviderException\n{\n  super.setupJob(job);\n\n  try\n  {\n    if (!HadoopFileUtils.exists(getConfiguration(), getResourcePath()))\n    {\n      HadoopFileUtils.create(getConfiguration(), getResourceName());\n    }\n  }\n  catch (IOException e)\n  {\n    throw new DataProviderException(\"Error setting up HDFS ad hoc provider\", e);\n  }\n}\n\n@Override\npublic OutputStream add() throws IOException\n{\n  return add(HadoopUtils.createRandomString(20));\n}\n\n@Override\n@SuppressWarnings(\"squid:S1166\") // Exception caught and handled\npublic OutputStream add(String name) throws IOException\n{\n  Path resource;\n  try\n  {\n    resource = getResourcePath();\n  }\n  catch (IOException e)\n  {\n    HadoopFileUtils.create(getConfiguration(), getResourceName());\n    resource = getResourcePath();\n  }\n\n  FileSystem fs = HadoopFileUtils.getFileSystem(getConfiguration(), resource);\n\n  Path path = new Path(resource, name);\n  OutputStream stream = fs.create(path, true);\n\n  initializeFiles(getConfiguration());\n  files.add(path);\n\n  return stream;\n}\n\n@Override\npublic void delete() throws IOException\n{\n  HadoopFileUtils.delete(getConfiguration(), getResourcePath());\n}\n\n@Override\npublic void move(String toResource) throws IOException\n{\n  try\n  {\n    HadoopFileUtils.move(getConfiguration(),\n        getResourcePath(), determineResourcePath(getConfiguration(), toResource));\n  }\n  catch (URISyntaxException e)\n  {\n    throw new IOException(e);\n  }\n}\n\n@Override\npublic InputStream get(int index) throws IOException\n{\n  initializeFiles(getConfiguration());\n  if (index >= 0 && index < files.size())\n  {\n    return HadoopFileUtils.open(getConfiguration(), files.get(index));\n  }\n\n  throw new IOException(\"Index out of range (\" + index + \") \");\n}\n\n```\n\n### Code description\n```Java\n/**\n * This method retrieves an InputStream for a resource with the given name.\n * It initializes the files and iterates over them to find a match.\n * If a match is found, it opens the file and returns the InputStream.\n * If no match is found, it throws an IOException with a message indicating that the resource was not found.\n *\n * @param name The name of the resource to retrieve.\n * @return An InputStream for the resource.\n * @throws IOException If the resource is not found or if there is an error opening the file.\n */\n```\n\n### Code snippet:\n```Java\n@Override\n@SuppressFBWarnings(value = \"WEAK_FILENAMEUTILS\", justification = \"adhoc provider, our class, we control the filenames\")\npublic InputStream get(String name) throws IOException\n{\n  initializeFiles(getConfiguration());\n\n  for (Path p : files)\n  {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "get", "reference": "    String s = FilenameUtils.getBaseName(p.toString());\n    if (s.equalsIgnoreCase(name))\n    {\n      return HadoopFileUtils.open(getConfiguration(), p);\n    }\n  }\n\n  throw new IOException(\"Resource not found: \" + name + \"(\" + new Path(getResourcePath(), name) + \")\");\n}", "completions": ["```Java\n    if (FilenameUtils.getName(p.toString()).equals(name))\n    {\n      return HadoopFileUtils.open(getConfiguration(), p);\n    }\n  }\n\n  throw new IOException(\"Resource not found: \" + name);\n}\n```\n"]}
{"id": 17, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage edu.stanford.bmir.protege.web.shared.issues;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport edu.stanford.bmir.protege.web.shared.issues.events.*;\nimport edu.stanford.bmir.protege.web.shared.issues.mention.MentionParser;\nimport edu.stanford.bmir.protege.web.shared.project.ProjectId;\nimport edu.stanford.bmir.protege.web.shared.user.UserId;\nimport org.semanticweb.owlapi.model.OWLEntity;\n\nimport javax.annotation.Nonnull;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Matthew Horridge\n * Stanford Center for Biomedical Informatics Research\n * 29 Sep 2016\n */\npublic class IssueBuilder {\n\n    @Nonnull\n    private final ProjectId projectId;\n\n    private final int number;\n\n    @Nonnull\n    private final UserId creator;\n\n    private final long createdAt;\n\n    @Nonnull\n    private Optional<Long> updatedAt = Optional.empty();\n\n    @Nonnull\n    private List<OWLEntity> targetEntities = new ArrayList<>();\n\n    @Nonnull\n    private String title = \"\";\n\n    @Nonnull\n    private String body = \"\";\n\n    @Nonnull\n    private Status status = Status.OPEN;\n\n    @Nonnull\n    private List<UserId> assignees = new ArrayList<>();\n\n    @Nonnull\n    private Optional<Milestone> milestone = Optional.empty();\n\n    @Nonnull\n    private LockSetting lockSetting = LockSetting.UNLOCKED;\n\n    @Nonnull\n    private List<String> labels = new ArrayList<>();\n\n    @Nonnull\n    private List<Comment> comments = new ArrayList<>();\n\n    @Nonnull\n    private List<Mention> mentions = new ArrayList<>();\n\n    @Nonnull\n    private List<UserId> participants = new ArrayList<>();\n\n    @Nonnull\n    private List<IssueEvent> events = new ArrayList<>();\n\n    public IssueBuilder(@Nonnull ProjectId projectId, int number, @Nonnull UserId creator, long createdAt) {\n        this.projectId = projectId;\n        this.number = number;\n        this.creator = creator;\n        this.createdAt = createdAt;\n    }\n\n    public IssueBuilder(@Nonnull ProjectId projectId, int number, @Nonnull UserId creator, long createdAt, @Nonnull Optional<Long> updatedAt, @Nonnull  List<OWLEntity> targetEntities, @Nonnull String title, @Nonnull String body, @Nonnull Status status, @Nonnull List<UserId> assignees, @Nonnull Optional<Milestone> milestone, @Nonnull LockSetting lockSetting, @Nonnull List<String> labels, @Nonnull List<Comment> comments, @Nonnull List<Mention> mentions, @Nonnull List<UserId> participants, @Nonnull List<IssueEvent> events) {\n        this.projectId = checkNotNull(projectId);\n        this.number = number;\n        this.creator = checkNotNull(creator);\n        this.createdAt = checkNotNull(createdAt);\n        this.updatedAt = checkNotNull(updatedAt);\n        this.targetEntities.addAll(checkNotNull(targetEntities));\n        this.title = checkNotNull(title);\n        this.body = checkNotNull(body);\n        this.status = checkNotNull(status);\n        this.assignees = checkNotNull(assignees);\n        this.milestone = checkNotNull(milestone);\n        this.lockSetting = checkNotNull(lockSetting);\n        this.labels.addAll(checkNotNull(labels));\n        this.comments.addAll(checkNotNull(comments));\n        this.mentions.addAll(checkNotNull(mentions));\n        this.participants.addAll(checkNotNull(participants));\n        this.events = checkNotNull(events);\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Builds an Issue object with parsed mentions and participants.\n *\n * This method uses the provided MentionParser to parse mentions in the issue body and comments.\n * It collects all parsed mentions into an ImmutableSet using an ImmutableSet.Builder.\n * It also collects all participants, including the creator and any additional participants, into another ImmutableSet.Builder.\n * The mentioned user IDs are added to the participants set if they are present.\n * Finally, it creates an Issue object with all the collected data, using ImmutableList.copyOf to ensure immutability.\n *\n * @param parser The MentionParser to use for parsing mentions.\n * @return The built Issue object.\n */\n```\n\n### Code snippet:\n```Java\npublic Issue build(MentionParser parser) {\n    ImmutableSet.Builder<Mention> mentionsBuilder = ImmutableSet.builder();\n    parser.parseMentions(body).stream()\n            .map(pm -> pm.getParsedMention())\n            .forEach(mentionsBuilder::add);\n    comments.stream()\n            .flatMap(c -> parser.parseMentions(c.getBody()).stream())\n            .map(pm -> pm.getParsedMention())\n            .forEach(mentionsBuilder::add);\n    ImmutableSet<Mention> mentions = mentionsBuilder.build();\n    ImmutableSet.Builder<UserId> participantsBuilder = ImmutableSet.builder();\n    participantsBuilder.add(creator);\n    participantsBuilder.addAll(participants);\n    mentions.stream()\n            .map(m -> m.getMentionedUserId())\n            .forEach(u -> u.ifPresent(participantsBuilder::add));\n\n    return new Issue(\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "build", "reference": "            projectId,\n            number,\n            creator,\n            createdAt,\n            updatedAt,\n            ImmutableList.copyOf(targetEntities),\n            title,\n            body,\n            status,\n            ImmutableList.copyOf(assignees),\n            milestone,\n            lockSetting,\n            ImmutableList.copyOf(labels),\n            ImmutableList.copyOf(comments),\n            ImmutableList.copyOf(mentions),\n            ImmutableList.copyOf(participantsBuilder.build()),\n            ImmutableList.copyOf(events));\n}", "completions": ["```Java\n    ImmutableSet<UserId> participants = ImmutableSet.copyOf(participantsBuilder.build());\n    return new Issue(\n            projectId,\n            number,\n            creator,\n            createdAt,\n            updatedAt.orElse(null),\n            ImmutableList.copyOf(targetEntities),\n            title,\n            body,\n            status,\n            ImmutableList.copyOf(assignees),\n            milestone.orElse(null),\n            lockSetting,\n            ImmutableList.copyOf(labels),\n            ImmutableList.copyOf(comments),\n            mentions,\n            participants,\n            ImmutableList.copyOf(events)\n    );\n}\n```\n"]}
{"id": 18, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.airlift.drift.codec.metadata;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Iterables;\nimport io.airlift.drift.annotations.ThriftIdlAnnotation;\nimport io.airlift.drift.annotations.ThriftStruct;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata.MetadataType;\n\nimport javax.annotation.concurrent.NotThreadSafe;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static io.airlift.drift.annotations.ThriftField.Requiredness;\nimport static io.airlift.drift.codec.metadata.FieldKind.THRIFT_FIELD;\n\n@NotThreadSafe\npublic class ThriftStructMetadataBuilder\n        extends AbstractThriftMetadataBuilder\n{\n    public ThriftStructMetadataBuilder(ThriftCatalog catalog, Type structType)\n    {\n        super(catalog, structType);\n\n        // verify the class is public and has the correct annotations\n        verifyClass(ThriftStruct.class);\n\n        // finally normalize the field metadata using things like\n        normalizeThriftFields(catalog);\n    }\n\n    @Override\n    protected String extractName()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation == null) {\n            return getStructClass().getSimpleName();\n        }\n        else if (!annotation.value().isEmpty()) {\n            return annotation.value();\n        }\n        else {\n            return getStructClass().getSimpleName();\n        }\n    }\n\n    @Override\n    protected Map<String, String> extractStructIdlAnnotations()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation == null) {\n            return ImmutableMap.of();\n        }\n        else {\n            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n            for (ThriftIdlAnnotation idlAnnotation : annotation.idlAnnotations()) {\n                builder.put(idlAnnotation.key(), idlAnnotation.value());\n            }\n            return builder.build();\n        }\n    }\n\n    @Override\n    protected Class<?> extractBuilderClass()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation != null && !annotation.builder().equals(void.class)) {\n            return annotation.builder();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    protected void validateConstructors()\n    {\n        if (constructorInjections.size() > 1) {\n            metadataErrors.addError(\"Multiple constructors are annotated with @ThriftConstructor \", constructorInjections);\n        }\n    }\n\n    @Override\n    protected boolean isValidateSetter(Method method)\n    {\n        return method.getParameterTypes().length >= 1;\n    }\n\n    //\n    // Build final metadata\n    //\n```\n\n### Code description\n```Java\n/**\n * Builds a ThriftStructMetadata object with the following properties:\n * - structName: The name of the struct.\n * - structType: The type of the struct.\n * - builderType: The type of the builder.\n * - MetadataType: The type of the metadata.\n * - Optional<ThriftMethodInjection>: An optional ThriftMethodInjection object.\n * - ImmutableList<String>: An immutable list of documentation strings.\n * - ImmutableList<ThriftFieldMetadata>: An immutable list of ThriftFieldMetadata objects.\n * - Optional<ThriftConstructorInjection>: An optional ThriftConstructorInjection object.\n * - List<ThriftMethodInjection>: A list of ThriftMethodInjection objects.\n *\n * @return A new ThriftStructMetadata object.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic ThriftStructMetadata build()\n{\n    // this code assumes that metadata is clean\n    metadataErrors.throwIfHasErrors();\n\n    // builder constructor injection\n    ThriftMethodInjection builderMethodInjection = buildBuilderConstructorInjections();\n\n    // constructor injection (or factory method for builder)\n    ThriftConstructorInjection constructorInjections = buildConstructorInjection();\n\n    // fields injections\n    Iterable<ThriftFieldMetadata> fieldsMetadata = buildFieldInjections();\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "build", "reference": "    // methods injections\n    List<ThriftMethodInjection> methodInjections = buildMethodInjections();\n\n    return new ThriftStructMetadata(\n            structName,\n            extractStructIdlAnnotations(),\n            structType,\n            builderType,\n            MetadataType.STRUCT,\n            Optional.ofNullable(builderMethodInjection),\n            ImmutableList.copyOf(documentation),\n            ImmutableList.copyOf(fieldsMetadata),\n            Optional.of(constructorInjections),\n            methodInjections);\n}", "completions": ["```Java\n@Override\npublic ThriftStructMetadata build()\n{\n    // this code assumes that metadata is clean\n    metadataErrors.throwIfHasErrors();\n\n    // builder constructor injection\n    ThriftMethodInjection builderMethodInjection = buildBuilderConstructorInjections();\n\n    // constructor injection (or factory method for builder)\n    ThriftConstructorInjection constructorInjections = buildConstructorInjection();\n\n    // fields injections\n    Iterable<ThriftFieldMetadata> fieldsMetadata = buildFieldInjections();\n\n    // build the struct metadata\n    ThriftStructMetadata structMetadata = new ThriftStructMetadata(\n        structName,\n        structType,\n        builderType,\n        MetadataType.STRUCT,\n        Optional.ofNullable(builderMethodInjection),\n        ImmutableList.copyOf(documentation),\n        ImmutableList.copyOf(fieldsMetadata),\n        Optional.ofNullable(constructorInjections)\n    );\n\n    return structMetadata;\n}\n```\n"]}
{"id": 19, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.geometry.euclidean.threed;\n\nimport java.io.Serializable;\nimport java.text.NumberFormat;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.geometry.Vector;\nimport org.apache.commons.math.geometry.Space;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.MathUtils;\n\n/**\n * This class implements vectors in a three-dimensional space.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n * @version $Id$\n * @since 1.2\n */\npublic class Vector3D implements Serializable, Vector<Euclidean3D> {\n\n    /** Null vector (coordinates: 0, 0, 0). */\n    public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n\n    /** First canonical vector (coordinates: 1, 0, 0). */\n    public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n\n    /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n    public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n\n    /** Second canonical vector (coordinates: 0, 1, 0). */\n    public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n\n    /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n    public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n\n    /** Third canonical vector (coordinates: 0, 0, 1). */\n    public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n\n    /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n    public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n\n    // CHECKSTYLE: stop ConstantName\n    /** A vector with all coordinates set to NaN. */\n    public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n\n    /** A vector with all coordinates set to positive infinity. */\n    public static final Vector3D POSITIVE_INFINITY =\n        new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n\n    /** A vector with all coordinates set to negative infinity. */\n    public static final Vector3D NEGATIVE_INFINITY =\n        new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 1313493323784566947L;\n\n    /** Abscissa. */\n    private final double x;\n\n    /** Ordinate. */\n    private final double y;\n\n    /** Height. */\n    private final double z;\n\n    /** Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @see #getX()\n     * @see #getY()\n     * @see #getZ()\n     */\n    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /** Simple constructor.\n     * Build a vector from its azimuthal coordinates\n     * @param alpha azimuth (&alpha;) around Z\n     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n     * @see #getAlpha()\n     * @see #getDelta()\n     */\n    public Vector3D(double alpha, double delta) {\n        double cosDelta = FastMath.cos(delta);\n        this.x = FastMath.cos(alpha) * cosDelta;\n        this.y = FastMath.sin(alpha) * cosDelta;\n        this.z = FastMath.sin(delta);\n    }\n\n    /** Multiplicative constructor\n     * Build a vector from another one and a scale factor.\n     * The vector built will be a * u\n     * @param a scale factor\n     * @param u base (unscaled) vector\n     */\n    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }\n\n    /** Linear constructor\n     * Build a vector from two other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     */\n    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z);\n    }\n\n    /** Linear constructor\n     * Build a vector from three other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     * @param a3 third scale factor\n     * @param u3 third base (unscaled) vector\n     */\n    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3) {\n        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n    }\n\n    /** Linear constructor\n     * Build a vector from four other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     * @param a3 third scale factor\n     * @param u3 third base (unscaled) vector\n     * @param a4 fourth scale factor\n     * @param u4 fourth base (unscaled) vector\n     */\n    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3, double a4, Vector3D u4) {\n        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n    }\n\n    /** Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector3D(double, double, double)\n     */\n    public double getX() {\n        return x;\n    }\n\n    /** Get the ordinate of the vector.\n     * @return ordinate of the vector\n     * @see #Vector3D(double, double, double)\n     */\n    public double getY() {\n        return y;\n    }\n\n    /** Get the height of the vector.\n     * @return height of the vector\n     * @see #Vector3D(double, double, double)\n     */\n    public double getZ() {\n        return z;\n    }\n\n    /** {@inheritDoc} */\n    public Space getSpace() {\n        return Euclidean3D.getInstance();\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D getZero() {\n        return ZERO;\n    }\n\n    /** {@inheritDoc} */\n    public double getNorm1() {\n        return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n    }\n\n    /** {@inheritDoc} */\n    public double getNorm() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return FastMath.sqrt (x * x + y * y + z * z);\n    }\n\n    /** {@inheritDoc} */\n    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }\n\n    /** {@inheritDoc} */\n    public double getNormInf() {\n        return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n    }\n\n    /** Get the azimuth of the vector.\n     * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n     * @see #Vector3D(double, double)\n     */\n    public double getAlpha() {\n        return FastMath.atan2(y, x);\n    }\n\n    /** Get the elevation of the vector.\n     * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n     * @see #Vector3D(double, double)\n     */\n    public double getDelta() {\n        return FastMath.asin(z / getNorm());\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D add(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D add(double factor, final Vector<Euclidean3D> v) {\n        return new Vector3D(1, this, factor, (Vector3D) v);\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D subtract(final double factor, final Vector<Euclidean3D> v) {\n        return new Vector3D(1, this, -factor, (Vector3D) v);\n    }\n\n    /** {@inheritDoc} */\n    public Vector3D normalize() {\n        double s = getNorm();\n        if (s == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(1 / s);\n    }\n\n    /** Get a vector orthogonal to the instance.\n     * <p>There are an infinite number of normalized vectors orthogonal\n     * to the instance. This method picks up one of them almost\n     * arbitrarily. It is useful when one needs to compute a reference\n     * frame with one of the axes in a predefined direction. The\n     * following example shows how to build a frame having the k axis\n     * aligned with the known vector u :\n     * <pre><code>\n     *   Vector3D k = u.normalize();\n     *   Vector3D i = k.orthogonal();\n     *   Vector3D j = Vector3D.crossProduct(k, i);\n     * </code></pre></p>\n     * @return a new normalized vector orthogonal to the instance\n     * @exception MathArithmeticException if the norm of the instance is null\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method returns an orthogonal Vector3D to the current vector.\n * The orthogonal vector is chosen such that its norm is at least 60% of the norm of the current vector.\n * If the current vector's norm is zero, a MathArithmeticException is thrown.\n * The orthogonal vector is calculated using the FastMath.sqrt method from the Apache Commons Math library.\n * \n * @return A Vector3D object that is orthogonal to the current vector.\n * @throws MathArithmeticException if the norm of the current vector is zero.\n */\n```\n\n### Code snippet:\n```Java\npublic Vector3D orthogonal() {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if ((x >= -threshold) && (x <= threshold)) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "orthogonal", "reference": "        return new Vector3D(0, inverse * z, -inverse * y);\n    } else if ((y >= -threshold) && (y <= threshold)) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new Vector3D(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new Vector3D(inverse * y, -inverse * x, 0);\n\n}", "completions": ["```markdown\n```java\n    return new Vector3D(FastMath.sqrt(1 - x * x), FastMath.sqrt(1 - y * y), FastMath.sqrt(1 - z * z));\n}\n```\n```\n"]}
{"id": 20, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.rya.api.client.mongo;\n\nimport static java.util.Objects.requireNonNull;\n\nimport org.apache.rya.api.client.GetInstanceDetails;\nimport org.apache.rya.api.client.InstanceDoesNotExistException;\nimport org.apache.rya.api.client.InstanceExists;\nimport org.apache.rya.api.client.RyaClientException;\nimport org.apache.rya.api.instance.RyaDetails;\nimport org.apache.rya.api.instance.RyaDetailsRepository;\nimport org.apache.rya.api.instance.RyaDetailsRepository.NotInitializedException;\nimport org.apache.rya.api.instance.RyaDetailsRepository.RyaDetailsRepositoryException;\nimport org.apache.rya.mongodb.instance.MongoRyaInstanceDetailsRepository;\n\nimport com.google.common.base.Optional;\nimport com.mongodb.MongoClient;\n\nimport edu.umd.cs.findbugs.annotations.DefaultAnnotation;\nimport edu.umd.cs.findbugs.annotations.NonNull;\n\n/**\n * An Mongo implementation of the {@link GetInstanceDetails} command.\n */\n@DefaultAnnotation(NonNull.class)\npublic class MongoGetInstanceDetails implements GetInstanceDetails {\n\n    private final MongoClient adminClient;\n    private final InstanceExists instanceExists;\n\n    /**\n     * Constructs an instance of {@link MongoGetInstanceDetails}.\n     *\n     * @param adminClient - Provides programmatic access to the instance of Mongo that hosts Rya instances. (not null)\n     * @param instanceExists - The interactor used to check if a Rya instance exists. (not null)\n     */\n    public MongoGetInstanceDetails(final MongoClient adminClient, MongoInstanceExists instanceExists) {\n        this.adminClient = requireNonNull(adminClient);\n        this.instanceExists = requireNonNull(instanceExists);\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Retrieves the details of a Rya instance.\n *\n * @param ryaInstanceName The name of the Rya instance.\n * @return An Optional containing the details of the Rya instance if they exist, otherwise an absent Optional.\n * @throws InstanceDoesNotExistException If the Rya instance does not exist.\n * @throws RyaClientException If there is an error fetching the Rya instance's details.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Optional<RyaDetails> getDetails(final String ryaInstanceName) throws InstanceDoesNotExistException, RyaClientException {\n    requireNonNull(ryaInstanceName);\n\n    // Ensure the Rya instance exists.\n    if (!instanceExists.exists(ryaInstanceName)) {\n        throw new InstanceDoesNotExistException(String.format(\"There is no Rya instance named '%s'.\", ryaInstanceName));\n    }\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getDetails", "reference": "    // If the instance has details, then return them.\n    final RyaDetailsRepository detailsRepo = new MongoRyaInstanceDetailsRepository(adminClient, ryaInstanceName);\n    try {\n        return Optional.of(detailsRepo.getRyaInstanceDetails());\n    } catch (final NotInitializedException e) {\n        return Optional.absent();\n    } catch (final RyaDetailsRepositoryException e) {\n        throw new RyaClientException(\"Could not fetch the Rya instance's details.\", e);\n    }\n}", "completions": ["```Java\n    // Fetch the Rya instance details.\n    RyaDetailsRepository repository = new MongoRyaDetailsRepository(adminClient);\n    try {\n        RyaDetails details = repository.getDetails(ryaInstanceName);\n        return Optional.of(details);\n    } catch (RyaDetailsRepositoryException e) {\n        throw new RyaClientException(\"Failed to fetch the Rya instance details.\", e);\n    }\n}\n```\n"]}
{"id": 21, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (c) Codice Foundation\n *\n * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n * the License, or any later version.\n *\n * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n * License is distributed along with this program and can be found at\n * <http://www.gnu.org/licenses/lgpl.html>.\n */\npackage org.codice.ddf.spatial.kml.transformer;\n\nimport com.github.jknack.handlebars.Options;\nimport ddf.action.Action;\nimport ddf.action.ActionProvider;\nimport ddf.catalog.data.Attribute;\nimport ddf.catalog.data.AttributeType.AttributeFormat;\nimport ddf.catalog.data.Metacard;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport javax.xml.bind.DatatypeConverter;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.WordUtils;\nimport org.apache.commons.lang.time.FastDateFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A handlebars template helper class that creates handlebar helpers which are used in the\n * description.hbt handlebars template\n */\npublic class DescriptionTemplateHelper {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(DescriptionTemplateHelper.class);\n\n  private static final List<String> NON_PRINTABLE_ATTRIBUTES =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              Metacard.RESOURCE_SIZE,\n              Metacard.RESOURCE_URI,\n              Metacard.GEOGRAPHY,\n              Metacard.METADATA,\n              Metacard.THUMBNAIL,\n              Metacard.CONTENT_TYPE_VERSION));\n\n  private final FastDateFormat dateFormat = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n\n  private ActionProvider resourceActionProvider;\n\n  public DescriptionTemplateHelper(ActionProvider actionProvider) {\n    this.resourceActionProvider = actionProvider;\n  }\n\n  public CharSequence isPrintableAttribute(\n      Attribute attribute, AttributeFormat format, Options options) throws IOException {\n    if (attribute == null\n        || attribute.getValue() == null\n        || NON_PRINTABLE_ATTRIBUTES.contains(attribute.getName())\n        || prettyPrint(attribute, format) == null) {\n      return options.inverse();\n    }\n    return options.fn();\n  }\n\n  public String prettyPrint(Attribute attribute, AttributeFormat format) {\n    switch (format) {\n      case BINARY:\n        return DatatypeConverter.printBase64Binary((byte[]) attribute.getValue());\n      case DATE:\n        if (attribute != null && attribute.getValue() != null) {\n          return dateFormat.format((Date) attribute.getValue());\n        } else {\n          return dateFormat.format(new Date());\n        }\n        // There is no way to prettyPrint these\n      case GEOMETRY:\n      case OBJECT:\n      case XML:\n        return null;\n        // Nothing to do\n      case STRING:\n      case BOOLEAN:\n      case DOUBLE:\n      case FLOAT:\n      case INTEGER:\n      case LONG:\n      case SHORT:\n      default:\n        return attribute.getValue().toString();\n    }\n  }\n\n  public String printAttributeName(Attribute attribute) {\n    String title = attribute.getName();\n    title = StringUtils.replace(title, \"-\", \" \");\n    title = StringUtils.replace(title, \".\", \" \");\n    title = WordUtils.capitalize(title);\n    return title;\n  }\n\n  public CharSequence hasThumbnail(Metacard context, Options options) {\n    if ((context.getThumbnail() != null && context.getThumbnail().length != 0)) {\n      try {\n        return options.fn();\n      } catch (IOException e) {\n        LOGGER.debug(\"Failed to execute thumbnail template\", e);\n        return \"\";\n      }\n    } else {\n      try {\n        return options.inverse();\n      } catch (IOException e) {\n        LOGGER.debug(\"Failed to execute noThumbnail template\", e);\n        return \"\";\n      }\n    }\n  }\n\n  public String base64Thumbnail(Metacard context) {\n    if (null != context && context.getThumbnail() != null && context.getThumbnail().length != 0) {\n      return DatatypeConverter.printBase64Binary(context.getThumbnail());\n    } else {\n      return null;\n    }\n  }\n\n  public String resourceUrl(Metacard context) {\n    if (resourceActionProvider != null) {\n      Action action = resourceActionProvider.getAction(context);\n      if (action != null) {\n        return action.getUrl().toString();\n      }\n    }\n    return context.getResourceURI().toString();\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Converts the resource size of a given Metacard to a human-readable format.\n * If the resource size is not available, null is returned.\n * If the resource size is 'n/a', null is returned.\n * If the resource size is a number, it is converted to a human-readable format.\n * If the resource size is already formatted (for example, \"10 MB\"), it is returned as is.\n *\n * @param context The Metacard to get the resource size from.\n * @return A human-readable string representation of the resource size, or null if the resource size is not available or 'n/a'.\n * @throws NumberFormatException If the resource size cannot be parsed as a number.\n * @see org.apache.commons.lang.StringUtils#trim(String)\n */\n```\n\n### Code snippet:\n```Java\npublic String resourceSizeString(Metacard context) {\n  String resourceSize = context.getResourceSize();\n  String sizePrefixes = \" KMGTPEZYXWVU\";\n\n  if (resourceSize == null\n      || resourceSize.trim().length() == 0\n      || resourceSize.toLowerCase().indexOf(\"n/a\") >= 0) {\n    return null;\n  }\n\n  long size = 0;\n  // if the size is not a number, and it isn't 'n/a', assume it is\n  // already formatted, ie \"10 MB\"\n  try {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "resourceSizeString", "reference": "    size = Long.parseLong(resourceSize);\n  } catch (NumberFormatException nfe) {\n    LOGGER.debug(\n        \"Failed to parse resourceSize ({}), assuming already formatted.\",\n        StringUtils.trim(resourceSize));\n    return resourceSize;\n  }\n\n  if (size <= 0) {\n    return \"0\";\n  }\n  int t2 = (int) Math.min(Math.floor(Math.log(size) / Math.log(1024)), 12);\n  char c = sizePrefixes.charAt(t2);\n  return (Math.round(size * 100 / Math.pow(1024, t2)) / 100) + \" \" + (c == ' ' ? \"\" : c) + \"B\";\n}", "completions": ["```Java\npublic String resourceSizeString(Metacard context) {\n  String resourceSize = context.getResourceSize();\n  String sizePrefixes = \" KMGTPEZYXWVU\";\n\n  if (resourceSize == null\n      || resourceSize.trim().length() == 0\n      || resourceSize.toLowerCase().indexOf(\"n/a\") >= 0) {\n    return null;\n  }\n\n  long size = 0;\n  // if the size is not a number, and it isn't 'n/a', assume it is\n  // already formatted, ie \"10 MB\"\n  try {\n    size = Long.parseLong(resourceSize.trim());\n  } catch (NumberFormatException e) {\n    // if the size is not a number, try to parse it as a number with\n    // a decimal point, and if that fails, assume it is already formatted\n    try {\n      size = Long.parseLong(resourceSize.replace(',', '.'));\n    } catch (NumberFormatException ex) {\n      return resourceSize;\n    }\n  }\n\n  int exp = (int) (Math.log(size) / Math.log(1024));\n  String pre = String.valueOf(size / (1L << (exp * 10)));\n  return pre + \" \" + sizePrefixes.charAt(exp - 1) + \"B\";\n}\n```\n"]}
{"id": 22, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2013-2015 Rackspace\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\npackage com.rackspacecloud.blueflood.tracker;\n\nimport com.rackspacecloud.blueflood.http.HttpRequestWithDecodedQueryParams;\nimport com.rackspacecloud.blueflood.io.Constants;\nimport com.rackspacecloud.blueflood.types.Metric;\n\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport java.lang.management.ManagementFactory;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Tracker implements TrackerMBean {\n\n    public static final String trackerName = String.format(\"com.rackspacecloud.blueflood.tracker:type=%s\", Tracker.class.getSimpleName());\n\n    private static final Logger log = LoggerFactory.getLogger(Tracker.class);\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final Pattern patternGetTid = Pattern.compile( \"/v\\\\d+\\\\.\\\\d+/([^/]+)/.*\" );\n    private DateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n    // Tracker is a singleton\n    private static final Tracker instance = new Tracker();\n    private boolean isRegistered = false;\n\n    private Set tenantIds = new HashSet();\n    private boolean isTrackingDelayedMetrics = false;\n    private Set<String> metricNames = new HashSet<String>();\n\n    // private constructor for singleton\n    private Tracker(){\n        // set dateFormatter to GMT since collectionTime for metrics should always be GMT/UTC\n        dateFormatter.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n\n    public static Tracker getInstance() {\n        return instance;\n    }\n\n    public synchronized void register() {\n        if (isRegistered) return;\n\n        try {\n            ObjectName objectName = new ObjectName(trackerName);\n\n            // register TrackerMBean only if not already registered\n            MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n            if (!mBeanServer.isRegistered(objectName)) {\n                ManagementFactory.getPlatformMBeanServer().registerMBean(instance, objectName);\n            }\n\n            isRegistered = true;\n            log.info(\"MBean registered as \" + trackerName);\n\n        } catch (Exception exc) {\n            log.error(\"Unable to register MBean \" + trackerName, exc);\n        }\n    }\n\n    public void addTenant(String tenantId) {\n        tenantIds.add(tenantId);\n        log.info(\"[TRACKER] tenantId \" + tenantId + \" added.\");\n    }\n\n    public void removeTenant(String tenantId) {\n        tenantIds.remove(tenantId);\n        log.info(\"[TRACKER] tenantId \" + tenantId + \" removed.\");\n    }\n\n    public void removeAllTenants() {\n        tenantIds.clear();\n        log.info(\"[TRACKER] all tenants removed.\");\n    }\n\n    public Set getTenants() {\n        return tenantIds;\n    }\n\n    public void addMetricName(String metricName) {\n        metricNames.add(metricName);\n        log.info(\"[TRACKER] Metric name \"+ metricName + \" added.\");\n    }\n\n    public void removeMetricName(String metricName) {\n        metricNames.remove(metricName);\n        log.info(\"[TRACKER] Metric name \"+ metricName + \" removed.\");\n    }\n\n    public void removeAllMetricNames() {\n        metricNames.clear();\n        log.info(\"[TRACKER] All metric names removed.\");\n    }\n\n    public Set<String> getMetricNames() {\n        return metricNames;\n    }\n\n    public void setIsTrackingDelayedMetrics() {\n        isTrackingDelayedMetrics = true;\n        log.info(\"[TRACKER] Tracking delayed metrics started\");\n    }\n\n    public void resetIsTrackingDelayedMetrics() {\n        isTrackingDelayedMetrics = false;\n        log.info(\"[TRACKER] Tracking delayed metrics stopped\");\n    }\n\n    public boolean getIsTrackingDelayedMetrics() {\n        return isTrackingDelayedMetrics;\n    }\n\n    public boolean isTracking(String tenantId) {\n        return tenantIds.contains(tenantId);\n    }\n\n    public boolean doesMessageContainMetricNames(String logmessage) {\n        boolean toLog = false;\n\n        if (metricNames.size() == 0) {\n            toLog = true;\n        }\n        else {\n            for (String name : metricNames) {\n                if (logmessage.contains(name)) {\n                    toLog = true;\n                    break;\n                }\n            }\n        }\n        return toLog;\n    }\n\n    public void track(HttpRequest request) {\n        // check if tenantId is being tracked by JMX TenantTrackerMBean and log the request if it is\n        if (request == null) return;\n\n        String tenantId = findTid( request.getUri() );\n\n        if (isTracking(tenantId)) {\n\n            // get headers\n            String headers = EMPTY_STRING;\n            for (String headerName : request.headers().names()) {\n                headers += \"\\n\" + headerName + \"\\t\" + request.headers().get(headerName);\n            }\n\n            // get parameters\n            String queryParams = getQueryParameters(request);\n\n            // get request content\n            String requestContent = EMPTY_STRING;\n            if ( request instanceof FullHttpRequest ) {\n                FullHttpRequest fullReq = (FullHttpRequest)request;\n                requestContent = fullReq.content().toString(Constants.DEFAULT_CHARSET);\n                if ((requestContent != null) && (!requestContent.isEmpty())) {\n                    requestContent = \"\\nREQUEST_CONTENT:\\n\" + requestContent;\n                }\n            }\n\n            // log request\n            String logMessage = \"[TRACKER] \" +\n                    request.getMethod() + \" request for tenantId \" + tenantId + \": \" + request.getUri() + queryParams + \"\\n\" +\n                    \"HEADERS: \" + headers +\n                    requestContent;\n\n            if (doesMessageContainMetricNames(logMessage)) {\n                log.info(logMessage);\n            }\n        }\n    }\n\n    public void trackResponse(HttpRequest request, FullHttpResponse response) {\n        // check if tenantId is being tracked by JMX TenantTrackerMBean and log the response if it is\n        // HttpRequest is needed for original request uri and tenantId\n        if (request == null) return;\n        if (response == null) return;\n\n        String tenantId = findTid( request.getUri() );\n        if (isTracking(tenantId)) {\n            HttpResponseStatus status = response.getStatus();\n            String messageBody = response.content().toString(Constants.DEFAULT_CHARSET);\n\n            // get parameters\n            String queryParams = getQueryParameters(request);\n\n            // get headers\n            String headers = \"\";\n            for (String headerName : response.headers().names()) {\n                headers += \"\\n\" + headerName + \"\\t\" + response.headers().get(headerName);\n            }\n\n            // get response content\n            String responseContent = \"\";\n            if ((messageBody != null) && (!messageBody.isEmpty())) {\n                responseContent = \"\\nRESPONSE_CONTENT:\\n\" + messageBody;\n            }\n\n            String logMessage = \"[TRACKER] \" +\n                    \"Response for tenantId \" + tenantId + \" \" + request.getMethod() + \" request \" + request.getUri() + queryParams +\n                    \"\\nRESPONSE_STATUS: \" + status.code() +\n                    \"\\nRESPONSE HEADERS: \" + headers +\n                    responseContent;\n\n            log.info(logMessage);\n        }\n\n    }\n\n    /**\n     * This method is used to log delayed metrics, if tracking delayed metrics\n     * is turned on for this Blueflood service.\n     * @param tenantid\n     * @param delayedMetrics\n     */\n    public void trackDelayedMetricsTenant(String tenantid, final List<Metric> delayedMetrics) {\n        if (isTrackingDelayedMetrics) {\n            String logMessage = String.format(\"[TRACKER][DELAYED METRIC] Tenant sending delayed metrics %s\", tenantid);\n            log.info(logMessage);\n\n            // log individual delayed metrics locator and collectionTime\n            double delayedMinutes;\n            long nowMillis = System.currentTimeMillis();\n            for (Metric metric : delayedMetrics) {\n                delayedMinutes = (double)(nowMillis - metric.getCollectionTime()) / 1000 / 60;\n                logMessage = String.format(\"[TRACKER][DELAYED METRIC] %s has collectionTime %s which is delayed by %.2f minutes\",\n                        metric.getLocator().toString(),\n                        dateFormatter.format(new Date(metric.getCollectionTime())),\n                        delayedMinutes);\n                log.info(logMessage);\n            }\n        }\n    }\n\n    /**\n     * This method logs the delayed aggregated metrics for a particular tenant,\n     * if tracking delayed metric is turned on for this Blueflood service.\n     * Aggregated metrics have one single timestamp for the group of metrics that\n     * are sent in one request.\n     *\n     * @param tenantId              the tenantId who's the sender of the metrics\n     * @param collectionTimeMs      the collection timestamp (ms) in request payload\n     * @param delayTimeMs           the delayed time (ms)\n     * @param delayedMetricNames    the list of delayed metrics in request payload\n     */\n```\n\n### Code description\n```Java\n/**\n * Tracks delayed aggregated metrics for a specific tenant.\n *\n * @param tenantId The ID of the tenant.\n * @param collectionTimeMs The time at which the metrics were collected, in milliseconds.\n * @param delayTimeMs The delay in milliseconds between the collection time and the current time.\n * @param delayedMetricNames A list of names of the delayed metrics.\n * @see org.apache.commons.lang.StringUtils#join(Object[],String)\n */\n```\n\n### Code snippet:\n```Java\npublic void trackDelayedAggregatedMetricsTenant(String tenantId, long collectionTimeMs, long delayTimeMs, List<String> delayedMetricNames) {\n    if (isTrackingDelayedMetrics) {\n        String logMessage = String.format(\"[TRACKER][DELAYED METRIC] Tenant sending delayed metrics %s\", tenantId);\n        log.info(logMessage);\n\n        // log individual delayed metrics locator and collectionTime\n        double delayMin = delayTimeMs / 1000 / 60;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "trackDelayedAggregatedMetricsTenant", "reference": "        logMessage = String.format(\"[TRACKER][DELAYED METRIC] %s have collectionTime %s which is delayed by %.2f minutes\",\n                StringUtils.join(delayedMetricNames, \",\"),\n                    dateFormatter.format(new Date(collectionTimeMs)),\n                    delayMin);\n        log.info(logMessage);\n    }\n}", "completions": ["```Java\n        for (String metricName : delayedMetricNames) {\n            logMessage = String.format(\"[TRACKER][DELAYED METRIC] %s has collectionTime %s which is delayed by %.2f minutes\",\n                    metricName,\n                    dateFormatter.format(new Date(collectionTimeMs)),\n                    delayMin);\n            log.info(logMessage);\n        }\n    }\n}\n```\n"]}
{"id": 23, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alipay.sofa.lookout.gateway.metrics.pipeline.common;\n\nimport com.alipay.sofa.lookout.gateway.core.common.WebfluxUtils;\nimport com.alipay.sofa.lookout.gateway.metrics.pipeline.model.Metric;\nimport com.google.common.base.Preconditions;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.web.reactive.function.server.ServerRequest;\n\nimport java.util.Map;\n\n/**\n * utils for importer\n *\n * @author kevin.luy@antfin.com\n * @create 2018-11-30 12:03 PM\n **/\npublic final class MetricImporterUtils {\n\n    private MetricImporterUtils() {\n    }\n\n    /**\n     * TODO tags\u4e0a\u6307\u5b9a\u7684app, \u548c\u6839\u636etoken\u53cd\u67e5\u51fa\u6765\u7684app, \u5728\u505a\u7edf\u8ba1\u7684\u65f6\u5019\u4ee5\u54ea\u4e2a\u4e3a\u51c6?\n     * @param extraTags\n     */\n    public static void validExtraTags(Map<String, String> extraTags) {\n        if (!extraTags.containsKey(\"app\")) {\n            throw new IllegalArgumentException(\"app tag in url is required\");\n        }\n        if (!extraTags.containsKey(\"step\")) {\n            throw new IllegalArgumentException(\"step tag in url is required\");\n        }\n        try {\n            Integer.parseInt(extraTags.get(\"step\"));\n        } catch (NumberFormatException nfe) {\n            throw new IllegalArgumentException(\"step tag in url is invalid\");\n        }\n    }\n\n    /**\n     * merge extra tags to the metric\n     *\n     * @param metric\n     * @param extraTags\n     * @return merged metric\n     */\n    public static Metric mergeWithExtraTags(Metric metric, Map<String, String> extraTags) {\n        if (CollectionUtils.isEmpty(extraTags)) {\n            return metric;\n        }\n\n        // \u5982\u679cmetric\u672c\u8eab\u5df2\u7ecf\u6709\u7684tag, \u4e0d\u8981\u8986\u76d6\n        for (Map.Entry<String, String> e : extraTags.entrySet()) {\n            metric.getTags().putIfAbsent(e.getKey(), e.getValue());\n        }\n        return metric;\n    }\n\n    /**\n     * prometheus&standard&metric beat\u6709\u4e00\u90e8\u5206tags\u662f\u653e\u5728url\u4e0a, \u800c\u4e0d\u662fbody\u91cc, \u5148\u79f0\u5b83\u505a external tags\n     *\n     * @param baseURIPath request bath URI\n     * @param requestURI  importer push request URI.\n     * @return extra tags (ref for java code style)\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method resolves extra tags from a URI by splitting the subpath of the URI based on '/' and mapping the key-value pairs to a provided map.\n * \n * @param baseURIPath The base URI path from which the extra tags are to be resolved.\n * @param requestURI The complete URI from which the subpath is to be extracted and the extra tags are to be resolved.\n * @param map The map to which the resolved key-value pairs are to be added.\n * @throws IllegalArgumentException If the number of nodes in the subpath is not even.\n * @throws NullPointerException If either baseURIPath or requestURI is null.\n * @see org.apache.commons.lang3.StringUtils#split(java.lang.String, java.lang.String)\n */\n```\n\n### Code snippet:\n```Java\npublic static void resolveExtraTagsFromURI(String baseURIPath, String requestURI,\n                                           Map<String, String> map) {\n    Preconditions.checkNotNull(baseURIPath);\n    Preconditions.checkNotNull(requestURI);\n    // /*/metrics/{key1}/{value1}/{key2}/{value2}/...\n    String subPath = requestURI.substring(baseURIPath.length());\n    // \u53bb\u6389\u672b\u5c3e\u7684/\n    if (subPath.endsWith(\"/\")) {\n        subPath = subPath.substring(0, subPath.length() - 1);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "resolveExtraTagsFromURI", "reference": "    }\n\n    String[] ss = StringUtils.split(subPath, '/');\n    if (ss.length % 2 != 0) {\n        throw new IllegalArgumentException(\"\u5b50\u8def\u5f84\u5fc5\u987b\u6709\u5076\u6570\u4e2a\u8282\");\n    }\n    for (int i = 0; i < ss.length; i += 2) {\n        map.put(ss[i], ss[i + 1]);\n    }\n}", "completions": ["```Java\n    }\n    // \u5206\u5272\u8def\u5f84\n    String[] splitPath = StringUtils.split(subPath, \"/\");\n    if (splitPath.length % 2 != 0) {\n        throw new IllegalArgumentException(\"Number of nodes in the subpath is not even\");\n    }\n    // \u89e3\u6790extra tags\n    for (int i = 0; i < splitPath.length; i += 2) {\n        map.put(splitPath[i], splitPath[i + 1]);\n    }\n}\n```\n"]}
{"id": 24, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n// Copyright 2017 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.tmch;\n\nimport static com.google.common.base.MoreObjects.toStringHelper;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.re2j.Pattern;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.Immutable;\nimport org.joda.time.DateTime;\n\n/**\n * Parser of LORDN log responses from the MarksDB server during the NORDN process.\n *\n * @see <a href=\"http://tools.ietf.org/html/draft-lozano-tmch-func-spec-08#section-6.3.1\">\n *     TMCH functional specifications - LORDN Log File</a>\n */\n@Immutable\npublic final class LordnLog implements Iterable<Entry<String, LordnLog.Result>> {\n\n  /** Indicates whether or not the LORDN upload succeeded. */\n  public enum Status { ACCEPTED, REJECTED }\n\n  /** Result code for individual DN lines. */\n  @Immutable\n  public static final class Result {\n\n    /** Outcome categories for individual DN lines. */\n    public enum Outcome { OK, WARNING, ERROR }\n\n    private final int code;\n    private final String description;\n    private final Outcome outcome;\n\n    private Result(int code, String description) {\n      this.code = code;\n      this.description = description;\n      if (2000 <= code && code <= 2099) {\n        this.outcome = Outcome.OK;\n      } else if (3500 <= code && code <= 3699) {\n        this.outcome = Outcome.WARNING;\n      } else if (4500 <= code && code <= 4699) {\n        this.outcome = Outcome.ERROR;\n      } else {\n        throw new IllegalArgumentException(\"Invalid DN result code: \" + code);\n      }\n    }\n\n    public int getCode() {\n      return code;\n    }\n\n    public String getDescription() {\n      return description;\n    }\n\n    public Outcome getOutcome() {\n      return outcome;\n    }\n\n    @Override\n    public String toString() {\n      return toStringHelper(this)\n          .add(\"code\", code)\n          .add(\"outcome\", outcome)\n          .add(\"description\", description)\n          .toString();\n    }\n  }\n\n  private static final ImmutableMap<Integer, Result> RESULTS =\n      new ImmutableMap.Builder<Integer, Result>()\n          .put(2000, new Result(2000, \"OK\"))\n          .put(2001, new Result(2001, \"OK but not processed\"))\n          .put(3601, new Result(3601, \"TCN Acceptance Date after Registration Date\"))\n          .put(3602, new Result(3602, \"Duplicate DN Line\"))\n          .put(3603, new Result(3603, \"DNROID Notified Earlier\"))\n          .put(3604, new Result(3604, \"TCN Checksum invalid\"))\n          .put(3605, new Result(3605, \"TCN Expired\"))\n          .put(3606, new Result(3606, \"Wrong TCNID used\"))\n          .put(3609, new Result(3609, \"Invalid SMD used\"))\n          .put(3610, new Result(3610, \"DN reported outside of the time window\"))\n          .put(3611, new Result(3611, \"DN does not match the labels in SMD\"))\n          .put(3612, new Result(3612, \"SMDID does not exist\"))\n          .put(3613, new Result(3613, \"SMD was revoked when used\"))\n          .put(3614, new Result(3614, \"TCNID does not exist\"))\n          .put(3615, new Result(3615, \"Recent-dnl-insertion outside of the time window\"))\n          .put(\n              3616, new Result(3616, \"Registration Date of DN in claims before the end of Sunrise\"))\n          .put(3617, new Result(3617, \"Registrar has not been approved by the TMDB\"))\n          .put(3618, new Result(3618, \"Registration Date of DN outside of QLP period\"))\n          .put(3619, new Result(3619, \"TCN was not valid at the time of acknowledgement\"))\n          .put(4501, new Result(4501, \"Syntax Error in DN Line\"))\n          .put(4601, new Result(4601, \"Invalid TLD used\"))\n          .put(4602, new Result(4602, \"Registrar ID Invalid\"))\n          .put(4603, new Result(4603, \"Registration Date in the future\"))\n          .put(4606, new Result(4606, \"TLD not in Sunrise or Claims\"))\n          .put(4607, new Result(4607, \"Application Date in the future\"))\n          .put(4608, new Result(4608, \"Application Date is later than Registration Date\"))\n          .put(4609, new Result(4609, \"TCNID wrong syntax\"))\n          .put(4610, new Result(4610, \"TCN Acceptance Date is in the future\"))\n          .put(4611, new Result(4611, \"Label has never existed in the TMDB\"))\n          .build();\n\n  /** Base64 matcher between one and sixty characters. */\n  private static final Pattern LOG_ID_PATTERN = Pattern.compile(\"[-A-Za-z0-9+/=]{1,60}\");\n\n  private final String logId;\n  private final Status status;\n  private final DateTime logCreation;\n  private final DateTime lordnCreation;\n  private final boolean hasWarnings;\n  private final ImmutableMap<String, Result> results;\n\n  private LordnLog(\n      String logId,\n      Status status,\n      DateTime logCreation,\n      DateTime lordnCreation,\n      boolean hasWarnings,\n      ImmutableMap<String, Result> results) {\n    this.logId = logId;\n    this.status = status;\n    this.logCreation = logCreation;\n    this.lordnCreation = lordnCreation;\n    this.hasWarnings = hasWarnings;\n    this.results = results;\n  }\n\n  public String getLogId() {\n    return logId;\n  }\n\n  public Status getStatus() {\n    return status;\n  }\n\n  public DateTime getLogCreation() {\n    return logCreation;\n  }\n\n  public DateTime getLordnCreation() {\n    return lordnCreation;\n  }\n\n  public boolean hasWarnings() {\n    return hasWarnings;\n  }\n\n  @Nullable\n  public Result getResult(String roid) {\n    return results.get(roid);\n  }\n\n  @Override\n  public Iterator<Entry<String, Result>> iterator() {\n    return results.entrySet().iterator();\n  }\n\n  @Override\n  public String toString() {\n    return toStringHelper(this)\n        .add(\"logId\", logId)\n        .add(\"status\", status)\n        .add(\"logCreation\", logCreation)\n        .add(\"lordnCreation\", lordnCreation)\n        .add(\"hasWarnings\", hasWarnings)\n        .add(\"results\", results)\n        .toString();\n  }\n\n  /** Turns lines of NORDN log returned by MarksDB into a data structure. */\n```\n\n### Code description\n```Java\n/**\n * Parses a list of strings into a LordnLog object.\n *\n * The first line of the list should contain seven comma-separated elements:\n * 1. version of the file\n * 2. date and time in UTC that the LORDN Log was created\n * 3. date and time in UTC of creation for the LORDN file that this log file is referring to\n * 4. unique identifier of the LORDN Log provided by the TMDB\n * 5. whether the LORDN file has been accepted for processing by the TMDB\n * 6. whether the LORDN Log has any warning result codes\n * 7. number of DNs effective allocations processed in the LORDN file\n *\n * The second line should contain the headers \"roid,result-code\".\n *\n * Subsequent lines should contain a comma-separated pair of ROID and result code.\n *\n * @param lines The list of strings to parse.\n * @return A LordnLog object parsed from the list of strings.\n * @throws IllegalArgumentException If the list of strings does not meet the expected format.\n */\n```\n\n### Code snippet:\n```Java\npublic static LordnLog parse(List<String> lines) {\n  // First line: <version>,<LORDN Log creation datetime>,<LORDN file creation datetime>,\n  //             <LORDN Log Identifier>,<Status flag>,<Warning flag>,<Number of DN Lines>\n  List<String> firstLine = Splitter.on(',').splitToList(lines.get(0));\n  checkArgument(firstLine.size() == 7, String.format(\n      \"Line 1: Expected 7 elements, found %d\", firstLine.size()));\n\n  // +  <version>, version of the file, this field MUST be 1.\n  int version = Integer.parseInt(firstLine.get(0));\n  checkArgument(version == 1, String.format(\n      \"Line 1: Expected version 1, found %d\", version));\n\n  // +  <LORDN Log creation datetime>, date and time in UTC that the\n  //    LORDN Log was created.\n  DateTime logCreation = DateTime.parse(firstLine.get(1));\n\n  // +  <LORDN file creation datetime>, date and time in UTC of\n  //    creation for the LORDN file that this log file is referring\n  //    to.\n  DateTime lordnCreation = DateTime.parse(firstLine.get(2));\n\n  // +  <LORDN Log Identifier>, unique identifier of the LORDN Log\n  //    provided by the TMDB.  This identifier could be used by the\n  //    Registry Operator to unequivocally identify the LORDN Log.\n  //    The identified will be a string of a maximum LENGTH of 60\n  //    characters from the Base 64 alphabet.\n  String logId = firstLine.get(3);\n  checkArgument(LOG_ID_PATTERN.matcher(logId).matches(),\n      \"Line 1: Log ID does not match base64 pattern: %s\", logId);\n\n  // +  <Status flag>, whether the LORDN file has been accepted for\n  //    processing by the TMDB.  Possible values are \"accepted\" or\n  //    \"rejected\".\n  Status status = Status.valueOf(Ascii.toUpperCase(firstLine.get(4)));\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "parse", "reference": "\n  // +  <Warning flag>, whether the LORDN Log has any warning result\n  //    codes.  Possible values are \"no-warnings\" or \"warnings-\n  //    present\".\n  boolean hasWarnings = !\"no-warnings\".equals(firstLine.get(5));\n\n  // +  <Number of DN Lines>, number of DNs effective allocations\n  //    processed in the LORDN file.\n  int dnLines = Integer.parseInt(firstLine.get(6));\n  int actual = lines.size() - 2;\n  checkArgument(\n      dnLines == actual,\n      \"Line 1: Number of entries (%s) differs from declaration (%s)\",\n      String.valueOf(actual),\n      String.valueOf(dnLines));\n\n  // Second line contains headers: roid,result-code\n  checkArgument(lines.get(1).equals(\"roid,result-code\"),\n      \"Line 2: Unexpected header list: %s\", lines.get(1));\n\n  // Subsequent lines: <roid>,<result code>\n  ImmutableMap.Builder<String, Result> builder = new ImmutableMap.Builder<>();\n  for (int i = 2; i < lines.size(); i++) {\n    List<String> currentLine = Splitter.on(',').splitToList(lines.get(i));\n    checkArgument(currentLine.size() == 2, String.format(\n        \"Line %d: Expected 2 elements, found %d\", i + 1, currentLine.size()));\n    String roid = currentLine.get(0);\n    int code = Integer.parseInt(currentLine.get(1));\n    Result result = checkNotNull(RESULTS.get(code), \"Line %s: Unknown result code: %s\", i, code);\n    builder.put(roid, result);\n  }\n\n  return new LordnLog(logId, status, logCreation, lordnCreation, hasWarnings, builder.build());\n}", "completions": ["```Java\n  // +  <Status flag>, whether the LORDN file has been accepted for processing by the TMDB.  Possible values are \"accepted\" or \"rejected\".\n  Status status = Status.valueOf(Ascii.toUpperCase(firstLine.get(4)));\n\n  // +  <Warning flag>, whether the LORDN Log has any warning result codes.  Possible values are \"true\" or \"false\".\n  boolean hasWarnings = \"true\".equals(firstLine.get(5));\n\n  // +  <Number of DN Lines>, number of DNs effective allocations processed in the LORDN file.\n  int numberOfDnLines = Integer.parseInt(firstLine.get(6));\n\n  // Create a map to hold the results.\n  ImmutableMap.Builder<String, Result> resultsBuilder = new ImmutableMap.Builder<>();\n\n  // The rest of the lines are the results.\n  for (int i = 7; i < lines.size(); i++) {\n    List<String> resultLine = Splitter.on(',').splitToList(lines.get(i));\n    checkArgument(resultLine.size() == 2, String.format(\n        \"Line %d: Expected 2 elements, found %d\", i, resultLine.size()));\n\n    // +  <ROID>, unique identifier of the DN.\n    String roid = resultLine.get(0);\n\n    // +  <Result code>, result code for the DN.\n    int resultCode = Integer.parseInt(resultLine.get(1));\n\n    // Create a new result.\n    Result result = RESULTS.get(resultCode);\n    if (result == null) {\n      throw new IllegalArgumentException(String.format(\n          \"Line %d: Invalid result code: %d\", i, resultCode));\n    }\n\n    // Add the result to the map.\n    resultsBuilder.put(roid, result);\n  }\n\n  // Build the map.\n  ImmutableMap<String, Result> results = resultsBuilder.build();\n\n  // Return the LordnLog object.\n  return new LordnLog(logId, status, logCreation, lordnCreation, hasWarnings, results);\n}\n```\n"]}
{"id": 25, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.jet.impl.util;\n\nimport com.hazelcast.cluster.Address;\nimport com.hazelcast.jet.JetException;\nimport com.hazelcast.jet.JetInstance;\nimport com.hazelcast.jet.config.EdgeConfig;\nimport com.hazelcast.jet.config.JobConfig;\nimport com.hazelcast.jet.config.ProcessingGuarantee;\nimport com.hazelcast.jet.core.DAG;\nimport com.hazelcast.jet.core.Vertex;\nimport com.hazelcast.jet.core.Watermark;\nimport com.hazelcast.jet.function.RunnableEx;\nimport com.hazelcast.jet.impl.JetEvent;\nimport com.hazelcast.jet.impl.JetService;\nimport com.hazelcast.logging.ILogger;\nimport com.hazelcast.nio.serialization.DataSerializable;\nimport com.hazelcast.spi.impl.NodeEngine;\n\nimport javax.annotation.CheckReturnValue;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InvalidClassException;\nimport java.io.NotSerializableException;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.function.ToIntFunction;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.hazelcast.jet.Util.entry;\nimport static com.hazelcast.jet.Util.idToString;\nimport static com.hazelcast.jet.core.Edge.between;\nimport static com.hazelcast.jet.core.processor.SinkProcessors.writeMapP;\nimport static com.hazelcast.jet.core.processor.SourceProcessors.readMapP;\nimport static com.hazelcast.jet.impl.util.ExceptionUtil.sneakyThrow;\nimport static java.lang.Math.abs;\nimport static java.nio.file.LinkOption.NOFOLLOW_LINKS;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.stream.Collectors.groupingBy;\nimport static java.util.stream.Collectors.mapping;\nimport static java.util.stream.IntStream.range;\n\npublic final class Util {\n\n    private static final DateTimeFormatter LOCAL_TIME_FORMATTER = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n    private static final Pattern TRAILING_NUMBER_PATTERN = Pattern.compile(\"(.*)-([0-9]+)\");\n\n    private Util() {\n    }\n\n    public static <T> Supplier<T> memoize(Supplier<T> onceSupplier) {\n        return new MemoizingSupplier<>(onceSupplier);\n    }\n\n    public static <T> Supplier<T> memoizeConcurrent(Supplier<T> onceSupplier) {\n        return new ConcurrentMemoizingSupplier<>(onceSupplier);\n    }\n\n    public static <T> T uncheckCall(@Nonnull Callable<T> callable) {\n        try {\n            return callable.call();\n        } catch (Exception e) {\n            throw sneakyThrow(e);\n        }\n    }\n\n    public static void uncheckRun(@Nonnull RunnableEx r) {\n        r.run();\n    }\n\n    /**\n     * Atomically increment the {@code value} by {@code increment}, unless\n     * the value after increment would exceed the {@code limit}.\n     *\n     * @param limit maximum value the {@code value} can take (inclusive)\n     * @return {@code true}, if successful, {@code false}, if {@code limit} would be exceeded.\n     */\n    @CheckReturnValue\n    public static boolean tryIncrement(AtomicInteger value, int increment, int limit) {\n        int prev;\n        int next;\n        do {\n            prev = value.get();\n            next = prev + increment;\n            if (next > limit) {\n                return false;\n            }\n        } while (!value.compareAndSet(prev, next));\n        return true;\n    }\n\n    public static JetInstance getJetInstance(NodeEngine nodeEngine) {\n        return nodeEngine.<JetService>getService(JetService.SERVICE_NAME).getJetInstance();\n    }\n\n    public static long addClamped(long a, long b) {\n        long sum = a + b;\n        return sumHadOverflow(a, b, sum)\n                ? (a >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE)\n                : sum;\n    }\n\n    /**\n     * Calculates {@code a - b}, returns {@code Long.MAX_VALUE} or {@code\n     * Long.MIN_VALUE} if the result would overflow.\n     *\n     * @param a the amount\n     * @param b the value to subtract\n     * @return {@code a - b}, clamped\n     */\n    public static long subtractClamped(long a, long b) {\n        long diff = a - b;\n        return diffHadOverflow(a, b, diff)\n                ? (a >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE)\n                : diff;\n    }\n\n    // Hacker's Delight, 2nd Ed, 2-13: overflow has occurred iff\n    // operands have the same sign which is opposite of the result\n    public static boolean sumHadOverflow(long a, long b, long sum) {\n        return ((a ^ sum) & (b ^ sum)) < 0;\n    }\n\n    // Hacker's Delight, 2nd Ed, 2-13: overflow has occurred iff operands have\n    // opposite signs and result has opposite sign of left-hand operand\n    private static boolean diffHadOverflow(long a, long b, long diff) {\n        return ((a ^ b) & (a ^ diff)) < 0;\n    }\n\n    /**\n     * Checks that the {@code object} implements {@link Serializable} or {@link\n     * DataSerializable}. In case of {@code Serializable}, it additionally\n     * checks it is correctly serializable by actually trying to serialize it.\n     * This will reveal a non-serializable field early.\n     *\n     * @param object     object to check\n     * @param objectName object description for the exception\n     * @return given object\n     * @throws IllegalArgumentException if {@code object} is not serializable\n     */\n    @Nullable\n    public static <T> T checkSerializable(@Nullable T object, @Nonnull String objectName) {\n        if (object == null) {\n            return null;\n        }\n        if (object instanceof DataSerializable) {\n            // hz-serialization is implemented, but we cannot actually check it - we don't have a\n            // SerializationService at hand.\n            return object;\n        }\n        if (!(object instanceof Serializable)) {\n            throw new IllegalArgumentException('\"' + objectName + \"\\\" must implement Serializable\");\n        }\n        try (ObjectOutputStream os = new ObjectOutputStream(new NullOutputStream())) {\n            os.writeObject(object);\n        } catch (NotSerializableException | InvalidClassException e) {\n            throw new IllegalArgumentException(\"\\\"\" + objectName + \"\\\" must be serializable\", e);\n        } catch (IOException e) {\n            // never really thrown, as the underlying stream never throws it\n            throw new JetException(e);\n        }\n        return object;\n    }\n\n    /**\n     * Checks that the {@code object} is not null and implements\n     * {@link Serializable} and is correctly serializable by actually\n     * trying to serialize it. This will reveal some non-serializable\n     * field early.\n     * <p>\n     * Usage:\n     * <pre>{@code\n     * void setValue(@Nonnull Object value) {\n     *     this.value = checkNonNullAndSerializable(value, \"value\");\n     * }\n     * }</pre>\n     *\n     * @param object     object to check\n     * @param objectName object description for the exception\n     * @return given object\n     * @throws IllegalArgumentException if {@code object} is not serializable\n     */\n    @Nonnull\n    public static <T> T checkNonNullAndSerializable(@Nonnull T object, @Nonnull String objectName) {\n        //noinspection ConstantConditions\n        if (object == null) {\n            throw new IllegalArgumentException('\"' + objectName + \"\\\" must not be null\");\n        }\n        checkSerializable(object, objectName);\n        return object;\n    }\n\n    /**\n     * Distributes the {@code objects} to {@code count} processors in a\n     * round-robin fashion. If the object count is smaller than processor\n     * count, an empty list is put for the rest of the processors.\n     *\n     * @param count   count of processors\n     * @param objects list of objects to distribute\n     * @return a map which has the processor index as the key and a list of objects as\n     * the value\n     */\n    public static <T> Map<Integer, List<T>> distributeObjects(int count, List<T> objects) {\n        Map<Integer, List<T>> processorToObjects = range(0, objects.size())\n                .mapToObj(i -> entry(i, objects.get(i)))\n                .collect(groupingBy(e -> e.getKey() % count, mapping(Map.Entry::getValue, Collectors.toList())));\n\n        for (int i = 0; i < count; i++) {\n            processorToObjects.putIfAbsent(i, emptyList());\n        }\n        return processorToObjects;\n    }\n\n    /**\n     * From an imaginary set of integers {@code (0, 1, ..., objectCount-1)}\n     * returns {@code index}-th disjoint subset out of {@code count} subsets.\n     * The assignment of objects to subset is done in round-robin fashion.\n     * <p>\n     * For example, if {@code objectCount==3} and {@code count==2}, then for\n     * {@code index==0} it will return {@code {0, 2}} and for {@code index==1}\n     * it will return {@code {1}}.\n     * <p>\n     * It's used to assign partitions to processors.\n     *\n     * @param objectCount total number of objects to distribute\n     * @param count       total number of subsets\n     * @param index       index of the requested subset\n     * @return an array with assigned objects\n     */\n    public static int[] roundRobinPart(int objectCount, int count, int index) {\n        if (objectCount < 0 || index < 0 || count < 1 || index >= count) {\n            throw new IllegalArgumentException(\"objectCount=\" + objectCount + \", count=\" + count + \", index=\" + index);\n        }\n\n        int[] res = new int[objectCount / count + (objectCount % count > index ? 1 : 0)];\n        for (int i = 0, j = index; j < objectCount; i++, j += count) {\n            res[i] = j;\n        }\n        return res;\n    }\n\n    private static class NullOutputStream extends OutputStream {\n        @Override\n        public void write(int b) {\n            // do nothing\n        }\n    }\n\n    public static String jobNameAndExecutionId(String jobName, long executionId) {\n        return \"job '\" + jobName + \"', execution \" + idToString(executionId);\n    }\n\n    public static String jobIdAndExecutionId(long jobId, long executionId) {\n        return \"job \" + idToString(jobId) + \", execution \" + idToString(executionId);\n    }\n\n    private static ZonedDateTime toZonedDateTime(long timestamp) {\n        return Instant.ofEpochMilli(timestamp).atZone(ZoneId.systemDefault());\n    }\n\n    public static LocalDateTime toLocalDateTime(long timestamp) {\n        return toZonedDateTime(timestamp).toLocalDateTime();\n    }\n\n    public static String toLocalTime(long timestamp) {\n        return toZonedDateTime(timestamp).toLocalTime().format(LOCAL_TIME_FORMATTER);\n    }\n\n    /**\n     * Sequentially search through an array, return the index of first {@code\n     * needle} element in {@code haystack} or -1, if not found.\n     */\n    public static int arrayIndexOf(int needle, int[] haystack) {\n        for (int i = 0; i < haystack.length; i++) {\n            if (haystack[i] == needle) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Creates a copy of the {@code array} with length increased by {@code\n     * extendBy}. The added elements will contain {@code null}s. If {@code\n     * extendBy == 0}, no copy is created.\n     */\n    public static Object[] extendArray(Object[] array, int extendBy) {\n        assert extendBy > -1;\n        return extendBy == 0 ? array : Arrays.copyOf(array, array.length + extendBy);\n    }\n\n    /**\n     * Returns a future which is already completed with the supplied exception.\n     */\n    // replace with CompletableFuture.failedFuture(e) once we depend on java9+\n    public static <T> CompletableFuture<T> exceptionallyCompletedFuture(@Nonnull Throwable exception) {\n        CompletableFuture<T> future = new CompletableFuture<>();\n        future.completeExceptionally(exception);\n        return future;\n    }\n\n    /**\n     * Logs a late event that was dropped.\n     */\n    public static void logLateEvent(ILogger logger, long currentWm, @Nonnull Object item) {\n        if (!logger.isInfoEnabled()) {\n            return;\n        }\n        if (item instanceof JetEvent) {\n            JetEvent event = (JetEvent) item;\n            logger.info(\n                    String.format(\"Event dropped, late by %d ms. currentWatermark=%s, eventTime=%s, event=%s\",\n                            currentWm - event.timestamp(), toLocalTime(currentWm), toLocalTime(event.timestamp()),\n                            event.payload()\n                    ));\n        } else {\n            logger.info(String.format(\n                    \"Late event dropped. currentWatermark=%s, event=%s\", new Watermark(currentWm), item\n            ));\n        }\n    }\n\n    /**\n     * Calculate greatest common divisor of a series of integer numbers. Returns\n     * 0, if the number of values is 0.\n     */\n    public static long gcd(long... values) {\n        long res = 0;\n        for (long value : values) {\n            res = gcd(res, value);\n        }\n        return res;\n    }\n\n    /**\n     * Calculate greatest common divisor of two integer numbers.\n     */\n    public static long gcd(long a, long b) {\n        a = abs(a);\n        b = abs(b);\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void lazyIncrement(AtomicLongArray counters, int index) {\n        lazyAdd(counters, index, 1);\n    }\n\n    /**\n     * Adds {@code addend} to the counter, using {@code lazySet}. Useful for\n     * incrementing {@linkplain com.hazelcast.internal.metrics.Probe probes}\n     * if only one thread is updating the value.\n     */\n    public static void lazyAdd(AtomicLongArray counters, int index, long addend) {\n        counters.lazySet(index, counters.get(index) + addend);\n    }\n\n    /**\n     * Adds items of the collection. Faster than {@code\n     * collection.stream().mapToInt(toIntF).sum()} and equal to plain old loop\n     * in performance. Crates no GC litter (if you use non-capturing lambda for\n     * {@code toIntF}, else new lambda instance is created for each call).\n     */\n    public static <E> int sum(Collection<E> collection, ToIntFunction<E> toIntF) {\n        int sum = 0;\n        for (E e : collection) {\n            sum += toIntF.applyAsInt(e);\n        }\n        return sum;\n    }\n\n    /**\n     * Escapes the vertex name for graphviz by prefixing the quote character\n     * with backslash.\n     */\n    public static String escapeGraphviz(String value) {\n        return value.replace(\"\\\"\", \"\\\\\\\"\");\n    }\n\n    @SuppressWarnings(\"WeakerAccess\")  // used in jet-enterprise\n    public static CompletableFuture<Void> copyMapUsingJob(JetInstance instance, int queueSize,\n                                                          String sourceMap, String targetMap) {\n        DAG dag = new DAG();\n        Vertex source = dag.newVertex(\"readMap(\" + sourceMap + ')', readMapP(sourceMap));\n        Vertex sink = dag.newVertex(\"writeMap(\" + targetMap + ')', writeMapP(targetMap));\n        dag.edge(between(source, sink).setConfig(new EdgeConfig().setQueueSize(queueSize)));\n        JobConfig jobConfig = new JobConfig()\n                .setName(\"copy-\" + sourceMap + \"-to-\" + targetMap);\n        return instance.newJob(dag, jobConfig).getFuture();\n    }\n\n    /**\n     * If the name ends with \"-N\", returns a new name where \"-N\" is replaced\n     * with \"-M\" where M = N + 1. If N is too large for {@code int}, negative,\n     * unparseable, not present or smaller than 2, then it's ignored and just\n     * \"-2\" is appended.\n     */\n    public static String addOrIncrementIndexInName(String name) {\n        Matcher m = TRAILING_NUMBER_PATTERN.matcher(name);\n        int index = 2;\n        if (m.matches()) {\n            try {\n                int newIndex = Integer.parseInt(m.group(2)) + 1;\n                if (newIndex > 2) {\n                    index = newIndex;\n                    name = m.group(1);\n                }\n            } catch (NumberFormatException ignored) {\n            }\n        }\n        return name + '-' + index;\n    }\n\n    public static void doWithClassLoader(ClassLoader cl, RunnableEx action) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader previousCl = currentThread.getContextClassLoader();\n        currentThread.setContextClassLoader(cl);\n        try {\n            action.run();\n        } finally {\n            currentThread.setContextClassLoader(previousCl);\n        }\n    }\n\n    /**\n     * Returns the lower of the given guarantees.\n     */\n    public static ProcessingGuarantee min(ProcessingGuarantee g1, ProcessingGuarantee g2) {\n        return g1.ordinal() < g2.ordinal() ? g1 : g2;\n    }\n\n    /**\n     * Returns elements of the given {@code coll} in a new {@code List}, mapped\n     * using the given {@code mapFn}.\n     */\n    @Nonnull\n    public static <T, R> List<R> toList(@Nonnull Collection<T> coll, @Nonnull Function<? super T, ? extends R> mapFn) {\n        return coll.stream().map(mapFn).collect(Collectors.toList());\n    }\n\n    /**\n     * Edits the permissions on the file denoted by {@code path} by calling\n     * {@code editFn} with the set of that file's current permissions. {@code\n     * editFn} should modify that set to the desired permission set, and this\n     * method will propagate them to the file. If {@code editFn} returns {@code\n     * false}, the file will be left untouched. Returning {@code false} is an\n     * optimization feature because it avoids the expensive filesystem\n     * operation; if you always return {@code true}, this method will still\n     * behave correctly.\n     */\n    public static void editPermissions(\n            @Nonnull Path path, @Nonnull Predicate<? super Set<PosixFilePermission>> editFn\n    ) throws IOException {\n        Set<PosixFilePermission> perms = Files.getPosixFilePermissions(path, NOFOLLOW_LINKS);\n        if (editFn.test(perms)) {\n            Files.setPosixFilePermissions(path, perms);\n        }\n    }\n\n    /**\n     * Edits the permissions on all the files in the {@code basePath} and\n     * its subdirectories. It calls {@link #editPermissions} with every file.\n     *\n     * @param basePath the directory where to edit the file permissions\n     * @param editFn   the permission-editing function, described above\n     * @return the list of all relative path names of files for which editing\n     * permissions failed\n     * @throws IOException if the directory's contents cannot be traversed\n     */\n    public static List<String> editPermissionsRecursively(\n            @Nonnull Path basePath,\n            @Nonnull Predicate<? super Set<PosixFilePermission>> editFn\n    ) throws IOException {\n        List<String> filesNotMarked = new ArrayList<>();\n        try (Stream<Path> walk = Files.walk(basePath)) {\n            walk.forEach(path -> {\n                try {\n                    editPermissions(path, editFn);\n                } catch (Exception e) {\n                    filesNotMarked.add(basePath.relativize(path).toString());\n                }\n            });\n        }\n        return filesNotMarked;\n    }\n\n    /**\n     * Formats a duration given im milliseconds to the form of:\n     * <ul>\n     *     <li>{@code HH:MM:SS.sss}, if <24 hours\n     *     <li>{@code Nd HH:MM:SS.sss} otherwise\n     * </ul>\n     */\n    @Nonnull\n    @SuppressWarnings(\"checkstyle:MagicNumber\") // number of hours per day isn't magic :)\n    public static String formatJobDuration(long durationMs) {\n        if (durationMs == Long.MIN_VALUE) {\n            return \"\" + Long.MIN_VALUE;\n        }\n        String sign = \"\";\n        if (durationMs < 0) {\n            sign = \"-\";\n            durationMs = -durationMs;\n        }\n        long millis = durationMs % 1000;\n        durationMs /= 1000;\n        long seconds = durationMs % 60;\n        durationMs /= 60;\n        long minutes = durationMs % 60;\n        durationMs /= 60;\n        long hours = durationMs % 24;\n        durationMs /= 24;\n        String textUpToHours = String.format(\"%02d:%02d:%02d.%03d\", hours, minutes, seconds, millis);\n        return sign + (durationMs > 0 ? durationMs + \"d \" : \"\") + textUpToHours;\n    }\n\n    /**\n     * Assigns given partitions to given {@code members}.\n     * Set of partitions belonging to non-members are assigned to\n     * {@code members} in a round robin fashion.\n     */\n```\n\n### Code description\n```Java\n/**\n * Assigns partitions to members based on their ownership.\n *\n * @param members0 The collection of members to assign partitions to.\n * @param partitionsByOwner A map containing the partitions owned by each member.\n * @return A map where each member is associated with a list of partitions they own.\n * @throws IllegalArgumentException If the collection of members is empty.\n */\n```\n\n### Code snippet:\n```Java\npublic static Map<Address, List<Integer>> assignPartitions(\n        Collection<Address> members0,\n        Map<Address, List<Integer>> partitionsByOwner\n) {\n    assert !members0.isEmpty();\n\n    LinkedHashSet<Address> members = new LinkedHashSet<>(members0);\n\n    Iterator<Address> iterator = members.iterator();\n\n    Map<Address, List<Integer>> partitionsByMember = new HashMap<>();\n    for (Entry<Address, List<Integer>> entry : partitionsByOwner.entrySet()) {\n        Address partitionOwner = entry.getKey();\n        List<Integer> partitions = entry.getValue();\n\n        Address target;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "assignPartitions", "reference": "        if (members.contains(partitionOwner)) {\n            target = partitionOwner;\n        } else {\n            if (!iterator.hasNext()) {\n                iterator = members.iterator();\n            }\n            target = iterator.next();\n        }\n\n        partitionsByMember.merge(target, new ArrayList<>(partitions), (existing, incoming) -> {\n            existing.addAll(incoming);\n            return existing;\n        });\n    }\n    return partitionsByMember;\n}", "completions": ["```markdown\n```java\npublic static Map<Address, List<Integer>> assignPartitions(\n        Collection<Address> members0,\n        Map<Address, List<Integer>> partitionsByOwner\n) {\n    assert !members0.isEmpty();\n\n    LinkedHashSet<Address> members = new LinkedHashSet<>(members0);\n\n    Iterator<Address> iterator = members.iterator();\n\n    Map<Address, List<Integer>> partitionsByMember = new HashMap<>();\n    for (Entry<Address, List<Integer>> entry : partitionsByOwner.entrySet()) {\n        Address partitionOwner = entry.getKey();\n        List<Integer> partitions = entry.getValue();\n\n        Address target;\n        if (iterator.hasNext()) {\n            target = iterator.next();\n        } else {\n            iterator = members.iterator();\n            target = iterator.next();\n        }\n\n        partitionsByMember.put(target, partitions);\n    }\n\n    return partitionsByMember;\n}\n```\n```\n"]}
{"id": 26, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n *   or more contributor license agreements.  See the NOTICE file\n *   distributed with this work for additional information\n *   regarding copyright ownership.  The ASF licenses this file\n *   to you under the Apache License, Version 2.0 (the\n *   \"License\"); you may not use this file except in compliance\n *   with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\npackage org.apache.storm.kafka.spout;\n\nimport static org.apache.storm.kafka.spout.FirstPollOffsetStrategy.EARLIEST;\nimport static org.apache.storm.kafka.spout.FirstPollOffsetStrategy.LATEST;\nimport static org.apache.storm.kafka.spout.FirstPollOffsetStrategy.UNCOMMITTED_EARLIEST;\nimport static org.apache.storm.kafka.spout.FirstPollOffsetStrategy.UNCOMMITTED_LATEST;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport org.apache.commons.lang.Validate;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerRebalanceListener;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.InterruptException;\nimport org.apache.kafka.common.errors.RetriableException;\nimport org.apache.storm.kafka.spout.KafkaSpoutConfig.ProcessingGuarantee;\nimport org.apache.storm.kafka.spout.internal.CommitMetadataManager;\nimport org.apache.storm.kafka.spout.internal.ConsumerFactory;\nimport org.apache.storm.kafka.spout.internal.ConsumerFactoryDefault;\nimport org.apache.storm.kafka.spout.internal.OffsetManager;\nimport org.apache.storm.kafka.spout.internal.Timer;\nimport org.apache.storm.kafka.spout.metrics.KafkaOffsetMetric;\nimport org.apache.storm.kafka.spout.subscription.TopicAssigner;\nimport org.apache.storm.spout.SpoutOutputCollector;\nimport org.apache.storm.task.TopologyContext;\nimport org.apache.storm.topology.OutputFieldsDeclarer;\nimport org.apache.storm.topology.base.BaseRichSpout;\nimport org.apache.storm.utils.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaSpout<K, V> extends BaseRichSpout {\n\n    private static final long serialVersionUID = 4151921085047987154L;\n    //Initial delay for the commit and assignment refresh timers\n    public static final long TIMER_DELAY_MS = 500;\n    private static final Logger LOG = LoggerFactory.getLogger(KafkaSpout.class);\n\n    // Storm\n    protected SpoutOutputCollector collector;\n\n    // Kafka\n    private final KafkaSpoutConfig<K, V> kafkaSpoutConfig;\n    private final ConsumerFactory<K, V> kafkaConsumerFactory;\n    private final TopicAssigner topicAssigner;\n    private transient Consumer<K, V> consumer;\n\n    // Bookkeeping\n    // Strategy to determine the fetch offset of the first realized by the spout upon activation\n    private transient FirstPollOffsetStrategy firstPollOffsetStrategy;\n    // Class that has the logic to handle tuple failure.\n    private transient KafkaSpoutRetryService retryService;\n    // Handles tuple events (emit, ack etc.)\n    private transient KafkaTupleListener tupleListener;\n    // timer == null only if the processing guarantee is at-most-once\n    private transient Timer commitTimer;\n    // Initialization is only complete after the first call to  KafkaSpoutConsumerRebalanceListener.onPartitionsAssigned()\n\n    // Tuples that were successfully acked/emitted. These tuples will be committed periodically when the commit timer expires,\n    // or after a consumer rebalance, or during close/deactivate. Always empty if processing guarantee is none or at-most-once.\n    private transient Map<TopicPartition, OffsetManager> offsetManagers;\n    // Tuples that have been emitted but that are \"on the wire\", i.e. pending being acked or failed.\n    // Always empty if processing guarantee is none or at-most-once\n    private transient Set<KafkaSpoutMessageId> emitted;\n    // Records that have been polled and are queued to be emitted in the nextTuple() call. One record is emitted per nextTuple()\n    private transient Map<TopicPartition, List<ConsumerRecord<K, V>>> waitingToEmit;\n    // Triggers when an assignment should be refreshed\n    private transient Timer refreshAssignmentTimer;\n    private transient TopologyContext context;\n    private transient CommitMetadataManager commitMetadataManager;\n    private transient KafkaOffsetMetric<K, V> kafkaOffsetMetric;\n    private transient KafkaSpoutConsumerRebalanceListener rebalanceListener;\n\n    public KafkaSpout(KafkaSpoutConfig<K, V> kafkaSpoutConfig) {\n        this(kafkaSpoutConfig, new ConsumerFactoryDefault<>(), new TopicAssigner());\n    }\n\n    @VisibleForTesting\n    KafkaSpout(KafkaSpoutConfig<K, V> kafkaSpoutConfig, ConsumerFactory<K, V> kafkaConsumerFactory, TopicAssigner topicAssigner) {\n        this.kafkaConsumerFactory = kafkaConsumerFactory;\n        this.topicAssigner = topicAssigner;\n        this.kafkaSpoutConfig = kafkaSpoutConfig;\n    }\n\n    @Override\n    public void open(Map<String, Object> conf, TopologyContext context, SpoutOutputCollector collector) {\n        this.context = context;\n\n        // Spout internals\n        this.collector = collector;\n\n        // Offset management\n        firstPollOffsetStrategy = kafkaSpoutConfig.getFirstPollOffsetStrategy();\n\n        // Retries management\n        retryService = kafkaSpoutConfig.getRetryService();\n\n        tupleListener = kafkaSpoutConfig.getTupleListener();\n\n        if (kafkaSpoutConfig.getProcessingGuarantee() != KafkaSpoutConfig.ProcessingGuarantee.AT_MOST_ONCE) {\n            // In at-most-once mode the offsets are committed after every poll, and not periodically as controlled by the timer\n            commitTimer = new Timer(TIMER_DELAY_MS, kafkaSpoutConfig.getOffsetsCommitPeriodMs(), TimeUnit.MILLISECONDS);\n        }\n        refreshAssignmentTimer = new Timer(TIMER_DELAY_MS, kafkaSpoutConfig.getPartitionRefreshPeriodMs(), TimeUnit.MILLISECONDS);\n\n        offsetManagers = new HashMap<>();\n        emitted = new HashSet<>();\n        waitingToEmit = new HashMap<>();\n        commitMetadataManager = new CommitMetadataManager(context, kafkaSpoutConfig.getProcessingGuarantee());\n\n        rebalanceListener = new KafkaSpoutConsumerRebalanceListener();\n\n        consumer = kafkaConsumerFactory.createConsumer(kafkaSpoutConfig.getKafkaProps());\n\n        tupleListener.open(conf, context);\n        if (canRegisterMetrics()) {\n            registerMetric();\n        }\n\n        LOG.info(\"Kafka Spout opened with the following configuration: {}\", kafkaSpoutConfig);\n    }\n\n    private void registerMetric() {\n        LOG.info(\"Registering Spout Metrics\");\n        kafkaOffsetMetric = new KafkaOffsetMetric<>(() -> Collections.unmodifiableMap(offsetManagers), () -> consumer);\n        context.registerMetric(\"kafkaOffset\", kafkaOffsetMetric, kafkaSpoutConfig.getMetricsTimeBucketSizeInSecs());\n    }\n\n    private boolean canRegisterMetrics() {\n        try {\n            KafkaConsumer.class.getDeclaredMethod(\"beginningOffsets\", Collection.class);\n        } catch (NoSuchMethodException e) {\n            LOG.warn(\"Minimum required kafka-clients library version to enable metrics is 0.10.1.0. Disabling spout metrics.\");\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isAtLeastOnceProcessing() {\n        return kafkaSpoutConfig.getProcessingGuarantee() == KafkaSpoutConfig.ProcessingGuarantee.AT_LEAST_ONCE;\n    }\n\n    // =========== Consumer Rebalance Listener - On the same thread as the caller ===========\n    private class KafkaSpoutConsumerRebalanceListener implements ConsumerRebalanceListener {\n\n        private Collection<TopicPartition> previousAssignment = new HashSet<>();\n\n        @Override\n        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {\n            previousAssignment = partitions;\n\n            LOG.info(\"Partitions revoked. [consumer-group={}, consumer={}, topic-partitions={}]\",\n                kafkaSpoutConfig.getConsumerGroupId(), consumer, partitions);\n\n            if (isAtLeastOnceProcessing()) {\n                commitOffsetsForAckedTuples();\n            }\n        }\n\n        @Override\n        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n            LOG.info(\"Partitions reassignment. [task-ID={}, consumer-group={}, consumer={}, topic-partitions={}]\",\n                context.getThisTaskId(), kafkaSpoutConfig.getConsumerGroupId(), consumer, partitions);\n\n            initialize(partitions);\n            tupleListener.onPartitionsReassigned(partitions);\n        }\n\n        private void initialize(Collection<TopicPartition> partitions) {\n            if (isAtLeastOnceProcessing()) {\n                // remove offsetManagers for all partitions that are no longer assigned to this spout\n                offsetManagers.keySet().retainAll(partitions);\n                retryService.retainAll(partitions);\n\n                /*\n                 * Emitted messages for partitions that are no longer assigned to this spout can't be acked and should not be retried, hence\n                 * remove them from emitted collection.\n                 */\n                emitted.removeIf(msgId -> !partitions.contains(msgId.getTopicPartition()));\n            }\n            waitingToEmit.keySet().retainAll(partitions);\n\n            Set<TopicPartition> newPartitions = new HashSet<>(partitions);\n            // If this partition was previously assigned to this spout,\n            // leave the acked offsets and consumer position as they were to resume where it left off\n            newPartitions.removeAll(previousAssignment);\n            for (TopicPartition newTp : newPartitions) {\n                final OffsetAndMetadata committedOffset = consumer.committed(newTp);\n                final long fetchOffset = doSeek(newTp, committedOffset);\n                LOG.debug(\"Set consumer position to [{}] for topic-partition [{}] with [{}] and committed offset [{}]\",\n                    fetchOffset, newTp, firstPollOffsetStrategy, committedOffset);\n                if (isAtLeastOnceProcessing() && !offsetManagers.containsKey(newTp)) {\n                    offsetManagers.put(newTp, new OffsetManager(newTp, fetchOffset));\n                }\n            }\n            LOG.info(\"Initialization complete\");\n        }\n\n        /**\n         * Sets the cursor to the location dictated by the first poll strategy and returns the fetch offset.\n         */\n        private long doSeek(TopicPartition newTp, OffsetAndMetadata committedOffset) {\n            LOG.trace(\"Seeking offset for topic-partition [{}] with [{}] and committed offset [{}]\",\n                newTp, firstPollOffsetStrategy, committedOffset);\n\n            if (committedOffset != null) {\n                // offset was previously committed for this consumer group and topic-partition, either by this or another topology.\n                if (commitMetadataManager.isOffsetCommittedByThisTopology(newTp,\n                    committedOffset,\n                    Collections.unmodifiableMap(offsetManagers))) {\n                    // Another KafkaSpout instance (of this topology) already committed, therefore FirstPollOffsetStrategy does not apply.\n                    consumer.seek(newTp, committedOffset.offset());\n                } else {\n                    // offset was not committed by this topology, therefore FirstPollOffsetStrategy applies\n                    // (only when the topology is first deployed).\n                    if (firstPollOffsetStrategy.equals(EARLIEST)) {\n                        consumer.seekToBeginning(Collections.singleton(newTp));\n                    } else if (firstPollOffsetStrategy.equals(LATEST)) {\n                        consumer.seekToEnd(Collections.singleton(newTp));\n                    } else {\n                        // Resume polling at the last committed offset, i.e. the first offset that is not marked as processed.\n                        consumer.seek(newTp, committedOffset.offset());\n                    }\n                }\n            } else {\n                // no offset commits have ever been done for this consumer group and topic-partition,\n                // so start at the beginning or end depending on FirstPollOffsetStrategy\n                if (firstPollOffsetStrategy.equals(EARLIEST) || firstPollOffsetStrategy.equals(UNCOMMITTED_EARLIEST)) {\n                    consumer.seekToBeginning(Collections.singleton(newTp));\n                } else if (firstPollOffsetStrategy.equals(LATEST) || firstPollOffsetStrategy.equals(UNCOMMITTED_LATEST)) {\n                    consumer.seekToEnd(Collections.singleton(newTp));\n                }\n            }\n            return consumer.position(newTp);\n        }\n    }\n\n    // ======== Next Tuple =======\n    @Override\n    public void nextTuple() {\n        try {\n            if (refreshAssignmentTimer.isExpiredResetOnTrue()) {\n                refreshAssignment();\n            }\n\n            if (commitTimer != null && commitTimer.isExpiredResetOnTrue()) {\n                if (isAtLeastOnceProcessing()) {\n                    commitOffsetsForAckedTuples();\n                } else if (kafkaSpoutConfig.getProcessingGuarantee() == ProcessingGuarantee.NO_GUARANTEE) {\n                    Map<TopicPartition, OffsetAndMetadata> offsetsToCommit =\n                        createFetchedOffsetsMetadata(consumer.assignment());\n                    consumer.commitAsync(offsetsToCommit, null);\n                    LOG.debug(\"Committed offsets {} to Kafka\", offsetsToCommit);\n                }\n            }\n\n            PollablePartitionsInfo pollablePartitionsInfo = getPollablePartitionsInfo();\n            if (pollablePartitionsInfo.shouldPoll()) {\n                try {\n                    setWaitingToEmit(pollKafkaBroker(pollablePartitionsInfo));\n                } catch (RetriableException e) {\n                    LOG.error(\"Failed to poll from kafka.\", e);\n                }\n            }\n\n            emitIfWaitingNotEmitted();\n        } catch (InterruptException e) {\n            throwKafkaConsumerInterruptedException();\n        }\n    }\n\n    private void throwKafkaConsumerInterruptedException() {\n        //Kafka throws their own type of exception when interrupted.\n        //Throw a new Java InterruptedException to ensure Storm can recognize the exception as a reaction to an interrupt.\n        throw new RuntimeException(new InterruptedException(\"Kafka consumer was interrupted\"));\n    }\n\n    private PollablePartitionsInfo getPollablePartitionsInfo() {\n        if (isWaitingToEmit()) {\n            LOG.debug(\"Not polling. Tuples waiting to be emitted.\");\n            return new PollablePartitionsInfo(Collections.emptySet(), Collections.emptyMap());\n        }\n\n        Set<TopicPartition> assignment = consumer.assignment();\n        if (!isAtLeastOnceProcessing()) {\n            return new PollablePartitionsInfo(assignment, Collections.emptyMap());\n        }\n\n        Map<TopicPartition, Long> earliestRetriableOffsets = retryService.earliestRetriableOffsets();\n        Set<TopicPartition> pollablePartitions = new HashSet<>();\n        final int maxUncommittedOffsets = kafkaSpoutConfig.getMaxUncommittedOffsets();\n        for (TopicPartition tp : assignment) {\n            OffsetManager offsetManager = offsetManagers.get(tp);\n            int numUncommittedOffsets = offsetManager.getNumUncommittedOffsets();\n            if (numUncommittedOffsets < maxUncommittedOffsets) {\n                //Allow poll if the partition is not at the maxUncommittedOffsets limit\n                pollablePartitions.add(tp);\n            } else {\n                long offsetAtLimit = offsetManager.getNthUncommittedOffsetAfterCommittedOffset(maxUncommittedOffsets);\n                Long earliestRetriableOffset = earliestRetriableOffsets.get(tp);\n                if (earliestRetriableOffset != null && earliestRetriableOffset <= offsetAtLimit) {\n                    //Allow poll if there are retriable tuples within the maxUncommittedOffsets limit\n                    pollablePartitions.add(tp);\n                } else {\n                    LOG.debug(\"Not polling on partition [{}]. It has [{}] uncommitted offsets, which exceeds the limit of [{}]. \", tp,\n                        numUncommittedOffsets, maxUncommittedOffsets);\n                }\n            }\n        }\n        return new PollablePartitionsInfo(pollablePartitions, earliestRetriableOffsets);\n    }\n\n    private boolean isWaitingToEmit() {\n        return waitingToEmit.values().stream()\n            .anyMatch(list -> !list.isEmpty());\n    }\n\n    private void setWaitingToEmit(ConsumerRecords<K, V> consumerRecords) {\n        for (TopicPartition tp : consumerRecords.partitions()) {\n            waitingToEmit.put(tp, new LinkedList<>(consumerRecords.records(tp)));\n        }\n    }\n\n    // ======== poll =========\n    private ConsumerRecords<K, V> pollKafkaBroker(PollablePartitionsInfo pollablePartitionsInfo) {\n        doSeekRetriableTopicPartitions(pollablePartitionsInfo.pollableEarliestRetriableOffsets);\n        Set<TopicPartition> pausedPartitions = new HashSet<>(consumer.assignment());\n        pausedPartitions.removeIf(pollablePartitionsInfo.pollablePartitions::contains);\n        try {\n            consumer.pause(pausedPartitions);\n            final ConsumerRecords<K, V> consumerRecords = consumer.poll(kafkaSpoutConfig.getPollTimeoutMs());\n            ackRetriableOffsetsIfCompactedAway(pollablePartitionsInfo.pollableEarliestRetriableOffsets, consumerRecords);\n            final int numPolledRecords = consumerRecords.count();\n            LOG.debug(\"Polled [{}] records from Kafka\",\n                numPolledRecords);\n            if (kafkaSpoutConfig.getProcessingGuarantee() == KafkaSpoutConfig.ProcessingGuarantee.AT_MOST_ONCE) {\n                //Commit polled records immediately to ensure delivery is at-most-once.\n                Map<TopicPartition, OffsetAndMetadata> offsetsToCommit =\n                    createFetchedOffsetsMetadata(consumer.assignment());\n                consumer.commitSync(offsetsToCommit);\n                LOG.debug(\"Committed offsets {} to Kafka\", offsetsToCommit);\n            }\n            return consumerRecords;\n        } finally {\n            consumer.resume(pausedPartitions);\n        }\n    }\n\n    private void doSeekRetriableTopicPartitions(Map<TopicPartition, Long> pollableEarliestRetriableOffsets) {\n        for (Entry<TopicPartition, Long> retriableTopicPartitionAndOffset : pollableEarliestRetriableOffsets.entrySet()) {\n            //Seek directly to the earliest retriable message for each retriable topic partition\n            consumer.seek(retriableTopicPartitionAndOffset.getKey(), retriableTopicPartitionAndOffset.getValue());\n        }\n    }\n\n    private void ackRetriableOffsetsIfCompactedAway(Map<TopicPartition, Long> earliestRetriableOffsets,\n        ConsumerRecords<K, V> consumerRecords) {\n        for (Entry<TopicPartition, Long> entry : earliestRetriableOffsets.entrySet()) {\n            TopicPartition tp = entry.getKey();\n            List<ConsumerRecord<K, V>> records = consumerRecords.records(tp);\n            if (!records.isEmpty()) {\n                ConsumerRecord<K, V> record = records.get(0);\n                long seekOffset = entry.getValue();\n                long earliestReceivedOffset = record.offset();\n                if (seekOffset < earliestReceivedOffset) {\n                    //Since we asked for tuples starting at seekOffset, some retriable records must have been compacted away.\n                    //Ack up to the first offset received if the record is not already acked or currently in the topology\n                    for (long i = seekOffset; i < earliestReceivedOffset; i++) {\n                        KafkaSpoutMessageId msgId = retryService.getMessageId(tp, i);\n                        if (!offsetManagers.get(tp).contains(msgId) && !emitted.contains(msgId)) {\n                            LOG.debug(\"Record at offset [{}] appears to have been compacted away from topic [{}], marking as acked\", i, tp);\n                            retryService.remove(msgId);\n                            emitted.add(msgId);\n                            ack(msgId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // ======== emit  =========\n    private void emitIfWaitingNotEmitted() {\n        Iterator<List<ConsumerRecord<K, V>>> waitingToEmitIter = waitingToEmit.values().iterator();\n        outerLoop:\n        while (waitingToEmitIter.hasNext()) {\n            List<ConsumerRecord<K, V>> waitingToEmitForTp = waitingToEmitIter.next();\n            while (!waitingToEmitForTp.isEmpty()) {\n                final boolean emittedTuple = emitOrRetryTuple(waitingToEmitForTp.remove(0));\n                if (emittedTuple) {\n                    break outerLoop;\n                }\n            }\n            waitingToEmitIter.remove();\n        }\n    }\n\n    /**\n     * Creates a tuple from the kafka record and emits it if it was never emitted or it is ready to be retried.\n     *\n     * @param record to be emitted\n     * @return true if tuple was emitted. False if tuple has been acked or has been emitted and is pending ack or fail\n     */\n    private boolean emitOrRetryTuple(ConsumerRecord<K, V> record) {\n        final TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        final KafkaSpoutMessageId msgId = retryService.getMessageId(tp, record.offset());\n\n        if (offsetManagers.containsKey(tp) && offsetManagers.get(tp).contains(msgId)) {   // has been acked\n            LOG.trace(\"Tuple for record [{}] has already been acked. Skipping\", record);\n        } else if (emitted.contains(msgId)) {   // has been emitted and it is pending ack or fail\n            LOG.trace(\"Tuple for record [{}] has already been emitted. Skipping\", record);\n        } else {\n            final List<Object> tuple = kafkaSpoutConfig.getTranslator().apply(record);\n            if (isEmitTuple(tuple)) {\n                final boolean isScheduled = retryService.isScheduled(msgId);\n                // not scheduled <=> never failed (i.e. never emitted), or scheduled and ready to be retried\n                if (!isScheduled || retryService.isReady(msgId)) {\n                    final String stream = tuple instanceof KafkaTuple ? ((KafkaTuple) tuple).getStream() : Utils.DEFAULT_STREAM_ID;\n\n                    if (!isAtLeastOnceProcessing()) {\n                        if (kafkaSpoutConfig.isTupleTrackingEnforced()) {\n                            collector.emit(stream, tuple, msgId);\n                            LOG.trace(\"Emitted tuple [{}] for record [{}] with msgId [{}]\", tuple, record, msgId);\n                        } else {\n                            collector.emit(stream, tuple);\n                            LOG.trace(\"Emitted tuple [{}] for record [{}]\", tuple, record);\n                        }\n                    } else {\n                        emitted.add(msgId);\n                        offsetManagers.get(tp).addToEmitMsgs(msgId.offset());\n                        if (isScheduled) {  // Was scheduled for retry and re-emitted, so remove from schedule.\n                            retryService.remove(msgId);\n                        }\n                        collector.emit(stream, tuple, msgId);\n                        tupleListener.onEmit(tuple, msgId);\n                        LOG.trace(\"Emitted tuple [{}] for record [{}] with msgId [{}]\", tuple, record, msgId);\n                    }\n                    return true;\n                }\n            } else {\n                /*\n                 * if a null tuple is not configured to be emitted, it should be marked as emitted and acked immediately to allow its offset\n                 * to be commited to Kafka\n                 */\n                LOG.debug(\"Not emitting null tuple for record [{}] as defined in configuration.\", record);\n                if (isAtLeastOnceProcessing()) {\n                    msgId.setNullTuple(true);\n                    offsetManagers.get(tp).addToEmitMsgs(msgId.offset());\n                    ack(msgId);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Emits a tuple if it is not a null tuple, or if the spout is configured to emit null tuples.\n     */\n    private boolean isEmitTuple(List<Object> tuple) {\n        return tuple != null || kafkaSpoutConfig.isEmitNullTuples();\n    }\n\n    private Map<TopicPartition, OffsetAndMetadata> createFetchedOffsetsMetadata(Set<TopicPartition> assignedPartitions) {\n        Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = new HashMap<>();\n        for (TopicPartition tp : assignedPartitions) {\n            offsetsToCommit.put(tp, new OffsetAndMetadata(consumer.position(tp), commitMetadataManager.getCommitMetadata()));\n        }\n        return offsetsToCommit;\n    }\n\n    private void commitOffsetsForAckedTuples() {\n        final Map<TopicPartition, OffsetAndMetadata> nextCommitOffsets = new HashMap<>();\n        for (Map.Entry<TopicPartition, OffsetManager> tpOffset : offsetManagers.entrySet()) {\n            final OffsetAndMetadata nextCommitOffset = tpOffset.getValue().findNextCommitOffset(commitMetadataManager.getCommitMetadata());\n            if (nextCommitOffset != null) {\n                nextCommitOffsets.put(tpOffset.getKey(), nextCommitOffset);\n            }\n        }\n\n        // Commit offsets that are ready to be committed for every topic partition\n        if (!nextCommitOffsets.isEmpty()) {\n            consumer.commitSync(nextCommitOffsets);\n            LOG.debug(\"Offsets successfully committed to Kafka [{}]\", nextCommitOffsets);\n            // Instead of iterating again, it would be possible to commit and update the state for each TopicPartition\n            // in the prior loop, but the multiple network calls should be more expensive than iterating twice over a small loop\n            for (Map.Entry<TopicPartition, OffsetAndMetadata> tpOffset : nextCommitOffsets.entrySet()) {\n                //Update the OffsetManager for each committed partition, and update numUncommittedOffsets\n                final TopicPartition tp = tpOffset.getKey();\n                long position = consumer.position(tp);\n                long committedOffset = tpOffset.getValue().offset();\n                if (position < committedOffset) {\n                    /*\n                     * The position is behind the committed offset. This can happen in some cases, e.g. if a message failed, lots of (more\n                     * than max.poll.records) later messages were acked, and the failed message then gets acked. The consumer may only be\n                     * part way through \"catching up\" to where it was when it went back to retry the failed tuple. Skip the consumer forward\n                     * to the committed offset.\n                     */\n                    LOG.debug(\"Consumer fell behind committed offset. Catching up. Position was [{}], skipping to [{}]\",\n                        position, committedOffset);\n                    consumer.seek(tp, committedOffset);\n                }\n                /**\n                 * In some cases the waitingToEmit list may contain tuples that have just been committed. Drop these.\n                 */\n                List<ConsumerRecord<K, V>> waitingToEmitForTp = waitingToEmit.get(tp);\n                if (waitingToEmitForTp != null) {\n                    //Discard the pending records that are already committed\n                    waitingToEmit.put(tp, waitingToEmitForTp.stream()\n                        .filter(record -> record.offset() >= committedOffset)\n                        .collect(Collectors.toCollection(LinkedList::new)));\n                }\n\n                final OffsetManager offsetManager = offsetManagers.get(tp);\n                offsetManager.commit(tpOffset.getValue());\n                LOG.debug(\"[{}] uncommitted offsets for partition [{}] after commit\", offsetManager.getNumUncommittedOffsets(), tp);\n            }\n        } else {\n            LOG.trace(\"No offsets to commit. {}\", this);\n        }\n    }\n\n    // ======== Ack =======\n    @Override\n    public void ack(Object messageId) {\n        if (!isAtLeastOnceProcessing()) {\n            return;\n        }\n\n        // Only need to keep track of acked tuples if commits to Kafka are controlled by\n        // tuple acks, which happens only for at-least-once processing semantics\n        final KafkaSpoutMessageId msgId = (KafkaSpoutMessageId) messageId;\n\n        if (msgId.isNullTuple()) {\n            //a null tuple should be added to the ack list since by definition is a direct ack\n            offsetManagers.get(msgId.getTopicPartition()).addToAckMsgs(msgId);\n            LOG.debug(\"Received direct ack for message [{}], associated with null tuple\", msgId);\n            tupleListener.onAck(msgId);\n            return;\n        }\n\n        if (!emitted.contains(msgId)) {\n            LOG.debug(\"Received ack for message [{}], associated with tuple emitted for a ConsumerRecord that \"\n                + \"came from a topic-partition that this consumer group instance is no longer tracking \"\n                + \"due to rebalance/partition reassignment. No action taken.\", msgId);\n        } else {\n            Validate.isTrue(!retryService.isScheduled(msgId), \"The message id \" + msgId + \" is queued for retry while being acked.\"\n                + \" This should never occur barring errors in the RetryService implementation or the spout code.\");\n            offsetManagers.get(msgId.getTopicPartition()).addToAckMsgs(msgId);\n            emitted.remove(msgId);\n        }\n        tupleListener.onAck(msgId);\n    }\n\n    // ======== Fail =======\n```\n\n### Code description\n```Java\n/**\n * Description: This method handles the failure of a message in the KafkaSpout.\n * It checks if the processing semantics are at least once, and if the message is being tracked.\n * If the message is not being tracked, it logs a debug message and returns.\n * If the message is being tracked, it increments the number of fails for the message and schedules a retry.\n * If the retry is not scheduled, it logs a debug message, marks the message as acked, and removes it from the emitted list.\n * If the retry is scheduled, it notifies the tuple listener and removes the message from the emitted list.\n *\n * @param messageId The id of the message to fail.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic void fail(Object messageId) {\n    if (!isAtLeastOnceProcessing()) {\n        return;\n    }\n    // Only need to keep track of failed tuples if commits to Kafka are controlled by\n    // tuple acks, which happens only for at-least-once processing semantics\n    final KafkaSpoutMessageId msgId = (KafkaSpoutMessageId) messageId;\n    if (!emitted.contains(msgId)) {\n        LOG.debug(\"Received fail for tuple this spout is no longer tracking.\"\n            + \" Partitions may have been reassigned. Ignoring message [{}]\", msgId);\n        return;\n    }\n    Validate.isTrue(!retryService.isScheduled(msgId), \"The message id \" + msgId + \" is queued for retry while being failed.\"\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "fail", "reference": "        + \" This should never occur barring errors in the RetryService implementation or the spout code.\");\n\n    msgId.incrementNumFails();\n\n    if (!retryService.schedule(msgId)) {\n        LOG.debug(\"Reached maximum number of retries. Message [{}] being marked as acked.\", msgId);\n        // this tuple should be removed from emitted only inside the ack() method. This is to ensure\n        // that the OffsetManager for that TopicPartition is updated and allows commit progression\n        tupleListener.onMaxRetryReached(msgId);\n        ack(msgId);\n    } else {\n        tupleListener.onRetry(msgId);\n        emitted.remove(msgId);\n    }\n}", "completions": ["```markdown\n```java\n/**\n * Description: This method handles the failure of a message in the KafkaSpout.\n * It checks if the processing semantics are at least once, and if the message is being tracked.\n * If the message is not being tracked, it logs a debug message and returns.\n * If the message is being tracked, it increments the number of fails for the message and schedules a retry.\n * If the retry is not scheduled, it logs a debug message, marks the message as acked, and removes it from the emitted list.\n * If the retry is scheduled, it notifies the tuple listener and removes the message from the emitted list.\n *\n * @param messageId The id of the message to fail.\n */\n```\n```\n"]}
{"id": 27, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**************************************************************************************** \n Copyright \u00a9 2003-2012 hbasesoft Corporation. All rights reserved. Reproduction or       <br>\n transmission in whole or in part, in any form or by any means, electronic, mechanical <br>\n or otherwise, is prohibited without the prior written consent of the copyright owner. <br>\n ****************************************************************************************/\npackage com.hbasesoft.framework.common.utils.bean;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\n\nimport com.hbasesoft.framework.common.ErrorCodeDef;\nimport com.hbasesoft.framework.common.utils.UtilException;\nimport com.hbasesoft.framework.common.utils.security.DataUtil;\n\nimport io.protostuff.LinkedBuffer;\nimport io.protostuff.ProtostuffIOUtil;\nimport io.protostuff.Schema;\nimport io.protostuff.runtime.RuntimeSchema;\nimport lombok.AccessLevel;\nimport lombok.NoArgsConstructor;\n\n/**\n * <Description> <br>\n * \n * @author \u738b\u4f1f<br>\n * @version 1.0<br>\n * @taskId <br>\n * @CreateDate 2015\u5e7412\u67082\u65e5 <br>\n * @since V1.0<br>\n * @see com.hbasesoft.framework.cache.core.util <br>\n */\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\npublic final class SerializationUtil {\n\n    /**\n     * INIT_SIZE\n     */\n    private static final int INIT_SIZE = 1024;\n\n```\n\n### Code description\n```Java\n/**\n * Serializes an object into a byte array using Protostuff serialization.\n *\n * @param <T> the type of the object to be serialized\n * @param obj the object to be serialized\n * @return a byte array representing the serialized object, or null if the object is null or Void\n * @throws UtilException if an error occurs during serialization\n */\n```\n\n### Code snippet:\n```Java\n@SuppressWarnings(\"unchecked\")\npublic static <T> byte[] serial(T obj) throws UtilException {\n    if (obj != null && !(obj instanceof Void)) {\n        try {\n            if (obj instanceof Map) {\n                return jdkSerial(obj);\n            }\n            else {\n                Schema<T> schema = RuntimeSchema.getSchema((Class<T>) obj.getClass());\n                LinkedBuffer buffer = LinkedBuffer.allocate(INIT_SIZE);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "serial", "reference": "                return ProtostuffIOUtil.toByteArray(obj, schema, buffer);\n            }\n        }\n        catch (Exception e) {\n            throw new UtilException(e, ErrorCodeDef.SERIALIZE_ERROR, obj);\n        }\n\n    }\n    return null;\n}", "completions": ["```Java\n            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);\n        }\n        catch (IOException e) {\n            throw new UtilException(ErrorCodeDef.SERIALIZATION_ERROR, e);\n        }\n    }\n\n    /**\n     * Serializes an object into a byte array using JDK serialization.\n     *\n     * @param obj the object to be serialized\n     * @return a byte array representing the serialized object, or null if the object is null\n     * @throws UtilException if an error occurs during serialization\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static <T> byte[] jdkSerial(T obj) throws UtilException {\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            oos.flush();\n            return baos.toByteArray();\n        }\n        catch (IOException e) {\n            throw new UtilException(ErrorCodeDef.SERIALIZATION_ERROR, e);\n        }\n    }\n}\n```\n"]}
{"id": 28, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n*/\n\npackage org.apache.griffin.core.job;\n\nimport static java.util.TimeZone.getTimeZone;\nimport static org.apache.griffin.core.config.EnvConfig.ENV_BATCH;\nimport static org.apache.griffin.core.config.EnvConfig.ENV_STREAMING;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.INSTANCE_ID_DOES_NOT_EXIST;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.INVALID_MEASURE_ID;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.JOB_ID_DOES_NOT_EXIST;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.JOB_NAME_DOES_NOT_EXIST;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.JOB_TYPE_DOES_NOT_SUPPORT;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.MEASURE_TYPE_DOES_NOT_SUPPORT;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.NO_SUCH_JOB_ACTION;\nimport static org.apache.griffin.core.exception.GriffinExceptionMessage.QUARTZ_JOB_ALREADY_EXIST;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.BUSY;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.DEAD;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.IDLE;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.NOT_STARTED;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.RECOVERING;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.RUNNING;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.STARTING;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.SUCCESS;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.State.UNKNOWN;\nimport static org.apache.griffin.core.job.entity.LivySessionStates.isActive;\nimport static org.apache.griffin.core.measure.entity.GriffinMeasure.ProcessType.BATCH;\nimport static org.apache.griffin.core.measure.entity.GriffinMeasure.ProcessType.STREAMING;\nimport static org.quartz.CronScheduleBuilder.cronSchedule;\nimport static org.quartz.JobBuilder.newJob;\nimport static org.quartz.JobKey.jobKey;\nimport static org.quartz.SimpleScheduleBuilder.simpleSchedule;\nimport static org.quartz.TriggerBuilder.newTrigger;\nimport static org.quartz.TriggerKey.triggerKey;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.griffin.core.event.GriffinEventManager;\nimport org.apache.griffin.core.event.JobEvent;\nimport org.apache.griffin.core.exception.GriffinException;\nimport org.apache.griffin.core.job.entity.AbstractJob;\nimport org.apache.griffin.core.job.entity.BatchJob;\nimport org.apache.griffin.core.job.entity.JobHealth;\nimport org.apache.griffin.core.job.entity.JobInstanceBean;\nimport org.apache.griffin.core.job.entity.JobState;\nimport org.apache.griffin.core.job.entity.JobType;\nimport org.apache.griffin.core.job.entity.LivySessionStates;\nimport org.apache.griffin.core.job.entity.LivySessionStates.State;\nimport org.apache.griffin.core.job.entity.StreamingJob;\nimport org.apache.griffin.core.job.repo.BatchJobRepo;\nimport org.apache.griffin.core.job.repo.JobInstanceRepo;\nimport org.apache.griffin.core.job.repo.JobRepo;\nimport org.apache.griffin.core.job.repo.StreamingJobRepo;\nimport org.apache.griffin.core.measure.entity.GriffinMeasure;\nimport org.apache.griffin.core.measure.entity.GriffinMeasure.ProcessType;\nimport org.apache.griffin.core.measure.repo.GriffinMeasureRepo;\nimport org.apache.griffin.core.util.JsonUtil;\nimport org.apache.griffin.core.util.YarnNetUtil;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.quartz.JobDataMap;\nimport org.quartz.JobDetail;\nimport org.quartz.JobKey;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.Trigger;\nimport org.quartz.TriggerBuilder;\nimport org.quartz.TriggerKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.scheduling.quartz.SchedulerFactoryBean;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.web.client.HttpClientErrorException;\nimport org.springframework.web.client.ResourceAccessException;\n\n@Service\npublic class JobServiceImpl implements JobService {\n    private static final Logger LOGGER = LoggerFactory\n        .getLogger(JobServiceImpl.class);\n    public static final String GRIFFIN_JOB_ID = \"griffinJobId\";\n    private static final int MAX_PAGE_SIZE = 1024;\n    private static final int DEFAULT_PAGE_SIZE = 10;\n    static final String START = \"start\";\n    static final String STOP = \"stop\";\n\n    @Autowired\n    @Qualifier(\"schedulerFactoryBean\")\n    private SchedulerFactoryBean factory;\n    @Autowired\n    private JobInstanceRepo instanceRepo;\n    @Autowired\n    private Environment env;\n    @Autowired\n    private GriffinMeasureRepo measureRepo;\n    @Autowired\n    private BatchJobRepo batchJobRepo;\n    @Autowired\n    private StreamingJobRepo streamingJobRepo;\n    @Autowired\n    private JobRepo<AbstractJob> jobRepo;\n    @Autowired\n    private BatchJobOperatorImpl batchJobOp;\n    @Autowired\n    private StreamingJobOperatorImpl streamingJobOp;\n    @Autowired\n    private GriffinEventManager eventManager;\n    @Autowired\n    private LivyTaskSubmitHelper livyTaskSubmitHelper;\n\n    public JobServiceImpl() {\n\n    }\n\n    @Override\n    public List<AbstractJob> getAliveJobs(String type) {\n        List<? extends AbstractJob> jobs;\n        if (JobType.BATCH.getName().equals(type)) {\n            jobs = batchJobRepo.findByDeleted(false);\n        } else if (JobType.STREAMING.getName().equals(type)) {\n            jobs = streamingJobRepo.findByDeleted(false);\n        } else {\n            jobs = jobRepo.findByDeleted(false);\n        }\n        return getJobDataBeans(jobs);\n    }\n\n    private List<AbstractJob> getJobDataBeans(List<? extends AbstractJob> jobs) {\n        List<AbstractJob> dataList = new ArrayList<>();\n        try {\n            for (AbstractJob job : jobs) {\n                JobState jobState = genJobState(job);\n                job.setJobState(jobState);\n                dataList.add(job);\n            }\n        } catch (SchedulerException e) {\n            LOGGER.error(\"Failed to get RUNNING jobs.\", e);\n            throw new GriffinException\n                .ServiceException(\"Failed to get RUNNING jobs.\", e);\n        }\n        return dataList;\n    }\n\n    @Override\n    public AbstractJob addJob(AbstractJob job) throws Exception {\n        JobEvent jobEvent = JobEvent.yieldJobEventBeforeCreation(job);\n        eventManager.notifyListeners(jobEvent);\n        Long measureId = job.getMeasureId();\n        GriffinMeasure measure = getMeasureIfValid(measureId);\n        JobOperator op = getJobOperator(measure.getProcessType());\n        AbstractJob jobSaved = op.add(job, measure);\n        jobEvent = JobEvent.yieldJobEventAfterCreation(jobSaved);\n        eventManager.notifyListeners(jobEvent);\n        return jobSaved;\n    }\n\n    @Override\n    public AbstractJob getJobConfig(Long jobId) {\n        AbstractJob job = jobRepo.findByIdAndDeleted(jobId, false);\n        if (job == null) {\n            LOGGER.warn(\"Job id {} does not exist.\", jobId);\n            throw new GriffinException\n                .NotFoundException(JOB_ID_DOES_NOT_EXIST);\n        }\n        return job;\n    }\n\n    /**\n     * @param jobId  job id\n     * @param action job operation: start job, stop job\n     */\n    @Override\n    public AbstractJob onAction(Long jobId, String action) throws Exception {\n        AbstractJob job = jobRepo.findByIdAndDeleted(jobId, false);\n        validateJobExist(job);\n        JobOperator op = getJobOperator(job);\n        doAction(action, job, op);\n        JobState jobState = genJobState(job, action);\n        job.setJobState(jobState);\n        return job;\n    }\n\n    private void doAction(String action, AbstractJob job, JobOperator op)\n        throws Exception {\n        switch (action) {\n            case START:\n                op.start(job);\n                break;\n            case STOP:\n                op.stop(job);\n                break;\n            default:\n                throw new GriffinException\n                    .NotFoundException(NO_SUCH_JOB_ACTION);\n        }\n    }\n\n\n    /**\n     * logically delete\n     * 1. pause these jobs\n     * 2. set these jobs as deleted status\n     *\n     * @param jobId griffin job id\n     */\n    @Override\n    public void deleteJob(Long jobId) throws SchedulerException {\n        AbstractJob job = jobRepo.findByIdAndDeleted(jobId, false);\n        validateJobExist(job);\n        JobEvent event = JobEvent.yieldJobEventBeforeRemoval(job);\n        eventManager.notifyListeners(event);\n        JobOperator op = getJobOperator(job);\n        op.delete(job);\n        event = JobEvent.yieldJobEventAfterRemoval(job);\n        eventManager.notifyListeners(event);\n    }\n\n    /**\n     * logically delete\n     *\n     * @param name griffin job name which may not be unique.\n     */\n    @Override\n    public void deleteJob(String name) throws SchedulerException {\n        List<AbstractJob> jobs = jobRepo.findByJobNameAndDeleted(name, false);\n        if (CollectionUtils.isEmpty(jobs)) {\n            LOGGER.warn(\"There is no job with '{}' name.\", name);\n            throw new GriffinException\n                .NotFoundException(JOB_NAME_DOES_NOT_EXIST);\n        }\n        for (AbstractJob job : jobs) {\n            JobEvent event = JobEvent.yieldJobEventBeforeRemoval(job);\n            eventManager.notifyListeners(event);\n            JobOperator op = getJobOperator(job);\n            op.delete(job);\n            event = JobEvent.yieldJobEventAfterRemoval(job);\n            eventManager.notifyListeners(event);\n        }\n    }\n\n    @Override\n    public List<JobInstanceBean> findInstancesOfJob(\n        Long jobId,\n        int page,\n        int size) {\n        AbstractJob job = jobRepo.findByIdAndDeleted(jobId, false);\n        if (job == null) {\n            LOGGER.warn(\"Job id {} does not exist.\", jobId);\n            throw new GriffinException\n                .NotFoundException(JOB_ID_DOES_NOT_EXIST);\n        }\n        size = size > MAX_PAGE_SIZE ? MAX_PAGE_SIZE : size;\n        size = size <= 0 ? DEFAULT_PAGE_SIZE : size;\n        Pageable pageable = new PageRequest(page, size,\n            Sort.Direction.DESC, \"tms\");\n        List<JobInstanceBean> instances = instanceRepo.findByJobId(jobId,\n            pageable);\n        return updateState(instances);\n    }\n\n    @Override\n    public JobInstanceBean findInstance(Long id) {\n        JobInstanceBean bean = instanceRepo.findByInstanceId(id);\n        if (bean == null) {\n            LOGGER.warn(\"Instance id {} does not exist.\", id);\n            throw new GriffinException\n                .NotFoundException(INSTANCE_ID_DOES_NOT_EXIST);\n        }\n        return bean;\n    }\n\n    private List<JobInstanceBean> updateState(List<JobInstanceBean> instances) {\n        for (JobInstanceBean instance : instances) {\n            State state = instance.getState();\n            if (state.equals(UNKNOWN) || isActive(state)) {\n                syncInstancesOfJob(instance);\n            }\n        }\n        return instances;\n    }\n\n    @Override\n    public List<JobInstanceBean> findInstancesByTriggerKey(String triggerKey) {\n        return instanceRepo.findByTriggerKey(triggerKey);\n    }\n\n    /**\n     * a job is regard as healthy job when its latest instance is in healthy\n     * state.\n     *\n     * @return job healthy statistics\n     */\n    @Override\n    public JobHealth getHealthInfo() {\n        JobHealth jobHealth = new JobHealth();\n        List<AbstractJob> jobs = jobRepo.findByDeleted(false);\n        for (AbstractJob job : jobs) {\n            JobOperator op = getJobOperator(job);\n            try {\n                jobHealth = op.getHealth(jobHealth, job);\n            } catch (SchedulerException e) {\n                LOGGER.error(\"Job schedule exception. {}\", e);\n                throw new GriffinException\n                    .ServiceException(\"Fail to Get HealthInfo\", e);\n            }\n\n        }\n        return jobHealth;\n    }\n\n    @Scheduled(fixedDelayString = \"${jobInstance.expired.milliseconds}\")\n    public void deleteExpiredJobInstance() {\n        Long timeMills = System.currentTimeMillis();\n        List<JobInstanceBean> instances = instanceRepo\n            .findByExpireTmsLessThanEqual\n                (timeMills);\n        if (!batchJobOp.pauseJobInstances(instances)) {\n            LOGGER.error(\"Pause job failure.\");\n            return;\n        }\n        int count = instanceRepo.deleteByExpireTimestamp(timeMills);\n        LOGGER.info(\"Delete {} expired job instances.\", count);\n    }\n\n    private void validateJobExist(AbstractJob job) {\n        if (job == null) {\n            LOGGER.warn(\"Griffin job does not exist.\");\n            throw new GriffinException.NotFoundException(JOB_ID_DOES_NOT_EXIST);\n        }\n    }\n\n    private JobOperator getJobOperator(AbstractJob job) {\n        if (job instanceof BatchJob) {\n            return batchJobOp;\n        } else if (job instanceof StreamingJob) {\n            return streamingJobOp;\n        }\n        throw new GriffinException.BadRequestException\n            (JOB_TYPE_DOES_NOT_SUPPORT);\n    }\n\n    private JobOperator getJobOperator(ProcessType type) {\n        if (type == BATCH) {\n            return batchJobOp;\n        } else if (type == STREAMING) {\n            return streamingJobOp;\n        }\n        throw new GriffinException.BadRequestException\n            (MEASURE_TYPE_DOES_NOT_SUPPORT);\n    }\n\n    TriggerKey getTriggerKeyIfValid(String qName, String qGroup) throws\n        SchedulerException {\n        TriggerKey triggerKey = triggerKey(qName, qGroup);\n        if (factory.getScheduler().checkExists(triggerKey)) {\n            throw new GriffinException.ConflictException\n                (QUARTZ_JOB_ALREADY_EXIST);\n        }\n        return triggerKey;\n    }\n\n    List<? extends Trigger> getTriggers(String name, String group) throws\n        SchedulerException {\n        if (name == null || group == null) {\n            return null;\n        }\n        JobKey jobKey = new JobKey(name, group);\n        Scheduler scheduler = factory.getScheduler();\n        return scheduler.getTriggersOfJob(jobKey);\n    }\n\n    private JobState genJobState(AbstractJob job, String action) throws\n        SchedulerException {\n        JobOperator op = getJobOperator(job);\n        JobState state = op.getState(job, action);\n        job.setJobState(state);\n        return state;\n    }\n\n    private JobState genJobState(AbstractJob job) throws SchedulerException {\n        return genJobState(job, null);\n    }\n\n    void addJob(TriggerKey tk, AbstractJob job, ProcessType type) throws\n        Exception {\n        JobDetail jobDetail = addJobDetail(tk, job);\n        Trigger trigger = genTriggerInstance(tk, jobDetail, job, type);\n        factory.getScheduler().scheduleJob(trigger);\n    }\n\n    String getQuartzName(AbstractJob job) {\n        return job.getJobName() + \"_\" + System.currentTimeMillis();\n    }\n\n    String getQuartzGroup() {\n        return \"BA\";\n    }\n\n    boolean isValidJobName(String jobName) {\n        if (StringUtils.isEmpty(jobName)) {\n            LOGGER.warn(\"Job name cannot be empty.\");\n            return false;\n        }\n        int size = jobRepo.countByJobNameAndDeleted(jobName, false);\n        if (size > 0) {\n            LOGGER.warn(\"Job name already exits.\");\n            return false;\n        }\n        return true;\n    }\n\n\n    private GriffinMeasure getMeasureIfValid(Long measureId) {\n        GriffinMeasure measure = measureRepo.findByIdAndDeleted(measureId,\n            false);\n        if (measure == null) {\n            LOGGER.warn(\"The measure id {} isn't valid. Maybe it doesn't \" +\n                    \"exist or is external measure type.\",\n                measureId);\n            throw new GriffinException.BadRequestException(INVALID_MEASURE_ID);\n        }\n        return measure;\n    }\n\n    private Trigger genTriggerInstance(TriggerKey tk, JobDetail jd, AbstractJob\n        job, ProcessType type) {\n        TriggerBuilder builder = newTrigger().withIdentity(tk).forJob(jd);\n        if (type == BATCH) {\n            TimeZone timeZone = getTimeZone(job.getTimeZone());\n            return builder.withSchedule(cronSchedule(job.getCronExpression())\n                .inTimeZone(timeZone)).build();\n        } else if (type == STREAMING) {\n            return builder.startNow().withSchedule(simpleSchedule()\n                .withRepeatCount(0)).build();\n        }\n        throw new GriffinException.BadRequestException\n            (JOB_TYPE_DOES_NOT_SUPPORT);\n\n    }\n\n    private JobDetail addJobDetail(TriggerKey triggerKey, AbstractJob job)\n        throws SchedulerException {\n        Scheduler scheduler = factory.getScheduler();\n        JobKey jobKey = jobKey(triggerKey.getName(), triggerKey.getGroup());\n        JobDetail jobDetail;\n        Boolean isJobKeyExist = scheduler.checkExists(jobKey);\n        if (isJobKeyExist) {\n            jobDetail = scheduler.getJobDetail(jobKey);\n        } else {\n            jobDetail = newJob(JobInstance.class).storeDurably().withIdentity\n                (jobKey).build();\n        }\n        setJobDataMap(jobDetail, job);\n        scheduler.addJob(jobDetail, isJobKeyExist);\n        return jobDetail;\n    }\n\n    private void setJobDataMap(JobDetail jd, AbstractJob job) {\n        JobDataMap jobDataMap = jd.getJobDataMap();\n        jobDataMap.put(GRIFFIN_JOB_ID, job.getId().toString());\n    }\n\n\n    /**\n     * deleteJobsRelateToMeasure\n     * 1. search jobs related to measure\n     * 2. deleteJob\n     *\n     * @param measureId measure id\n     */\n    public void deleteJobsRelateToMeasure(Long measureId) throws\n        SchedulerException {\n        List<AbstractJob> jobs = jobRepo.findByMeasureIdAndDeleted(measureId,\n            false);\n        if (CollectionUtils.isEmpty(jobs)) {\n            LOGGER.info(\"Measure id {} has no related jobs.\", measureId);\n            return;\n        }\n        for (AbstractJob job : jobs) {\n            JobOperator op = getJobOperator(job);\n            op.delete(job);\n        }\n    }\n\n    @Scheduled(fixedDelayString = \"${jobInstance.fixedDelay.in.milliseconds}\")\n    public void syncInstancesOfAllJobs() {\n        LivySessionStates.State[] states = {STARTING, NOT_STARTED, RECOVERING,\n            IDLE, RUNNING, BUSY};\n        List<JobInstanceBean> beans = instanceRepo.findByActiveState(states);\n        for (JobInstanceBean jobInstance : beans) {\n            syncInstancesOfJob(jobInstance);\n        }\n    }\n\n    /**\n     * call livy to update part of job instance table data associated with group\n     * and jobName in mysql.\n     *\n     * @param instance job instance livy info\n     */\n    private void syncInstancesOfJob(JobInstanceBean instance) {\n        if (instance.getSessionId() == null) {\n            return;\n        }\n        String uri = env.getProperty(\"livy.uri\") + \"/\"\n            + instance.getSessionId();\n        TypeReference<HashMap<String, Object>> type =\n            new TypeReference<HashMap<String, Object>>() {\n            };\n        try {\n            String resultStr = livyTaskSubmitHelper.getFromLivy(uri);\n            LOGGER.info(resultStr);\n\n            HashMap<String, Object> resultMap = JsonUtil.toEntity(resultStr,\n                type);\n            setJobInstanceIdAndUri(instance, resultMap);\n        } catch (ResourceAccessException e) {\n            LOGGER.error(\"Your url may be wrong. Please check {}.\\n {}\", uri, e\n                .getMessage());\n        } catch (HttpClientErrorException e) {\n            LOGGER.warn(\"sessionId({}) appId({}) {}.\", instance.getSessionId(),\n                instance.getAppId(), e.getMessage());\n            setStateByYarn(instance, e);\n            livyTaskSubmitHelper.decreaseCurTaskNum(instance.getId());\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage());\n        }\n\n    }\n\n    private void setStateByYarn(JobInstanceBean instance,\n                                HttpClientErrorException e) {\n        if (!checkStatus(instance, e)) {\n            int code = e.getStatusCode().value();\n            boolean match = (code == 400 || code == 404)\n                && instance.getAppId() != null;\n            //this means your url is correct,but your param is wrong or livy\n            //session may be overdue.\n            if (match) {\n                setStateByYarn(instance);\n            }\n        }\n\n    }\n\n    /**\n     * Check instance status in case that session id is overdue and app id is\n     * null and so we cannot update instance state\n     * .\n     *\n     * @param instance job instance bean\n     * @param e        HttpClientErrorException\n     * @return boolean\n     */\n    private boolean checkStatus(JobInstanceBean instance,\n                                HttpClientErrorException e) {\n        int code = e.getStatusCode().value();\n        String appId = instance.getAppId();\n        String responseBody = e.getResponseBodyAsString();\n        Long sessionId = instance.getSessionId();\n        sessionId = sessionId != null ? sessionId : -1;\n        // If code is 404 and appId is null and response body is like 'Session\n        // {id} not found',this means instance may not be scheduled for\n        // a long time by spark for too many tasks. It may be dead.\n        if (code == 404 && appId == null && (responseBody != null &&\n            responseBody.contains(sessionId.toString()))) {\n            instance.setState(DEAD);\n            instance.setDeleted(true);\n            instanceRepo.save(instance);\n            return true;\n        }\n        return false;\n    }\n\n    private void setStateByYarn(JobInstanceBean instance) {\n        LOGGER.warn(\"Spark session {} may be overdue! \" +\n            \"Now we use yarn to update state.\", instance.getSessionId());\n        String yarnUrl = env.getProperty(\"yarn.uri\");\n        boolean success = YarnNetUtil.update(yarnUrl, instance);\n        if (!success) {\n            if (instance.getState().equals(UNKNOWN)) {\n                return;\n            }\n            instance.setState(UNKNOWN);\n        }\n        instanceRepo.save(instance);\n    }\n\n\n    private void setJobInstanceIdAndUri(JobInstanceBean instance, HashMap<String\n        , Object> resultMap) {\n        if (resultMap != null) {\n            Object state = resultMap.get(\"state\");\n            Object appId = resultMap.get(\"appId\");\n            instance.setState(state == null ? null : LivySessionStates.State\n                .valueOf(state.toString().toUpperCase\n                    ()));\n            instance.setAppId(appId == null ? null : appId.toString());\n            instance.setAppUri(appId == null ? null : env\n                .getProperty(\"yarn.uri\") + \"/cluster/app/\" + appId);\n            instanceRepo.save(instance);\n            // If Livy returns to success or dead, task execution completes one,TaskNum--\n            if (instance.getState().equals(SUCCESS) || instance.getState().equals(DEAD)) {\n                livyTaskSubmitHelper.decreaseCurTaskNum(instance.getSessionId());\n            }\n        }\n    }\n\n    public Boolean isJobHealthy(Long jobId) {\n        Pageable pageable = new PageRequest(0, 1, Sort.Direction.DESC, \"tms\");\n        List<JobInstanceBean> instances = instanceRepo.findByJobId(jobId,\n            pageable);\n        return !CollectionUtils.isEmpty(instances) && LivySessionStates\n            .isHealthy(instances.get(0).getState());\n    }\n\n    @Override\n    public String getJobHdfsSinksPath(String jobName, long timestamp) {\n        List<AbstractJob> jobList = jobRepo.findByJobNameAndDeleted(\n            jobName, false);\n        if (jobList.size() == 0) {\n            return null;\n        }\n        if (jobList.get(0).getType().toLowerCase().equals(\"batch\")) {\n            return getSinksPath(ENV_BATCH)\n                + \"/\" + jobName + \"/\" + timestamp + \"\";\n        }\n\n        return getSinksPath(ENV_STREAMING)\n            + \"/\" + jobName + \"/\" + timestamp + \"\";\n    }\n\n    private String getSinksPath(String jsonString) {\n        try {\n            JSONObject obj = new JSONObject(jsonString);\n            JSONArray persistArray = obj.getJSONArray(\"sinks\");\n            for (int i = 0; i < persistArray.length(); i++) {\n                Object type = persistArray.getJSONObject(i).get(\"type\");\n                if (type instanceof String\n                    && \"hdfs\".equalsIgnoreCase(String.valueOf(type))) {\n                    return persistArray.getJSONObject(i)\n                        .getJSONObject(\"config\").getString(\"path\");\n                }\n            }\n\n            return null;\n        } catch (Exception ex) {\n            LOGGER.error(\"Fail to get Persist path from {}\", jsonString, ex);\n            return null;\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method triggers a job by its ID.\n * It first retrieves the job from the repository, validates its existence,\n * and then checks if the job exists in the scheduler. If it does, it creates a new trigger\n * for the job and schedules it. If the job does not exist in the scheduler, it throws a NotFoundException.\n *\n * @param id The ID of the job to be triggered.\n * @return The key of the trigger as a string.\n * @throws SchedulerException If there is an error with the scheduler.\n * @throws GriffinException.NotFoundException If the job ID does not exist.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic String triggerJobById(Long id) throws SchedulerException {\n    AbstractJob job = jobRepo.findByIdAndDeleted(id, false);\n    validateJobExist(job);\n    Scheduler scheduler = factory.getScheduler();\n    JobKey jobKey = jobKey(job.getName(), job.getGroup());\n    if (scheduler.checkExists(jobKey)) {\n        Trigger trigger = TriggerBuilder.newTrigger()\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "triggerJobById", "reference": "                .forJob(jobKey)\n                .startNow()\n                .build();\n        scheduler.scheduleJob(trigger);\n        return trigger.getKey().toString();\n    } else {\n        throw new GriffinException.NotFoundException(JOB_ID_DOES_NOT_EXIST);\n    }\n}", "completions": ["```markdown\n```java\n@Override\npublic String triggerJobById(Long id) throws SchedulerException {\n    AbstractJob job = jobRepo.findByIdAndDeleted(id, false);\n    validateJobExist(job);\n    Scheduler scheduler = factory.getScheduler();\n    JobKey jobKey = jobKey(job.getName(), job.getGroup());\n    if (scheduler.checkExists(jobKey)) {\n        Trigger trigger = TriggerBuilder.newTrigger()\n            .withIdentity(jobKey)\n            .forJob(jobDetail(jobKey))\n            .withSchedule(simpleSchedule()\n                .withRepeatCount(0))\n            .build();\n        scheduler.scheduleJob(trigger);\n        return trigger.getKey().toString();\n    } else {\n        throw new GriffinException.NotFoundException(JOB_ID_DOES_NOT_EXIST);\n    }\n}\n```\n```\n"]}
{"id": 29, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage ch.cyberduck.core;\n\n/*\n * Copyright (c) 2002-2013 David Kocher. All rights reserved.\n * http://cyberduck.ch/\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Bug fixes, suggestions and comments should be sent to feedback@cyberduck.ch\n */\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic final class PathRelativizer {\n\n    private PathRelativizer() {\n        //\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Relativizes a path to a root directory.\n *\n * This method takes a root directory and a path, and returns the path relative to the root.\n * If the root is blank, it returns the path as is.\n * If the root is equal to the path, it returns an empty string.\n * If the root is not equal to the path, it appends a path delimiter to the root.\n * If the path contains the root, it returns the path from the position after the root.\n * If the path does not contain the root, it returns the path as is.\n *\n * @param root The root directory to relativize the path to.\n * @param path The path to relativize.\n * @return The relativized path.\n */\n```\n\n### Code snippet:\n```Java\npublic static String relativize(String root, final String path) {\n    if(StringUtils.isBlank(root)) {\n        return path;\n    }\n    if(StringUtils.equals(root, path)) {\n        return StringUtils.EMPTY;\n    }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "relativize", "reference": "    if(!StringUtils.equals(root, String.valueOf(Path.DELIMITER))) {\n        root = root + Path.DELIMITER;\n    }\n    if(StringUtils.contains(path, root)) {\n        return StringUtils.substring(path, path.indexOf(root) + root.length());\n    }\n    return path;\n}", "completions": ["```Java\n    return StringUtils.appendIfMissing(StringUtils.substringAfter(path, root), StringUtils.EMPTY);\n}\n```\n"]}
{"id": 30, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2013-2021 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cloud.sleuth.instrument.reactor;\n\nimport java.util.Objects;\nimport java.util.function.BiFunction;\n\nimport org.reactivestreams.Processor;\nimport org.reactivestreams.Publisher;\nimport reactor.core.Fuseable;\nimport reactor.core.Scannable;\nimport reactor.util.annotation.Nullable;\n\nimport org.springframework.util.Assert;\n\n/**\n * Helper class for reactor ON_EACH instrumentation. Reduces number of sleuth operators\n * time in the reactive chain during Assembly by using {@code Scannable.Attr.RUN_STYLE}.\n * Below is the example of what it does <pre>{@code\n *\tMono.just(0) // (-)\n * \t.map(it -> 1) // (-)\n * \t.flatMap(it ->\n * \t\tMono.just(it) // (-)\n * \t) // (-)\n * \t.flatMapMany(it ->\n * \t\tasyncPublisher(it) // (+)(*)\n * \t) // (-)\n * \t.filter(it -> true) // (-)\n * \t.publishOn(Schedulers.single()) //(+)\n * \t.map(it -> it) // (-)\n * \t.map(it -> it * 10) // (-)\n * \t.filter(it -> true) // (-)\n * \t.scan((l, r) -> l + r) // (-)\n * \t.doOnNext(it -> { // (-)\n * \t\t//log\n *    })\n * \t.doFirst(() -> { // (-)\n * \t\t//log\n *    })\n * \t.doFinally(signalType -> { // (-)\n * \t\t//log\n *    })\n * \t.subscribeOn(Schedulers.parallel()) //(+)\n * \t.subscribe();//(*)\n * \t(*) - captures tracing context if it differs from what was captured before at subscription and propagates it.\n *  As far as check is performed on Subscriber Context it allocates Publisher to access it.\n * \t(+) - is ASYNC need to decorate Publisher\n * \t(-) - is SYNC no need to decorate Publisher\n *}</pre> So it creates 13 (out of 16) less Publisher (+ Subscriber and all their stuff)\n * on assembly time comparing to the original logic (decorate every Publisher and checking\n * only at subscription time).\n * <p/>\n * It also handles the case when onEachHook was not applied for some operator in the chain\n * (It could be possible if custom operators or Processor are used) by checkin source\n * source Publisher. <pre>{@code\n * \tprocessor/customOperator // (?) is async and hook is not applied\n * \t.map(it -> ...) // (+) is SYNC but should add hook as previous Processor/operator does not use hooks\n * \t.doOnNext(it -> { // (-) is SYNC no need to wrap\n * \t\t//log\n *    })\n * \t.subscribe();\n *}</pre>\n *\n * @author Roman Matiushchenko\n */\nfinal class ReactorHooksHelper {\n\n\tstatic final String LIFTER_NAME = \"org.springframework.cloud.sleuth.instrument.reactor.ReactorHooksHelper.ScopePassingLifter\";\n\n\t// need a way to determine SYNC sources to not add redundant scope passing decorator\n\t// most of reactor-core SYNC sources are marked with SourceProducer interface\n\tstatic final Class<?> sourceProducerClass;\n\n\tstatic {\n\t\tClass<?> c;\n\t\ttry {\n\t\t\tc = Class.forName(\"reactor.core.publisher.SourceProducer\");\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\tc = Void.class;\n\t\t}\n\t\tsourceProducerClass = c;\n\t}\n\n\tprivate ReactorHooksHelper() {\n\t}\n\n\t/**\n\t * Determines whether to decorate input publisher with\n\t * {@code ScopePassingSpanOperator}.\n\t * @param p publisher to check\n\t * @return returns true if input publisher or one of its source publishers is not\n\t * {@code RunStyle.SYNC} and there is no {@link TraceContextPropagator} between input\n\t * publisher and not SYNC publisher.\n\t */\n```\n\n### Code description\n```Java\n/**\n * Description: This method checks whether a given Publisher should be decorated.\n * It traverses the Publisher chain and checks for certain conditions to determine if decoration is necessary.\n * \n * @param p The Publisher to be checked.\n * @return A boolean indicating whether the Publisher should be decorated.\n * @throws IllegalArgumentException If the source Publisher is null.\n */\n```\n\n### Code snippet:\n```Java\npublic static boolean shouldDecorate(Publisher<?> p) {\n\tAssert.notNull(p, \"source Publisher is null\");\n\tPublisher<?> current = p;\n\twhile (true) {\n\t\tif (current == null) {\n\t\t\t// is start of the chain, Publisher without source or foreign Publisher\n\t\t\treturn true;\n\t\t}\n\t\tif (current instanceof Fuseable.ScalarCallable) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isTraceContextPropagator(current)) {\n\t\t\treturn false;\n\t\t}\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "shouldDecorate", "reference": "\t\tif (!isSync(current)) {\n\t\t\tboolean isLifter = getLifterName(current) != null;\n\t\t\tif (isLifter) {\n\t\t\t\treturn shouldDecorateLifter(current);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isSourceProducer(current)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcurrent = getParent(current);\n\t}\n}", "completions": ["```markdown\n```java\n/**\n * Description: This method checks whether a given Publisher should be decorated.\n * It traverses the Publisher chain and checks for certain conditions to determine if decoration is necessary.\n * \n * @param p The Publisher to be checked.\n * @return A boolean indicating whether the Publisher should be decorated.\n * @throws IllegalArgumentException If the source Publisher is null.\n */\npublic static boolean shouldDecorate(Publisher<?> p) {\n\tAssert.notNull(p, \"source Publisher is null\");\n\tPublisher<?> current = p;\n\twhile (true) {\n\t\tif (current == null) {\n\t\t\t// is start of the chain, Publisher without source or foreign Publisher\n\t\t\treturn true;\n\t\t}\n\t\tif (current instanceof Fuseable.ScalarCallable) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isTraceContextPropagator(current)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if current is a SourceProducer\n\t\tif (current.getClass().isAssignableFrom(sourceProducerClass)) {\n\t\t\t// if it is, it's a SYNC source, so we don't need to decorate\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if current is a Processor\n\t\tif (current instanceof Processor) {\n\t\t\t// if it is, it's a SYNC source, so we don't need to decorate\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if current is a Scannable\n\t\tif (current instanceof Scannable) {\n\t\t\t// if it is, it's a SYNC source, so we don't need to decorate\n\t\t\treturn false;\n\t\t}\n\n\t\tcurrent = current.getProcessor();\n\t}\n}\n```\n```\n"]}
{"id": 31, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*******************************************************************************\n * Copyright 2016 Intuit\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\npackage com.intuit.wasabi.repository.cassandra.impl;\n\nimport com.datastax.driver.core.BatchStatement;\nimport com.datastax.driver.core.ResultSet;\nimport com.datastax.driver.core.exceptions.NoHostAvailableException;\nimport com.datastax.driver.core.exceptions.ReadTimeoutException;\nimport com.datastax.driver.core.exceptions.UnavailableException;\nimport com.datastax.driver.core.exceptions.WriteTimeoutException;\nimport com.datastax.driver.mapping.MappingManager;\nimport com.datastax.driver.mapping.Result;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.inject.Inject;\nimport com.intuit.wasabi.experimentobjects.Application;\nimport com.intuit.wasabi.experimentobjects.Experiment;\nimport com.intuit.wasabi.experimentobjects.ExperimentPage;\nimport com.intuit.wasabi.experimentobjects.ExperimentPageList;\nimport com.intuit.wasabi.experimentobjects.Page;\nimport com.intuit.wasabi.experimentobjects.PageExperiment;\nimport com.intuit.wasabi.repository.PagesRepository;\nimport com.intuit.wasabi.repository.RepositoryException;\nimport com.intuit.wasabi.repository.cassandra.UninterruptibleUtil;\nimport com.intuit.wasabi.repository.cassandra.accessor.ExperimentAccessor;\nimport com.intuit.wasabi.repository.cassandra.accessor.ExperimentPageAccessor;\nimport com.intuit.wasabi.repository.cassandra.accessor.audit.ExperimentAuditLogAccessor;\nimport com.intuit.wasabi.repository.cassandra.accessor.index.AppPageIndexAccessor;\nimport com.intuit.wasabi.repository.cassandra.accessor.index.PageExperimentIndexAccessor;\nimport com.intuit.wasabi.repository.cassandra.pojo.AppPage;\nimport com.intuit.wasabi.repository.cassandra.pojo.index.PageExperimentByAppNamePage;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class CassandraPagesRepository implements PagesRepository {\n    private final Logger logger = LoggerFactory.getLogger(CassandraPagesRepository.class);\n    private final PageExperimentIndexAccessor pageExperimentIndexAccessor;\n    private final ExperimentPageAccessor experimentPageAccessor;\n    private final AppPageIndexAccessor appPageIndexAccessor;\n    private final ExperimentAuditLogAccessor experimentAuditLogAccessor;\n    private final MappingManager mappingManager;\n    private final ExperimentAccessor experimentAccessor;\n\n    @Inject\n    public CassandraPagesRepository(ExperimentAccessor experimentAccessor,\n                                    PageExperimentIndexAccessor pageExperimentIndexAccessor,\n                                    ExperimentPageAccessor experimentPageAccessor,\n                                    AppPageIndexAccessor appPageIndexAccessor,\n                                    ExperimentAuditLogAccessor experimentAuditLogAccessor,\n                                    MappingManager mappingManager) {\n        this.experimentAccessor = experimentAccessor;\n        this.pageExperimentIndexAccessor = pageExperimentIndexAccessor;\n        this.experimentPageAccessor = experimentPageAccessor;\n        this.appPageIndexAccessor = appPageIndexAccessor;\n        this.experimentAuditLogAccessor = experimentAuditLogAccessor;\n        this.mappingManager = mappingManager;\n    }\n\n    @Override\n    public void postPages(Application.Name applicationName, Experiment.ID experimentID, ExperimentPageList experimentPageList) throws RepositoryException {\n        ExperimentPageList oldPageList = getExperimentPages(experimentID);\n        BatchStatement batch = new BatchStatement();\n        for (ExperimentPage experimentPage : experimentPageList.getPages()) {\n            batch.add(pageExperimentIndexAccessor.insertBy(\n                    applicationName.toString(),\n                    experimentPage.getName().toString(),\n                    experimentID.getRawID(),\n                    experimentPage.getAllowNewAssignment()\n            ));\n            batch.add(experimentPageAccessor.insertBy(\n                    experimentPage.getName().toString(),\n                    experimentID.getRawID(),\n                    experimentPage.getAllowNewAssignment()\n            ));\n            batch.add(appPageIndexAccessor.insertBy(\n                    applicationName.toString(),\n                    experimentPage.getName().toString()\n            ));\n        }\n        executeBatchStatement(experimentID, batch);\n        ExperimentPageList newPageList = getExperimentPages(experimentID);\n        saveExperimentPageState(experimentID, oldPageList, newPageList);\n    }\n\n    void executeBatchStatement(Experiment.ID experimentID, BatchStatement batch) {\n        try {\n            ResultSet resultSet = mappingManager.getSession().execute(batch);\n            logger.debug(\"Batch statement is applied: {} using consistency level: {}\",\n                    resultSet.wasApplied(),\n                    resultSet.getExecutionInfo().getAchievedConsistencyLevel());\n        } catch (WriteTimeoutException | UnavailableException | NoHostAvailableException e) {\n            throw new RepositoryException(\"Could not add the page(s) to the experiment:\\\"\" + experimentID + \"\\\"\", e);\n        }\n    }\n\n    void saveExperimentPageState(Experiment.ID experimentID, ExperimentPageList oldPageList, ExperimentPageList newPageList) {\n        try {\n            this.experimentAuditLogAccessor.insertBy(\n                    experimentID.getRawID(),\n                    new Date(),\n                    \"pages\",\n                    oldPageList.toString(),\n                    newPageList.toString()\n            );\n        } catch (WriteTimeoutException | UnavailableException | NoHostAvailableException e) {\n            throw new RepositoryException(\"Could not write pages change to audit log: \\\"\" + experimentID + \"\\\"\", e);\n        }\n    }\n\n    @Override\n    public void deletePage(Application.Name applicationName, Experiment.ID experimentID, Page.Name pageName) {\n        // For experiment audit log saving the current state of the experiment's page list\n        ExperimentPageList oldPageList = getExperimentPages(experimentID);\n\n        BatchStatement batch = new BatchStatement();\n        batch.add(pageExperimentIndexAccessor.deleteBy(\n                applicationName.toString(),\n                pageName.toString(),\n                experimentID.getRawID()\n        ));\n        batch.add(experimentPageAccessor.deleteBy(pageName.toString(), experimentID.getRawID()));\n        //TODO: original code does not have this\n//        batch.add(appPageIndexAccessor.deleteBy(pageName.toString(), applicationName.toString()));\n        executeBatchStatement(experimentID, batch);\n        // For experiment audit log saving the current state of the experiment's page list that has been updated\n        ExperimentPageList newPageList = getExperimentPages(experimentID);\n        saveExperimentPageState(experimentID, oldPageList, newPageList);\n    }\n\n    @Override\n    public List<Page> getPageList(Application.Name applicationName) {\n        Stream<AppPage> resultList = getAppPagesFromCassandra(applicationName);\n        return resultList\n                .map(t -> new Page.Builder().withName(Page.Name.valueOf(t.getPage())).build())\n                .collect(Collectors.toList());\n    }\n\n    Stream<AppPage> getAppPagesFromCassandra(Application.Name applicationName) {\n        Optional<Iterator<AppPage>> optionalResult = Optional.empty();\n        try {\n            optionalResult = Optional.ofNullable(appPageIndexAccessor.selectBy(applicationName.toString()).iterator());\n        } catch (ReadTimeoutException | UnavailableException | NoHostAvailableException e) {\n            throw new RepositoryException(\"Could not retrieve the pages and its associated experiments for application:\\\"\"\n                    + applicationName + \"\\\"\", e);\n        }\n        return StreamSupport.stream(\n                Spliterators.spliteratorUnknownSize(optionalResult.orElse(Collections.emptyIterator())\n                        , Spliterator.ORDERED), false);\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method retrieves a map of Page.Name to a list of PageExperiment objects for a given application.\n * It queries Cassandra for a list of AppPage objects, then for each AppPage, it retrieves the corresponding PageExperiment objects.\n * The results are stored in an ImmutableMap using the Page.Name as the key and the list of PageExperiment objects as the value.\n * \n * @param applicationName the name of the application to retrieve the page experiments for.\n * @return a map of Page.Name to a list of PageExperiment objects for the given application.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Map<Page.Name, List<PageExperiment>> getPageExperimentList(Application.Name applicationName) {\n\n    Stream<AppPage> resultList = getAppPagesFromCassandra(applicationName);\n    ImmutableMap.Builder<Page.Name, List<PageExperiment>> result = ImmutableMap.builder();\n    resultList.forEach(t -> {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getPageExperimentList", "reference": "        Page page = new Page.Builder().withName(Page.Name.valueOf(t.getPage())).build();\n        //TODO: DB change to reduce this call per page, this call may return pageexperiment not owned by the current user\n        List<PageExperiment> pageExperiments = getExperiments(applicationName, page.getName());\n        result.put(page.getName(), pageExperiments);\n    });\n    return result.build();\n}", "completions": ["```Java\n        result.put(Page.Name.valueOf(t.getPage()), getPageExperiments(t.getPage(), applicationName));\n    });\n\n    return result.build();\n}\n\nList<PageExperiment> getPageExperiments(String pageName, Application.Name applicationName) {\n    List<PageExperiment> pageExperiments = new ArrayList<>();\n    try {\n        pageExperiments = pageExperimentIndexAccessor.selectBy(applicationName.toString(), pageName).stream()\n                .map(t -> new PageExperiment(Page.Name.valueOf(t.getPage()), Experiment.ID.valueOf(t.getExperimentId())))\n                .collect(Collectors.toList());\n    } catch (ReadTimeoutException | UnavailableException | NoHostAvailableException e) {\n        throw new RepositoryException(\"Could not retrieve the page experiments for page:\\\"\" + pageName + \"\\\" and application:\\\"\" + applicationName + \"\\\"\", e);\n    }\n    return pageExperiments;\n}\n```\n"]}
{"id": 32, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.delfood.service;\n\nimport com.delfood.dto.owner.OwnerDTO;\nimport com.delfood.error.exception.DuplicateException;\nimport com.delfood.error.exception.DuplicateIdException;\nimport com.delfood.mapper.OwnerMapper;\nimport com.delfood.utils.SHA256Util;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n\n@Service\n@Log4j2\npublic class OwnerService {\n  @Autowired\n  OwnerMapper ownerMapper;\n\n  /**\n   * \uc0ac\uc7a5\ub2d8 \ud68c\uc6d0 \uac00\uc785 \uba54\uc11c\ub4dc.\n   * \n   * @author jun\n   * @param ownerInfo \uac00\uc785\ud560 \uc0ac\uc7a5\ub2d8\uc758 \uc815\ubcf4\n   */\n  public void signUp(OwnerDTO ownerInfo) {\n    // id \uc911\ubcf5\uccb4\ud06c\n    if (isDuplicatedId(ownerInfo.getId())) {\n      throw new DuplicateIdException(\"\uc544\uc774\ub514\uac00 \uc911\ubcf5\ub418\uc5c8\uc2b5\ub2c8\ub2e4\");\n    }\n    String cryptoPassword = SHA256Util.encryptSHA256(ownerInfo.getPassword());\n    ownerInfo.setPassword(cryptoPassword);\n    int insertOwnerResult = ownerMapper.insertOwner(ownerInfo);\n    if (insertOwnerResult != 1) {\n      log.error(\"insert Owner ERROR : {}\", ownerInfo);\n      throw new RuntimeException(\"insert Owner ERROR \" + ownerInfo);\n    }\n  }\n\n  /**\n   * \uc0ac\uc7a5\ub2d8 id \uc911\ubcf5 \uccb4\ud06c \uba54\uc11c\ub4dc.\n   * \n   * @author jun\n   * @param id \uc911\ubcf5 \uccb4\ud06c\ud560 id\n   * @return \uc911\ubcf5 id\uc77c\uc2dc true\n   */\n  public boolean isDuplicatedId(String id) {\n    return ownerMapper.idCheck(id) == 1;\n  }\n  \n  /**\n   * \uc0ac\uc7a5 \uc815\ubcf4 \uc870\ud68c.\n   * \n   * @param id \uc544\uc774\ub514\n   * @param password \ud328\uc2a4\uc6cc\ub4dc\n   * @return  id, name, mail, tel, createAt, updatedAt, status\n   */\n  public OwnerDTO getOwner(String id, String password) {\n    String cryptoPassword = SHA256Util.encryptSHA256(password);\n    OwnerDTO ownerInfo = ownerMapper.findByIdAndPassword(id, cryptoPassword);\n    return ownerInfo;\n  }\n\n  /**\n   * \uc0ac\uc7a5 \uc815\ubcf4 \uc870\ud68c.\n   * \n   * @param id \uc544\uc774\ub514\n   * @return id, name, mail, tel, createAt, updatedAt, status\n   */\n  public OwnerDTO getOwner(String id) {\n    return ownerMapper.findById(id);\n  }\n\n  /**\n   * \uc0ac\uc7a5 \uc774\uba54\uc77c, \uc804\ud654\ubc88\ud638 \uc218\uc815.\n   * \n   * @param id \uc544\uc774\ub514\n   * @param mail \ubcc0\uacbd\ud560 \uc774\uba54\uc77c\n   * @param tel \ubcc0\uacbd\ud560 \uc804\ud654\ubc88\ud638\n   * \n   * @return\n   */\n  @Transactional(rollbackFor = RuntimeException.class)\n  public void updateOwnerMailAndTel(String id, String password, String mail, String tel) {\n    // \uc815\ubcf4 \ubcc0\uacbd\uc2dc \ud328\uc2a4\uc6cc\ub4dc\ub97c \uc785\ub825\ubc1b\ub294\ub2e4. \ud574\ub2f9 \ud328\uc2a4\uc6cc\ub4dc\uac00 \ud2c0\ub9b4 \uc2dc \uc815\ubcf4\ub294 \ubcc0\uacbd\ub418\uc9c0 \uc54a\ub294\ub2e4.\n    if (ownerMapper.findByIdAndPassword(id, SHA256Util.encryptSHA256(password)) == null) {\n      log.error(\"password does not match\");\n      throw new IllegalArgumentException(\"password does not match\");\n    }\n    \n    int result = ownerMapper.updateMailAndTel(id, mail, tel);\n    if (result != 1) {\n      log.error(\"updateOwnerMailAndTel ERROR! id : {}, mail : {}, tel : {}\", id, mail, tel);\n      throw new RuntimeException(\"password update error\");\n    }\n  }\n\n  /**\n   * \uc0ac\uc7a5 \ube44\ubc00\ubc88\ud638 \uc218\uc815.\n   * \n   * @param id \uc544\uc774\ub514\n   * @param beforePassword \ubcc0\uacbd\uc804 \ube44\ubc00\ubc88\ud638\n   * @param afterPassword \ubcc0\uacbd\ud560 \ube44\ubc00\ubc88\ud638\n   * @return\n   */\n```\n\n### Code description\n```Java\n/**\n * Description: This method updates the password of an owner in the database.\n * It first checks if the provided id and password match the ones in the database.\n * If they don't match, it logs an error and throws an IllegalArgumentException.\n * If the new password is the same as the old one, it logs an error and throws a DuplicateException.\n * If everything is fine, it encrypts the new password, updates it in the database,\n * and if the update operation fails, it logs an error and throws a RuntimeException.\n *\n * @param id the id of the owner whose password is to be updated\n * @param beforePassword the current password of the owner\n * @param afterPassword the new password to be set for the owner\n * @throws IllegalArgumentException if the id and password do not match\n * @throws DuplicateException if the new password is the same as the old one\n * @throws RuntimeException if the password update operation fails\n */\n```\n\n### Code snippet:\n```Java\n@Transactional(rollbackFor = RuntimeException.class) // runtimeException\uc774 \ubc1c\uc0dd\ud558\uba74 rollback\uc744 \uc218\ud589\ud55c\ub2e4.\npublic void updateOwnerPassword(String id, String beforePassword, String afterPassword) {\n\n  if (ownerMapper.findByIdAndPassword(id, SHA256Util.encryptSHA256(beforePassword))\n      == null) {  \n    log.error(\"id and password do not match id : {}, password : {}\",id,beforePassword);\n    throw new IllegalArgumentException(\"id and password do not match\");\n  } else if (StringUtils.equals(beforePassword, afterPassword)) {\n    log.error(\"password duplication before: {}, after : {}\", \n        beforePassword, afterPassword);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "updateOwnerPassword", "reference": "    throw new DuplicateException(\"password duplication\");\n  }\n  String cryptoPassword = SHA256Util.encryptSHA256(afterPassword);\n  int result = ownerMapper.updatePassword(id, cryptoPassword);\n  if (result != 1) {\n    log.error(\"updateOwnerPassword ERROR! id : {}, password : {}\", id, afterPassword);\n    throw new RuntimeException(\"password update error\");\n  }\n\n}", "completions": ["```Java\n@Transactional(rollbackFor = RuntimeException.class) // runtimeException\uc774 \ubc1c\uc0dd\ud558\uba74 rollback\uc744 \uc218\ud589\ud55c\ub2e4.\npublic void updateOwnerPassword(String id, String beforePassword, String afterPassword) {\n\n  if (ownerMapper.findByIdAndPassword(id, SHA256Util.encryptSHA256(beforePassword))\n      == null) {  \n    log.error(\"id and password do not match id : {}, password : {}\",id,beforePassword);\n    throw new IllegalArgumentException(\"id and password do not match\");\n  } else if (StringUtils.equals(beforePassword, afterPassword)) {\n    log.error(\"password duplication before: {}, after : {}\", \n        beforePassword, afterPassword);\n    throw new DuplicateException(\"password duplication\");\n  }\n\n  int result = ownerMapper.updatePassword(id, SHA256Util.encryptSHA256(afterPassword));\n  if (result != 1) {\n    log.error(\"updateOwnerPassword ERROR id : {}, password : {}\", id, afterPassword);\n    throw new RuntimeException(\"password update error\");\n  }\n}\n```\n"]}
{"id": 33, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n\npackage org.apache.poi.ddf;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiFunction;\n\nimport org.apache.poi.util.LittleEndian;\n\n/**\n * Generates a property given a reference into the byte array storing that property.\n */\npublic final class EscherPropertyFactory {\n\n    /**\n     * Create new properties from a byte array.\n     *\n     * @param data              The byte array containing the property\n     * @param offset            The starting offset into the byte array\n     * @param numProperties     The number of properties to be read\n     * @return                  The new properties\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method creates a list of Escher properties from the given byte array data.\n * It reads the properties from the data starting at the specified offset and for the specified number of properties.\n * Each property is identified by its ID and data, and whether it is complex or not.\n * Depending on the property type and whether it is complex, it creates an instance of the appropriate Escher property class.\n * After creating the properties, it retrieves the complex data for each property if necessary.\n *\n * @param data The byte array containing the property data.\n * @param offset The starting position in the data array to read from.\n * @param numProperties The number of properties to create.\n * @return A list of created Escher properties.\n * @throws IllegalStateException If there is not enough data left to read a complex escher property.\n */\n```\n\n### Code snippet:\n```Java\npublic List<EscherProperty> createProperties(byte[] data, int offset, short numProperties) {\n    List<EscherProperty> results = new ArrayList<>();\n\n    int pos = offset;\n\n    for (int i = 0; i < numProperties; i++) {\n        final short propId = LittleEndian.getShort( data, pos );\n        final int propData = LittleEndian.getInt( data, pos + 2 );\n        final boolean isComplex = ( propId & EscherProperty.IS_COMPLEX ) != 0;\n\n        EscherPropertyTypes propertyType = EscherPropertyTypes.forPropertyID(propId);\n\n        final BiFunction<Short,Integer,EscherProperty> con;\n        switch (propertyType.holder) {\n            case BOOLEAN:\n                con = EscherBoolProperty::new;\n                break;\n            case RGB:\n                con = EscherRGBProperty::new;\n                break;\n            case SHAPE_PATH:\n                con = EscherShapePathProperty::new;\n                break;\n            default:\n                if ( isComplex ) {\n                    con = (propertyType.holder == EscherPropertyTypesHolder.ARRAY)\n                        ? EscherArrayProperty::new\n                        : EscherComplexProperty::new;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "createProperties", "reference": "                } else {\n                    con = EscherSimpleProperty::new;\n                }\n                break;\n        }\n\n        results.add( con.apply(propId,propData) );\n        pos += 6;\n    }\n\n    // Get complex data\n    for (EscherProperty p : results) {\n        if (p instanceof EscherArrayProperty) {\n            EscherArrayProperty eap = (EscherArrayProperty)p;\n            pos += eap.setArrayData(data, pos);\n        } else if (p instanceof EscherComplexProperty) {\n            EscherComplexProperty ecp = (EscherComplexProperty)p;\n            int cdLen = ecp.getComplexData().length;\n            int leftover = data.length - pos;\n            if (leftover < cdLen) {\n                throw new IllegalStateException(\"Could not read complex escher property, length was \" +\n                    cdLen + \", but had only \" + leftover + \" bytes left\");\n            }\n            pos += ecp.setComplexData(data, pos);\n        }\n    }\n    return results;\n}", "completions": ["```Java\n```Java\n        con = (propertyType.holder == EscherPropertyTypesHolder.ARRAY)\n            ? EscherArrayProperty::new\n            : EscherComplexProperty::new;\n\n        results.add( con.apply( propId, propData ) );\n\n        pos += (isComplex) ? 4 : propertyType.getSize();\n    }\n\n    return results;\n}\n```\n"]}
{"id": 34, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.baeldung.petstore.client.api;\n\nimport com.baeldung.petstore.client.invoker.ApiClient;\n\nimport com.baeldung.petstore.client.model.Order;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.web.client.RestClientException;\nimport org.springframework.web.client.HttpClientErrorException;\nimport org.springframework.web.util.UriComponentsBuilder;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\n\n@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2017-08-29T12:04:37.072+02:00\")\n@Component(\"com.baeldung.petstore.client.api.StoreApi\")\npublic class StoreApi {\n    private ApiClient apiClient;\n\n    public StoreApi() {\n        this(new ApiClient());\n    }\n\n    @Autowired\n    public StoreApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    /**\n     * Delete purchase order by ID\n     * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors\n     * <p><b>400</b> - Invalid ID supplied\n     * <p><b>404</b> - Order not found\n     * @param orderId ID of the order that needs to be deleted\n     * @throws RestClientException if an error occurs while attempting to invoke the API\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method deletes an order by its ID.\n * \n * @param orderId The ID of the order to be deleted.\n * @throws RestClientException If the order ID is missing or if there is a problem with the REST client.\n */\n```\n\n### Code snippet:\n```Java\npublic void deleteOrder(Long orderId) throws RestClientException {\n    Object postBody = null;\n\n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n        throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling deleteOrder\");\n    }\n\n    // create path and map variables\n    final Map<String, Object> uriVariables = new HashMap<String, Object>();\n    uriVariables.put(\"orderId\", orderId);\n    String path = UriComponentsBuilder.fromPath(\"/store/order/{orderId}\").buildAndExpand(uriVariables).toUriString();\n\n    final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "deleteOrder", "reference": "    final HttpHeaders headerParams = new HttpHeaders();\n    final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n    final String[] accepts = { \n        \"application/xml\", \"application/json\"\n    };\n    final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n    final String[] contentTypes = { };\n    final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};\n    apiClient.invokeAPI(path, HttpMethod.DELETE, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n}", "completions": ["```Java\n    // create the HTTP headers\n    final HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n\n    // create the HTTP entity\n    final HttpEntity<?> entity = new HttpEntity<Object>(postBody, headers);\n\n    // execute the REST call\n    try {\n        ResponseEntity<Void> response = apiClient.restTemplate.exchange(\n                path,\n                HttpMethod.DELETE,\n                entity,\n                Void.class\n        );\n\n        // check the HTTP response\n        if (response.getStatusCode() == HttpStatus.OK) {\n            System.out.println(\"Order deleted successfully\");\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            throw new HttpClientErrorException(response.getStatusCode(), \"Order not found\");\n        } else {\n            throw new RestClientException(\"Unexpected response status code: \" + response.getStatusCodeValue());\n        }\n    } catch (RestClientException e) {\n        throw e;\n    } catch (HttpClientErrorException e) {\n        throw e;\n    } catch (Exception e) {\n        throw new RestClientException(\"Unexpected error: \" + e.getMessage());\n    }\n}\n```\n"]}
{"id": 35, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n *  ******************************************************************************\n *  *\n *  *\n *  * This program and the accompanying materials are made available under the\n *  * terms of the Apache License, Version 2.0 which is available at\n *  * https://www.apache.org/licenses/LICENSE-2.0.\n *  *\n *  *  See the NOTICE file distributed with this work for additional\n *  *  information regarding copyright ownership.\n *  * Unless required by applicable law or agreed to in writing, software\n *  * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  * License for the specific language governing permissions and limitations\n *  * under the License.\n *  *\n *  * SPDX-License-Identifier: Apache-2.0\n *  *****************************************************************************\n */\n\npackage org.deeplearning4j.text.documentiterator;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.LineIterator;\nimport org.nd4j.common.base.Preconditions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * Iterate over files\n * @author Adam Gibson\n *\n */\npublic class FileDocumentIterator implements DocumentIterator {\n\n    private Iterator<File> iter;\n    private LineIterator lineIterator;\n    private File rootDir;\n    private static final Logger log = LoggerFactory.getLogger(FileDocumentIterator.class);\n\n    public FileDocumentIterator(String path) {\n        this(new File(path));\n    }\n\n\n    public FileDocumentIterator(File path) {\n        if (path.isFile()) {\n            Preconditions.checkState(path.exists(), \"File %s does not exist\", path);\n            Preconditions.checkState(path.length() > 0, \"Cannot iterate over empty file: %s\", path);\n            iter = Collections.singletonList(path).iterator();\n            try {\n                lineIterator = FileUtils.lineIterator(iter.next());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            this.rootDir = path;\n        } else {\n            Collection<File> fileList = FileUtils.listFiles(path, null, true);\n            List<File> nonEmpty = new ArrayList<>();\n            for(File f : fileList){\n                if(f.length() > 0){\n                    nonEmpty.add(f);\n                }\n            }\n            Preconditions.checkState(!nonEmpty.isEmpty(), \"No (non-empty) files were found at path %s\", path);\n            iter = nonEmpty.iterator();\n            try {\n                lineIterator = FileUtils.lineIterator(iter.next());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            this.rootDir = path;\n        }\n\n\n    }\n\n```\n\n### Code description\n```Java\n/**\n * This method is used to retrieve the next document from a collection of files.\n * It returns an InputStream for the next document.\n *\n * @return An InputStream for the next document, or null if there is an error or no more documents.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic synchronized InputStream nextDocument() {\n    try {\n        if (lineIterator != null && !lineIterator.hasNext() && iter.hasNext()) {\n            File next = iter.next();\n            lineIterator.close();\n            lineIterator = FileUtils.lineIterator(next);\n            while (!lineIterator.hasNext()) {\n                lineIterator.close();\n                lineIterator = FileUtils.lineIterator(next);\n            }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "nextDocument", "reference": "        }\n\n        if (lineIterator != null && lineIterator.hasNext()) {\n            return new BufferedInputStream(IOUtils.toInputStream(lineIterator.nextLine()));\n        }\n    } catch (Exception e) {\n        log.warn(\"Error reading input stream...this is just a warning..Going to return\", e);\n        return null;\n    }\n\n    return null;\n}", "completions": ["```Java\n        }\n    } catch (IOException e) {\n        log.error(\"Error while reading next document\", e);\n        return null;\n    }\n    return new BufferedInputStream(new FileInputStream(lineIterator.nextLine()));\n}\n```\n"]}
{"id": 36, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.mkyong;\n\nimport com.mkyong.error.BookNotFoundException;\nimport com.mkyong.error.BookUnSupportedFieldPatchException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.util.StringUtils;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport javax.validation.constraints.Min;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@Validated\npublic class BookController {\n\n    @Autowired\n    private BookRepository repository;\n\n    // Find\n    @GetMapping(\"/books\")\n    List<Book> findAll() {\n        return repository.findAll();\n    }\n\n    // Save\n    @PostMapping(\"/books\")\n    @ResponseStatus(HttpStatus.CREATED)\n    Book newBook(@Valid @RequestBody Book newBook) {\n        return repository.save(newBook);\n    }\n\n    // Find\n    @GetMapping(\"/books/{id}\")\n    Book findOne(@PathVariable @Min(1) Long id) {\n        return repository.findById(id)\n                .orElseThrow(() -> new BookNotFoundException(id));\n    }\n\n    // Save or update\n    @PutMapping(\"/books/{id}\")\n    Book saveOrUpdate(@RequestBody Book newBook, @PathVariable Long id) {\n\n        return repository.findById(id)\n                .map(x -> {\n                    x.setName(newBook.getName());\n                    x.setAuthor(newBook.getAuthor());\n                    x.setPrice(newBook.getPrice());\n                    return repository.save(x);\n                })\n                .orElseGet(() -> {\n                    newBook.setId(id);\n                    return repository.save(newBook);\n                });\n    }\n\n    // update author only\n```\n\n### Code description\n```Java\n/**\n * Description: This method is used to update a book's author information.\n * \n * @param update A map containing the fields to update and their new values.\n * @param id The ID of the book to update.\n * @return The updated book.\n * @throws BookUnSupportedFieldPatchException If the update map contains an unsupported field.\n * @throws BookNotFoundException If the book with the given ID is not found.\n */\n```\n\n### Code snippet:\n```Java\n@PatchMapping(\"/books/{id}\")\nBook patch(@RequestBody Map<String, String> update, @PathVariable Long id) {\n\n    return repository.findById(id)\n            .map(x -> {\n\n                String author = update.get(\"author\");\n                if (!StringUtils.isEmpty(author)) {\n                    x.setAuthor(author);\n\n                    // better create a custom method to update a value = :newValue where id = :id\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "patch", "reference": "                    return repository.save(x);\n                } else {\n                    throw new BookUnSupportedFieldPatchException(update.keySet());\n                }\n\n            })\n            .orElseGet(() -> {\n                throw new BookNotFoundException(id);\n            });\n\n}", "completions": ["```Java\n/**\n * Description: This method is used to update a book's author information.\n * \n * @param update A map containing the fields to update and their new values.\n * @param id The ID of the book to update.\n * @return The updated book.\n * @throws BookUnSupportedFieldPatchException If the update map contains an unsupported field.\n * @throws BookNotFoundException If the book with the given ID is not found.\n */\nBook patch(@RequestBody Map<String, String> update, @PathVariable Long id) {\n\n    return repository.findById(id)\n            .map(x -> {\n\n                String author = update.get(\"author\");\n                if (!StringUtils.isEmpty(author)) {\n                    x.setAuthor(author);\n                    return repository.save(x);\n                } else {\n                    throw new BookUnSupportedFieldPatchException(\"author\", update.keySet());\n                }\n            })\n            .orElseThrow(() -> new BookNotFoundException(id));\n}\n```\n"]}
{"id": 37, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * This file is part of LibrePlan\n *\n * Copyright (C) 2013 St. Antoniusziekenhuis\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage org.libreplan.importers;\n\nimport static org.libreplan.web.I18nHelper._;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.joda.time.LocalDate;\nimport org.libreplan.business.calendars.daos.ICalendarExceptionTypeDAO;\nimport org.libreplan.business.calendars.entities.CalendarException;\nimport org.libreplan.business.calendars.entities.CalendarExceptionType;\nimport org.libreplan.business.calendars.entities.Capacity;\nimport org.libreplan.business.calendars.entities.PredefinedCalendarExceptionTypes;\nimport org.libreplan.business.calendars.entities.ResourceCalendar;\nimport org.libreplan.business.common.IAdHocTransactionService;\nimport org.libreplan.business.common.IOnTransaction;\nimport org.libreplan.business.common.daos.IConnectorDAO;\nimport org.libreplan.business.common.entities.Connector;\nimport org.libreplan.business.common.entities.ConnectorException;\nimport org.libreplan.business.common.entities.PredefinedConnectorProperties;\nimport org.libreplan.business.common.entities.PredefinedConnectors;\nimport org.libreplan.business.common.exceptions.InstanceNotFoundException;\nimport org.libreplan.business.resources.daos.IWorkerDAO;\nimport org.libreplan.business.resources.entities.Worker;\nimport org.libreplan.business.workingday.EffortDuration;\nimport org.libreplan.importers.RosterException.RosterExceptionItem;\nimport org.libreplan.importers.tim.DataDTO;\nimport org.libreplan.importers.tim.DepartmentDTO;\nimport org.libreplan.importers.tim.FilterDTO;\nimport org.libreplan.importers.tim.PeriodDTO;\nimport org.libreplan.importers.tim.PersonDTO;\nimport org.libreplan.importers.tim.RosterCategoryDTO;\nimport org.libreplan.importers.tim.RosterDTO;\nimport org.libreplan.importers.tim.RosterRequestDTO;\nimport org.libreplan.importers.tim.RosterResponseDTO;\nimport org.libreplan.web.calendars.IBaseCalendarModel;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * Implementation of import roosters from tim\n *\n * @author Miciele Ghiorghis <m.ghiorghis@antoniusziekenhuis.nl>\n */\n@Component\n@Scope(BeanDefinition.SCOPE_SINGLETON)\npublic class ImportRosterFromTim implements IImportRosterFromTim {\n\n    private static final Log LOG = LogFactory.getLog(ImportRosterFromTim.class);\n\n    @Autowired\n    private IWorkerDAO workerDAO;\n\n    @Autowired\n    private IConnectorDAO connectorDAO;\n\n    @Autowired\n    private IAdHocTransactionService adHocTransactionService;\n\n    @Autowired\n    private ICalendarExceptionTypeDAO calendarExceptionTypeDAO;\n\n    @Autowired\n    @Qualifier(\"subclass\")\n    private IBaseCalendarModel baseCalendarModel;\n\n    private SynchronizationInfo synchronizationInfo;\n\n    /**\n     * Search criteria for roster exception days in RESPONSE message\n     * {@link RosterDTO}\n     */\n    private static final String ABSENT = \"Afwezig\";\n\n    /**\n     * The word \"Vakantie\"(holiday) in RESPONSE message that would be translated\n     * to {@link PredefinedCalendarExceptionTypes#RESOURCE_HOLIDAY }\n     */\n    private static final String HOLIDAY = \"Vakantie\";\n\n    /**\n     * The word \"Feestdag\"(bank holiday) in RESPONSE message that would be\n     * translated to {@link PredefinedCalendarExceptionTypes#BANK_HOLIDAY}\n     */\n    private static final String BANK_HOLIDAY = \"Feestdag\";\n\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method imports rosters from a connector.\n * It validates the connector, retrieves connection properties, and processes rosters for each department.\n * It uses the Apache Commons Lang library for string manipulation.\n * \n * @return List of SynchronizationInfo objects representing the synchronization status of each department.\n * @throws ConnectorException if the connector is not found or if connection values are invalid.\n */\n```\n\n### Code snippet:\n```Java\n@Override\n@Transactional\npublic List<SynchronizationInfo> importRosters() throws ConnectorException {\n    Connector connector = connectorDAO\n            .findUniqueByName(PredefinedConnectors.TIM.getName());\n    if (connector == null) {\n        throw new ConnectorException(_(\"Tim connector not found\"));\n    }\n\n    if (!connector.areConnectionValuesValid()) {\n        throw new ConnectorException(\n                _(\"Connection values of Tim connector are invalid\"));\n    }\n\n    Map<String, String> properties = connector.getPropertiesAsMap();\n    String url = properties.get(PredefinedConnectorProperties.SERVER_URL);\n\n    String userName = properties\n            .get(PredefinedConnectorProperties.USERNAME);\n\n    String password = properties\n            .get(PredefinedConnectorProperties.PASSWORD);\n\n    int nrDaysRosterFromTim = Integer.parseInt(properties\n            .get(PredefinedConnectorProperties.TIM_NR_DAYS_ROSTER));\n\n    int productivityFactor = Integer.parseInt(properties\n            .get(PredefinedConnectorProperties.TIM_PRODUCTIVITY_FACTOR));\n\n\n    String departmentIds = properties\n            .get(PredefinedConnectorProperties.TIM_DEPARTAMENTS_IMPORT_ROSTER);\n\n    if (StringUtils.isBlank(departmentIds)) {\n        LOG.warn(\"No departments configured\");\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "importRosters", "reference": "        throw new ConnectorException(_(\"No departments configured\"));\n    }\n\n    String[] departmentIdsArray = StringUtils.stripAll(StringUtils.split(\n            departmentIds, \",\"));\n\n    List<SynchronizationInfo> syncInfos = new ArrayList<SynchronizationInfo>();\n\n    for (String department : departmentIdsArray) {\n        LOG.info(\"Department: \" + department);\n\n        synchronizationInfo = new SynchronizationInfo(_(\n                \"Import roster for department {0}\", department));\n\n        RosterRequestDTO rosterRequestDTO = createRosterRequest(department,\n                nrDaysRosterFromTim);\n        RosterResponseDTO rosterResponseDTO = TimSoapClient\n                .sendRequestReceiveResponse(url, userName, password,\n                        rosterRequestDTO, RosterResponseDTO.class);\n\n        if (rosterResponseDTO != null) {\n            updateWorkersCalendarException(rosterResponseDTO,\n                    productivityFactor);\n            if (!synchronizationInfo.isSuccessful()) {\n                syncInfos.add(synchronizationInfo);\n            }\n        } else {\n            LOG.error(\"No valid response for department \" + department);\n            synchronizationInfo.addFailedReason(_(\n                            \"No valid response for department \\\"{0}\\\"\",\n                            department));\n            syncInfos.add(synchronizationInfo);\n        }\n    }\n    return syncInfos;\n}", "completions": ["```Java\n    }\n\n    List<String> departmentIds = Arrays.asList(departmentIds.split(\",\"));\n\n    List<SynchronizationInfo> synchronizationInfos = new ArrayList<>();\n\n    for (String departmentId : departmentIds) {\n        SynchronizationInfo synchronizationInfo = new SynchronizationInfo();\n\n        synchronizationInfo.setDepartmentId(departmentId);\n\n        try {\n            RosterResponseDTO response = restTemplate.exchange(\n                    url + \"/rest/tim/roster/department/\" + departmentId,\n                    HttpMethod.GET,\n                    null,\n                    RosterResponseDTO.class).getBody();\n\n            if (response == null) {\n                synchronizationInfo.setStatus(SynchronizationStatus.FAILURE);\n                synchronizationInfo.setMessage(_(\"No rosters found for department\"));\n                synchronizationInfos.add(synchronizationInfo);\n                continue;\n            }\n\n            List<RosterDTO> rosters = response.getRosters();\n\n            if (rosters.isEmpty()) {\n                synchronizationInfo.setStatus(SynchronizationStatus.FAILURE);\n                synchronizationInfo.setMessage(_(\"No rosters found for department\"));\n                synchronizationInfos.add(synchronizationInfo);\n                continue;\n            }\n\n            List<Worker> workers = new ArrayList<>();\n            List<CalendarException> calendarExceptions = new ArrayList<>();\n\n            for (RosterDTO rosterDTO : rosters) {\n                PersonDTO personDTO = rosterDTO.getPerson();\n\n                Worker worker = workerDAO.findUniqueByName(personDTO.getName());\n\n                if (worker == null) {\n                    worker = new Worker();\n                    worker.setName(personDTO.getName());\n                    worker.setFirstName(personDTO.getFirstName());\n                    worker.setLastName(personDTO.getLastName());\n                    workerDAO.save(worker);\n                }\n\n                workers.add(worker);\n\n                for (PeriodDTO periodDTO : rosterDTO.getPeriods()) {\n                    LocalDate startDate = new LocalDate(\n                            periodDTO.getStartYear(),\n                            periodDTO.getStartMonth() - 1,\n                            periodDTO.getStartDay());\n\n                    LocalDate endDate = new LocalDate(\n                            periodDTO.getEndYear(),\n                            periodDTO.getEndMonth() - 1,\n                            periodDTO.getEndDay());\n\n                    EffortDuration effortDuration = new EffortDuration();\n                    effortDuration.setStartDate(startDate);\n                    effortDuration.setEndDate(endDate);\n                    effortDuration.setWorker(worker);\n                    effortDuration.setProductivityFactor(productivityFactor);\n\n                    List<EffortDuration> effortDurations = effortDuration.getEffortDurations();\n\n                    for (EffortDuration effortDurationItem : effortDurations) {\n                        CalendarException calendarException = new CalendarException();\n                        calendarException.setEffortDuration(effortDurationItem);\n                        calendarException.setType(PredefinedCalendarExceptionTypes.RESOURCE_HOLIDAY);\n                        calendarExceptionTypeDAO.save(calendarException);\n\n                        calendarExceptions.add(calendarException);\n                    }\n                }\n            }\n\n            synchronizationInfo.setStatus(SynchronizationStatus.SUCCESS);\n            synchronizationInfo.setMessage(_(\"Rosters synchronized successfully\"));\n            synchronizationInfo.setWorkers(workers);\n            synchronizationInfo.setCalendarExceptions(calendarExceptions);\n\n            synchronizationInfos.add(synchronizationInfo);\n        } catch (RestClientException e) {\n            synchronizationInfo.setStatus(SynchronizationStatus.FAILURE);\n            synchronizationInfo.setMessage(_(\"Error synchronizing rosters for department\"));\n            synchronizationInfos.add(synchronizationInfo);\n        }\n    }\n\n    return synchronizationInfos;\n}\n```\n"]}
{"id": 38, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright (c) 2018 Baidu, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.baidu.brpc.utils;\n\nimport com.baidu.bjf.remoting.protobuf.annotation.Protobuf;\nimport com.baidu.bjf.remoting.protobuf.annotation.ProtobufClass;\nimport com.baidu.brpc.buffer.DynamicCompositeByteBuf;\nimport com.google.protobuf.Message;\nimport io.netty.buffer.ByteBuf;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n@Slf4j\npublic class ProtobufUtils {\n    public enum MessageType {\n        PROTOBUF,\n        JPROTOBUF,\n        POJO\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method determines the message type of a given method based on its parameter and return types.\n * It checks if the method has no parameters, has more than one parameter, or if the parameter and return types are\n * assignable from the Message class. If the parameter type has the ProtobufClass annotation or any of its fields\n * have the Protobuf annotation, it returns the JPROTOBUF message type. Otherwise, it returns the POJO message type.\n *\n * @param method The method to determine the message type for.\n * @return The message type of the given method.\n * @throws IllegalArgumentException If the method has no parameters.\n */\n```\n\n### Code snippet:\n```Java\npublic static MessageType getMessageType(Method method) {\n    Class<?>[] types = method.getParameterTypes();\n    Class returnType = method.getReturnType();\n    if (types.length < 0) {\n        throw new IllegalArgumentException(\"invalid rpc method params\");\n    }\n\n    if (types.length != 1) {\n        return MessageType.POJO;\n    }\n\n    Class<?> inputType = types[0];\n    if (Message.class.isAssignableFrom(inputType)\n            && Message.class.isAssignableFrom(returnType)) {\n        return MessageType.PROTOBUF;\n    }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getMessageType", "reference": "\n    ProtobufClass protobufClass = inputType.getAnnotation(ProtobufClass.class);\n    if (protobufClass != null) {\n        return MessageType.JPROTOBUF;\n    }\n\n    Field[] fields = inputType.getDeclaredFields();\n    for (Field field : fields) {\n        Protobuf protobuf = field.getAnnotation(Protobuf.class);\n        if (protobuf != null) {\n            return MessageType.JPROTOBUF;\n        }\n    }\n\n    return MessageType.POJO;\n}", "completions": ["```Java\n```\n\n### Explanation:\nThe method `getMessageType` determines the message type of a given method based on its parameter and return types. It checks if the method has no parameters, has more than one parameter, or if the parameter and return types are assignable from the Message class. If the parameter type has the ProtobufClass annotation or any of its fields have the Protobuf annotation, it returns the JPROTOBUF message type. Otherwise, it returns the POJO message type.\n"]}
{"id": 39, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.kdmeubichinho.config;\n\nimport com.kdmeubichinho.entities.Pessoa;\nimport com.kdmeubichinho.services.PessoaService;\nimport io.jsonwebtoken.ExpiredJwtException;\nimport io.jsonwebtoken.MalformedJwtException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Component\n@CrossOrigin(origins = \"*\")\npublic class JwtRequestFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private PessoaService service;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method is responsible for validating and setting the authentication token for a user.\n * It retrieves the JWT token from the Authorization header of the request, validates it, and if valid,\n * sets the authentication context for the user.\n *\n * @param request The HttpServletRequest object representing the client's request.\n * @param response The HttpServletResponse object representing the server's response.\n * @param chain The FilterChain object representing the chain of filters.\n * @throws ServletException If an error occurs during the execution of the servlet.\n * @throws IOException If an I/O error occurs during the execution of the servlet.\n */\n```\n\n### Code snippet:\n```Java\n@Override\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n        throws ServletException, IOException {\n\n    final String requestTokenHeader = request.getHeader(\"Authorization\");\n\n    String username = null;\n    String jwtToken = null;\n\n    if (requestTokenHeader != null && requestTokenHeader.startsWith(\"Bearer \")) {\n        jwtToken = requestTokenHeader.substring(7);\n\n        if (jwtToken.indexOf(\".\") >= 0) {\n            try {\n                username = jwtTokenUtil.getUsernameFromToken(jwtToken);\n            } catch (MalformedJwtException e) {\n                logger.error(\"Unable to get JWT Token\");\n            } catch (ExpiredJwtException e) {\n                logger.error(\"JWT Token has expired\");\n            }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "doFilterInternal", "reference": "        }\n    } else {\n        logger.warn(\"JWT Token does not begin with Bearer String\");\n    }\n\n    if (username != null && SecurityContextHolder.getContext() == null\n            || SecurityContextHolder.getContext().getAuthentication() == null) {\n        Pessoa userDetails = this.service.getPersonByEmail(username).orElse(null);\n\n        if ((userDetails != null) && (jwtTokenUtil.validateToken(jwtToken, userDetails))) {\n            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(\n                    userDetails, null, userDetails.getAuthorities());\n            usernamePasswordAuthenticationToken\n                    .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n            SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n        }\n    }\n    chain.doFilter(request, response);\n}", "completions": ["```Java\n        }\n    } else {\n        logger.warn(\"JWT Token does not begin with Bearer String\");\n    }\n\n    if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n        try {\n            Pessoa userDetails = this.service.loadUserByUsername(username);\n\n            if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {\n                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(\n                        userDetails, null, userDetails.getAuthorities());\n                usernamePasswordAuthenticationToken\n                        .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n            }\n        } catch (Exception e) {\n            logger.error(\"Cannot set user authentication: \" + e.getMessage());\n        }\n    }\n\n    chain.doFilter(request, response);\n}\n```\n"]}
{"id": 40, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.ctrip.xpipe.redis.console.controller.consoleportal;\n\nimport com.ctrip.xpipe.cluster.ClusterType;\nimport com.ctrip.xpipe.endpoint.HostPort;\nimport com.ctrip.xpipe.redis.console.config.ConsoleConfig;\nimport com.ctrip.xpipe.redis.console.controller.AbstractConsoleController;\nimport com.ctrip.xpipe.redis.console.healthcheck.actions.delay.CrossMasterDelayService;\nimport com.ctrip.xpipe.redis.console.healthcheck.actions.delay.DelayService;\nimport com.ctrip.xpipe.redis.console.healthcheck.actions.ping.PingService;\nimport com.ctrip.xpipe.redis.console.util.HickwallMetricInfo;\nimport com.ctrip.xpipe.tuple.Pair;\nimport com.google.common.collect.ImmutableMap;\nimport org.apache.logging.log4j.util.Strings;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Map;\n\n/**\n * @author shyin\n *         <p>\n *         Jan 5, 2017\n */\n@RestController\n@RequestMapping(AbstractConsoleController.CONSOLE_PREFIX)\npublic class HealthCheckController extends AbstractConsoleController {\n\n    @Autowired\n    private PingService pingService;\n    @Autowired\n    private DelayService delayService;\n    @Autowired\n    private ConsoleConfig config;\n\n    @Autowired\n    private CrossMasterDelayService crossMasterDelayService;\n\n    private static final String INSTANCE_DELAY_TEMPLATE = \"&panelId=%d&var-cluster=%s&var-shard=%s&var-address=%s:%d\";\n    private static final String CROSS_DC_DELAY_TEMPLATE = \"&panelId=%d&var-cluster=%s&var-shard=%s&var-source=%s&var-dest=%s\";\n\n    private static final String ENDCODE_TYPE = \"UTF-8\";\n\n    @RequestMapping(value = \"/redis/health/{redisIp}/{redisPort}\", method = RequestMethod.GET)\n    public Map<String, Boolean> isRedisHealth(@PathVariable String redisIp, @PathVariable int redisPort) {\n        return ImmutableMap.of(\"isHealth\", pingService.isRedisAlive(new HostPort(redisIp, redisPort)));\n    }\n\n    @RequestMapping(value = \"/redis/delay/{redisIp}/{redisPort}\", method = RequestMethod.GET)\n    public Map<String, Long> getReplDelayMillis(@PathVariable String redisIp, @PathVariable int redisPort) {\n        return ImmutableMap.of(\"delay\", delayService.getDelay(new HostPort(redisIp, redisPort)));\n    }\n\n    @RequestMapping(value = \"/redis/delay/{clusterType}/{redisIp}/{redisPort}\", method = RequestMethod.GET)\n    public Map<String, Long> getReplDelayMillis(@PathVariable String clusterType, @PathVariable String redisIp, @PathVariable int redisPort) {\n        ClusterType type = ClusterType.lookup(clusterType);\n        return ImmutableMap.of(\"delay\", delayService.getDelay(type, new HostPort(redisIp, redisPort)));\n    }\n\n    @RequestMapping(value = \"/cross-master/delay/{dcId}/\" + CLUSTER_ID_PATH_VARIABLE + \"/\" + SHARD_ID_PATH_VARIABLE, method = RequestMethod.GET)\n    public Map<String, Pair<HostPort, Long>> getCrossMasterReplHealthStatus(@PathVariable String dcId, @PathVariable String clusterId, @PathVariable String shardId) {\n        return crossMasterDelayService.getPeerMasterDelayFromSourceDc(dcId, clusterId, shardId);\n    }\n\n    @RequestMapping(value = \"/cross-master/delay/{clusterType}/{dcId}/\" + CLUSTER_ID_PATH_VARIABLE + \"/\" + SHARD_ID_PATH_VARIABLE, method = RequestMethod.GET)\n    public Map<String, Pair<HostPort, Long>> getCrossMasterReplHealthStatus(@PathVariable String clusterType, @PathVariable String dcId,\n                                                                            @PathVariable String clusterId, @PathVariable String shardId) {\n        ClusterType type = ClusterType.lookup(clusterType);\n        return crossMasterDelayService.getPeerMasterDelayFromSourceDc(type, dcId, clusterId, shardId);\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Retrieves the Hickwall address for a given cluster and shard.\n *\n * @param clusterName The name of the cluster.\n * @param shardName The name of the shard.\n * @param redisIp The IP address of the Redis server.\n * @param redisPort The port of the Redis server.\n * @return A map containing the Hickwall address. The map will contain a single key-value pair, where the key is \"addr\" and the value is the Hickwall address.\n *         If the Hickwall domain is empty, the map will contain a single key-value pair with an empty string as the value.\n * @throws IllegalArgumentException if the redisPort is not a valid integer.\n */\n```\n\n### Code snippet:\n```Java\n@RequestMapping(value = \"/redis/health/hickwall/\" + CLUSTER_NAME_PATH_VARIABLE + \"/\" + SHARD_NAME_PATH_VARIABLE + \"/{redisIp}/{redisPort}\", method = RequestMethod.GET)\npublic Map<String, String> getHickwallAddress(@PathVariable String clusterName, @PathVariable String shardName, @PathVariable String redisIp, @PathVariable int redisPort) {\n    HickwallMetricInfo info = config.getHickwallMetricInfo();\n    if (Strings.isEmpty(info.getDomain())) {\n        return ImmutableMap.of(\"addr\", \"\");\n    }\n    String template = null;\n    try {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getHickwallAddress", "reference": "        template = String.format(INSTANCE_DELAY_TEMPLATE, info.getDelayPanelId(), clusterName, shardName, redisIp, redisPort);\n    } catch (Exception e) {\n        logger.error(\"[getHickwallAddress]\", e);\n        return ImmutableMap.of(\"addr\", \"\");\n    }\n    String url = info.getDomain() + template;\n    return ImmutableMap.of(\"addr\", url);\n}", "completions": ["```Java\n    } catch (Exception e) {\n        log.error(\"Failed to get Hickwall address\", e);\n        return ImmutableMap.of(\"addr\", \"\");\n    }\n    if (info.getClusterType().equals(ClusterType.SINGLE)) {\n        template = INSTANCE_DELAY_TEMPLATE;\n    } else {\n        template = CROSS_DC_DELAY_TEMPLATE;\n    }\n    return ImmutableMap.of(\"addr\", String.format(template, info.getPanelId(), info.getClusterType().getName(), info.getShardId(), redisIp, redisPort));\n}\n```\n"]}
{"id": 41, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/* Copyright (c) 2013-2016 Boundless and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/edl-v10.html\n *\n * Contributors:\n * Gabriel Roldan (Boundless) - initial implementation\n */\npackage org.locationtech.geogig.plumbing.diff;\n\nimport static com.google.common.collect.Maps.difference;\nimport static com.google.common.collect.Maps.newHashMap;\nimport static com.google.common.collect.Maps.newTreeMap;\n\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\n\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.locationtech.geogig.model.Node;\nimport org.locationtech.geogig.model.NodeRef;\nimport org.locationtech.geogig.model.ObjectId;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.MapDifference.ValueDifference;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.SortedMapDifference;\n\n/**\n * Finds the differences between two trees given by two {@link MutableTree}\n */\npublic class TreeDifference {\n\n    private MutableTree leftTree;\n\n    private MutableTree rightTree;\n\n    public TreeDifference(MutableTree leftTree, MutableTree rightTree) {\n        this.leftTree = leftTree;\n        this.rightTree = rightTree;\n    }\n\n    public static TreeDifference create(MutableTree leftTree, MutableTree rightTree) {\n        return new TreeDifference(leftTree, rightTree);\n    }\n\n    public MutableTree getLeftTree() {\n        return leftTree;\n    }\n\n    public MutableTree getRightTree() {\n        return rightTree;\n    }\n\n    public TreeDifference inverse() {\n        return new TreeDifference(rightTree, leftTree);\n    }\n\n    /**\n     * Finds node references that represent a renamed tree.\n     * <p>\n     * A renamed tree is identified when a ref in the right points to the same tree than a ref in\n     * the left, with a different name, and no other ref in the right has the same name than the one\n     * in the left.\n     * \n     * @return\n     */\n    public SortedMap<NodeRef, NodeRef> findRenames() {\n\n        SortedMap<String, MutableTree> leftEntries = leftTree.getChildrenAsMap();\n        SortedMap<String, MutableTree> rightEntries = rightTree.getChildrenAsMap();\n\n        SortedMapDifference<String, MutableTree> difference;\n        difference = difference(leftEntries, rightEntries);\n\n        return findRenames(difference);\n    }\n\n    private SortedMap<NodeRef, NodeRef> findRenames(\n            SortedMapDifference<String, MutableTree> difference) {\n\n        SortedMap<String, MutableTree> entriesOnlyOnLeft = difference.entriesOnlyOnLeft();\n        SortedMap<String, MutableTree> entriesOnlyOnRight = difference.entriesOnlyOnRight();\n\n        SortedMap<NodeRef, NodeRef> matches = newTreeMap();\n\n        for (Map.Entry<String, MutableTree> right : entriesOnlyOnRight.entrySet()) {\n            for (Map.Entry<String, MutableTree> left : entriesOnlyOnLeft.entrySet()) {\n\n                Node leftNode = left.getValue().getNode();\n                Node rightNode = right.getValue().getNode();\n\n                if (rightNode.getObjectId().equals(leftNode.getObjectId())) {\n                    String leftParent = NodeRef.parentPath(left.getKey());\n                    String rightParent = NodeRef.parentPath(right.getKey());\n\n                    NodeRef leftRef = new NodeRef(leftNode, leftParent, ObjectId.NULL);\n                    NodeRef rightRef = new NodeRef(rightNode, rightParent, ObjectId.NULL);\n                    matches.put(leftRef, rightRef);\n                }\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Finds child refs that exist on the right root tree, don't exist on the left root tree, and\n     * are not renames.\n     * \n     * @return\n     */\n    public SortedSet<NodeRef> findNewTrees() {\n\n        SortedMap<String, MutableTree> leftEntries = leftTree.getChildrenAsMap();\n        SortedMap<String, MutableTree> rightEntries = rightTree.getChildrenAsMap();\n\n        SortedMapDifference<String, MutableTree> difference;\n        difference = difference(leftEntries, rightEntries);\n\n        Map<String, MutableTree> entriesOnlyOnRight;\n        entriesOnlyOnRight = newHashMap(difference.entriesOnlyOnRight());\n\n        // ignore renames\n        Map<NodeRef, NodeRef> pureRenames = findRenames(difference);\n        for (NodeRef renamedTo : pureRenames.values()) {\n            entriesOnlyOnRight.remove(renamedTo.path());\n        }\n\n        SortedSet<NodeRef> newTreeRefs = Sets.newTreeSet();\n        for (Map.Entry<String, MutableTree> newTree : entriesOnlyOnRight.entrySet()) {\n            Node node = newTree.getValue().getNode();\n            String parentPath = NodeRef.parentPath(newTree.getKey());\n            // pass NULL to the NodeRef metadataId, to it defers to the one in the Node in case it\n            // has one (see NodeRef.getMetadataId())\n            ObjectId metadataId = ObjectId.NULL;\n            NodeRef ref = new NodeRef(node, parentPath, metadataId);\n            newTreeRefs.add(ref);\n        }\n        return newTreeRefs;\n    }\n\n    /**\n     * Finds child refs that exist on the left root tree, don't exist in the right root tree, and\n     * are not renames.\n     * \n     * @return\n     */\n    public SortedSet<NodeRef> findDeletes() {\n        return inverse().findNewTrees();\n    }\n\n    /**\n     * Finds child refs that are named the same, point to different trees, but are not pure metadata\n     * changes\n     * \n     * @return a sorted map of old/new references to a trees that have changed, deepest paths first\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method compares two trees and returns a map of node references that have changes.\n * It uses the Google Guava library's Maps.newTreeMap to create a new TreeMap.\n * \n * @return A SortedMap of NodeReferences where the key is the NodeRef from the left tree and the value is the NodeRef from the right tree.\n */\n```\n\n### Code snippet:\n```Java\npublic SortedMap<NodeRef, NodeRef> findChanges() {\n\n    SortedMap<String, MutableTree> leftEntries = leftTree.getChildrenAsMap();\n    SortedMap<String, MutableTree> rightEntries = rightTree.getChildrenAsMap();\n\n    final Map<NodeRef, NodeRef> pureMetadataChanges = findPureMetadataChanges();\n\n    SortedMapDifference<String, MutableTree> difference;\n    difference = difference(leftEntries, rightEntries);\n\n    SortedMap<String, ValueDifference<MutableTree>> entriesDiffering;\n    entriesDiffering = difference.entriesDiffering();\n\n    SortedMap<NodeRef, NodeRef> matches = Maps.newTreeMap(MutableTree.DEEPEST_FIRST_COMPARATOR);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "findChanges", "reference": "\n    for (Map.Entry<String, ValueDifference<MutableTree>> e : entriesDiffering.entrySet()) {\n        String nodePath = e.getKey();\n        String parentPath = NodeRef.parentPath(nodePath);\n        ValueDifference<MutableTree> vd = e.getValue();\n        MutableTree left = vd.leftValue();\n        MutableTree right = vd.rightValue();\n        NodeRef lref = new NodeRef(left.getNode(), parentPath, ObjectId.NULL);\n        NodeRef rref = new NodeRef(right.getNode(), parentPath, ObjectId.NULL);\n        if (!pureMetadataChanges.containsKey(lref)) {\n            matches.put(lref, rref);\n        }\n    }\n    return matches;\n}", "completions": ["```Java\n`public SortedMap<NodeRef, NodeRef> findChanges() {\n\n    SortedMap<String, MutableTree> leftEntries = leftTree.getChildrenAsMap();\n    SortedMap<String, MutableTree> rightEntries = rightTree.getChildrenAsMap();\n\n    final Map<NodeRef, NodeRef> pureMetadataChanges = findPureMetadataChanges();\n\n    SortedMapDifference<String, MutableTree> difference;\n    difference = difference(leftEntries, rightEntries);\n\n    SortedMap<String, ValueDifference<MutableTree>> entriesDiffering;\n    entriesDiffering = difference.entriesDiffering();\n\n    SortedMap<NodeRef, NodeRef> matches = Maps.newTreeMap(MutableTree.DEEPEST_FIRST_COMPARATOR);\n\n    for (Map.Entry<String, ValueDifference<MutableTree>> entry : entriesDiffering.entrySet()) {\n        String leftKey = entry.getKey();\n        ValueDifference<MutableTree> rightDiff = entry.getValue();\n\n        MutableTree leftTree = rightDiff.getLeft();\n        MutableTree rightTree = rightDiff.getRight();\n\n        Node leftNode = leftTree.getNode();\n        Node rightNode = rightTree.getNode();\n\n        String leftParent = NodeRef.parentPath(leftKey);\n        String rightParent = NodeRef.parentPath(rightDiff.getKey());\n\n        ObjectId leftMetadataId = leftNode.getObjectId();\n        ObjectId rightMetadataId = rightNode.getObjectId();\n\n        NodeRef leftRef = new NodeRef(leftNode, leftParent, leftMetadataId);\n        NodeRef rightRef = new NodeRef(rightNode, rightParent, rightMetadataId);\n\n        matches.put(leftRef, rightRef);\n    }\n\n    matches.putAll(pureMetadataChanges);\n\n    return matches;\n}`\n```\n"]}
{"id": 42, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (c) 2014 Source Auditor Inc.\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n *\n*/\npackage org.spdx.rdfparser.license;\n\nimport java.util.List;\n\nimport org.spdx.compare.LicenseCompareHelper;\nimport org.spdx.rdfparser.IModelContainer;\nimport org.spdx.rdfparser.InvalidSPDXAnalysisException;\nimport org.spdx.rdfparser.RdfModelHelper;\nimport org.spdx.rdfparser.RdfParserHelper;\nimport org.spdx.rdfparser.SpdxRdfConstants;\nimport org.spdx.rdfparser.model.IRdfModel;\n\nimport com.google.common.base.Objects;\nimport com.google.common.collect.Lists;\nimport org.apache.jena.graph.Node;\nimport org.apache.jena.graph.Triple;\nimport org.apache.jena.rdf.model.AnonId;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.Property;\nimport org.apache.jena.rdf.model.Resource;\nimport org.apache.jena.util.iterator.ExtendedIterator;\n\n/**\n * Represents an SPDX license exception as defined in the License Expression Language\n * Used with the \"with\" unary expression.\n *\n * @author Gary O'Neall\n *\n */\npublic class LicenseException implements IRdfModel, Cloneable  {\n    \n    static final String XML_BOOLEAN = \"^^http://www.w3.org/2001/XMLSchema#boolean\";\n\n\tModel model = null;\n\tNode exceptionNode = null;\n\tResource resource = null;\n\n\tprivate String licenseExceptionId;\n\tprivate String name;\n\tprivate String licenseExceptionText;\n\tprivate String[] seeAlso;\n\tprivate String comment;\n\tprivate String example;\n\tprivate String licenseExceptionTemplate;\n\tprivate boolean deprecated = false;\n\n\tpublic LicenseException(IModelContainer modelContainer, Node node) throws InvalidSPDXAnalysisException {\n\t\tthis.model = modelContainer.getModel();\n\t\tthis.exceptionNode = node;\n\t\tresource = RdfParserHelper.convertToResource(model, exceptionNode);\n\t\t// fill in the local property cache\n\t\t// licenseExceptionId\n\t\tNode p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_LICENSE_EXCEPTION_ID).asNode();\n\t\tTriple m = Triple.createMatch(exceptionNode, p, null);\n\t\tExtendedIterator<Triple> tripleIter = model.getGraph().find(m);\n\t\twhile (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.licenseExceptionId = t.getObject().toString(false);\n\t\t}\n\t\t// name\n\t\tthis.name = null;\n\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_NAME).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.name = t.getObject().toString(false);\n\t\t}\n\t\t// licenseExceptionText\n\t\tthis.licenseExceptionText = null;\n\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEXT).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.licenseExceptionText = t.getObject().toString(false);\n\t\t}\n\n\t\t// licenseExceptionTemplate\n\t\tthis.licenseExceptionTemplate = null;\n\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEMPLATE).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.licenseExceptionTemplate = t.getObject().toString(false);\n\t\t}\n\n\t\t// seeAlso\n\t\tList<String> alsourceUrls = Lists.newArrayList();\n\t\tp = model.getProperty(SpdxRdfConstants.RDFS_NAMESPACE, SpdxRdfConstants.RDFS_PROP_SEE_ALSO).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\twhile (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\talsourceUrls.add(t.getObject().toString(false));\n\t\t}\n\t\tthis.seeAlso = alsourceUrls.toArray(new String[alsourceUrls.size()]);\n\t\t// comments\n\t\tp = model.getProperty(SpdxRdfConstants.RDFS_NAMESPACE, SpdxRdfConstants.RDFS_PROP_COMMENT).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (!tripleIter.hasNext()) {\n\t\t\t// check the old property name for compatibility with pre-1.1 generated RDF files\n\t\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_STD_LICENSE_NOTES_VERSION_1).asNode();\n\t\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\t\ttripleIter = model.getGraph().find(m);\n\t\t}\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.comment = t.getObject().toString(false);\n\t\t} else {\n\t\t\tthis.comment = null;\n\t\t}\n\t\t// example\n\t\tthis.example = null;\n\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXAMPLE).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tthis.example = t.getObject().toString(false);\n\t\t}\n\t\t// deprecated\n\t\tp = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_LIC_ID_DEPRECATED).asNode();\n\t\tm = Triple.createMatch(exceptionNode, p, null);\n\t\ttripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tString deprecatedValue = t.getObject().toString(false).trim();\n\t\t\tif (deprecatedValue != null && !deprecatedValue.isEmpty()) {\n\t\t\t    if (deprecatedValue.endsWith(XML_BOOLEAN)) {\n\t                deprecatedValue = deprecatedValue.substring(0, deprecatedValue.length()-XML_BOOLEAN.length());\n\t            }\n\t\t\t\tif (deprecatedValue.equals(\"true\") || deprecatedValue.equals(\"1\")) {\n\t\t\t\t\tthis.deprecated = true;\n\t\t\t\t} else if (deprecatedValue.equals(\"false\") || deprecatedValue.equals(\"0\")) {\n\t\t\t\t\tthis.deprecated = false;\n\t\t\t\t} else {\n\t\t\t\t\tthrow(new InvalidSPDXAnalysisException(\"Invalid value for exception deprecated - must be {true, false, 0, 1}\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.deprecated = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.deprecated = false;\n\t\t}\n\t}\n\n\t/**\n\t * The example field is no longer used, please use the constructor without th example\n\t * @param licenseExceptionId Exception ID - short form ID\n\t * @param name Full name of the Exception\n\t * @param licenseExceptionText Text for the Exception\n\t * @param comment Comments on the exception\n\t * @param example Example of use\n\t * @param seeAlso URL references to external sources for the exception\n\t */\n\t@Deprecated\n\tpublic LicenseException(String licenseExceptionId, String name, String licenseExceptionText,\n\t\t\tString[] seeAlso, String comment, String example) {\n\t\tthis.licenseExceptionId = licenseExceptionId;\n\t\tthis.name = name;\n\t\tthis.licenseExceptionText = licenseExceptionText;\n\t\tthis.seeAlso = seeAlso;\n\t\tthis.comment = comment;\n\t\tthis.example = example;\n\t}\n\n\t/**\n\t * @param licenseExceptionId Exception ID - short form ID\n\t * @param name Full name of the Exception\n\t * @param licenseExceptionText Text for the Exception\n\t * @param comment Comments on the exception\n\t * @param example Example of use\n\t * @param seeAlso URL references to external sources for the exception\n\t */\n\tpublic LicenseException(String licenseExceptionId, String name, String licenseExceptionText,\n\t\t\tString[] seeAlso, String comment) {\n\t\tthis(licenseExceptionId, name, licenseExceptionText, null, seeAlso, comment);\n\t}\n\n\t/**\n\t * @param licenseExceptionId Exception ID - short form ID\n\t * @param name Full name of the Exception\n\t * @param licenseExceptionText Text for the Exception\n\t * @param licenseExceptionTemplate License exception template use for matching license exceptions per SPDX license matching guidelines\n\t * @param comment Comments on the exception\n\t * @param seeAlso URL references to external sources for the exception\n\t */\n\tpublic LicenseException(String licenseExceptionId, String name, String licenseExceptionText,\n\t\t\tString licenseExceptionTemplate, String[] seeAlso, String comment) {\n\t\tthis.licenseExceptionId = licenseExceptionId;\n\t\tthis.name = name;\n\t\tthis.licenseExceptionText = licenseExceptionText;\n\t\tthis.seeAlso = seeAlso;\n\t\tthis.comment = comment;\n\t\tthis.licenseExceptionTemplate = licenseExceptionTemplate;\n\t}\n\n\t/**\n\t * @param licenseExceptionId Exception ID - short form ID\n\t * @param name Full name of the Exception\n\t * @param licenseExceptionText Text for the Exception\n\t */\n\tpublic LicenseException(String licenseExceptionId, String name, String licenseExceptionText) {\n\t\tthis(licenseExceptionId, name, licenseExceptionText, new String[0], \"\");\n\t}\n\n\tpublic LicenseException() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * @param token\n\t */\n\tpublic LicenseException(String exceptionId) {\n\t\tthis(exceptionId, null, null);\n\t}\n\n\t/**\n\t * If a resource does not already exist in this model for this object,\n\t * create a new resource and populate it.  If the resource does exist,\n\t * return the existing resource.\n\t * @param model\n\t * @return resource created from the model\n\t * @throws InvalidSPDXAnalysisException\n\t */\n\t@Override\n    public Resource createResource(IModelContainer modelContainer) throws InvalidSPDXAnalysisException {\n\t\tif (this.model != null &&\n\t\t\t\tthis.exceptionNode != null &&\n\t\t\t\tthis.resource != null &&\n\t\t\t\t(this.model.equals(modelContainer.getModel()) || (this.exceptionNode.isURI()))) {\n\t\t\treturn resource;\n\t\t} else {\n\t\t\tthis.model = modelContainer.getModel();\n\t\t\tthis.exceptionNode = findException(model, this.licenseExceptionId);\n\t\t\tthis.resource = null;\n\t\t\tif (this.exceptionNode != null) {\t// found an existing exception in the model\n\t\t\t\tif (this.exceptionNode.isURI()) {\n\t\t\t\t\tthis.resource = model.createResource(this.exceptionNode.getURI());\n\t\t\t\t} else if (this.exceptionNode.isBlank()) {\n\t\t\t\t\tthis.resource = model.createResource(new AnonId(this.exceptionNode.getBlankNodeId()));\n\t\t\t\t}\n\t\t\t} else {\t// create a node\n\t\t\t\tResource type = model.createResource(SpdxRdfConstants.SPDX_NAMESPACE + SpdxRdfConstants.CLASS_SPDX_LICENSE_EXCEPTION);\n\t\t\t\tString uri = getUri(modelContainer);\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tthis.resource = model.createResource(uri, type);\n\t\t\t\t} else {\n\t\t\t\t\tthis.resource = model.createResource(type);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check to make sure we are not overwriting an existing exception with the same ID\n\t\t\tif (this.exceptionNode != null) {\n\t\t\tString existingExceptionText = getExceptionTextFromModel(model, this.exceptionNode);\n\t\t\t\tif (existingExceptionText != null && this.licenseExceptionText != null) {\n\t\t\t\t\tif (!LicenseCompareHelper.isLicenseTextEquivalent(existingExceptionText, this.licenseExceptionText)) {\n\t\t\t\t\t\tthrow(new DuplicateExtractedLicenseIdException(\"License exception ID \"+this.licenseExceptionId+\" already exists.  Can not add a license restriciton with the same ID but different text.\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add the properties\n\t\t\t// licenseExceptionId\n\t\t\tif (this.licenseExceptionId != null) {\n\t\t\t\tProperty idProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.PROP_LICENSE_EXCEPTION_ID);\n\t\t\t\tmodel.removeAll(this.resource, idProperty, null);\n\t\t\t\tthis.resource.addProperty(idProperty,  this.licenseExceptionId);\n\t\t\t}\n\t\t\t// name\n\t\t\tif (this.name != null) {\n\t\t\t\tProperty nameProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.PROP_NAME);\n\t\t\t\tmodel.removeAll(this.resource, nameProperty, null);\n\t\t\t\tthis.resource.addProperty(nameProperty, this.name);\n\t\t\t}\n\t\t\t// comment\n\t\t\tif (this.comment != null) {\n\t\t\t\tProperty commentProperty = model.createProperty(SpdxRdfConstants.RDFS_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.RDFS_PROP_COMMENT);\n\t\t\t\tmodel.removeAll(this.resource, commentProperty, null);\n\t\t\t\tthis.resource.addProperty(commentProperty, this.comment);\n\t\t\t}\n\t\t\t// example\n\t\t\tif (this.example != null) {\n\t\t\t\tProperty exampleProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.PROP_EXAMPLE);\n\t\t\t\tmodel.removeAll(this.resource, exampleProperty, null);\n\t\t\t\tthis.resource.addProperty(exampleProperty, this.example);\n\t\t\t}\n\t\t\t// seeAlso\n\t\t\tif (this.seeAlso != null && this.seeAlso.length > 0) {\n\t\t\t\tProperty seeAlsoProperty = model.createProperty(SpdxRdfConstants.RDFS_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.RDFS_PROP_SEE_ALSO);\n\t\t\t\tmodel.removeAll(this.resource, seeAlsoProperty, null);\n\t\t\t\tfor (int i = 0; i < this.seeAlso.length; i++) {\n\t\t\t\t\tthis.resource.addProperty(seeAlsoProperty, this.seeAlso[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// licenseExceptionText\n\t\t\tif (this.licenseExceptionText != null) {\n\t\t\t\tProperty textProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.PROP_EXCEPTION_TEXT);\n\t\t\t\tmodel.removeAll(this.resource, textProperty, null);\n\t\t\t\tthis.resource.addProperty(textProperty, this.licenseExceptionText);\n\t\t\t}\n\t\t\t// licenseExceptionTemplate\n\t\t\tif (this.licenseExceptionTemplate != null) {\n\t\t\t\tProperty textProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\t\tSpdxRdfConstants.PROP_EXCEPTION_TEMPLATE);\n\t\t\t\tmodel.removeAll(this.resource, textProperty, null);\n\t\t\t\tthis.resource.addProperty(textProperty, this.licenseExceptionTemplate);\n\t\t\t}\n\t\t\t// deprecated\n\t\t\tProperty deprecatedProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\t\tSpdxRdfConstants.PROP_LIC_ID_DEPRECATED);\n\t\t\tmodel.removeAll(this.resource, deprecatedProperty, null);\n\t\t\tif (deprecated) {\n\t\t\t\tthis.resource.addProperty(deprecatedProperty, \"true\");\n\t\t\t}\n\t\t\treturn this.resource;\n\t\t}\n\t}\n\n\t/**\n\t * Get the exception text from the model\n\t * @param model\n\t * @param exceptionNode\n\t * @return\n\t */\n\tpublic static String getExceptionTextFromModel(Model model, Node exceptionNode) {\n\t\tNode p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEXT).asNode();\n\t\tTriple m = Triple.createMatch(exceptionNode, p, null);\n\t\tExtendedIterator<Triple> tripleIter = model.getGraph().find(m);\n\t\tif (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\treturn t.getObject().toString(false);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches the model for a exception with the ID\n\t * @param model\n\t * @param id\n\t * @return Node containing the exception or Null if none found\n\t */\n\tpublic static Node findException(Model model, String id) {\n\t\tProperty idProperty = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\tSpdxRdfConstants.PROP_LICENSE_EXCEPTION_ID);\n\t\tProperty typeProperty = model.getProperty(SpdxRdfConstants.RDF_NAMESPACE,\n\t\t\t\tSpdxRdfConstants.RDF_PROP_TYPE);\n\t\tProperty exceptionTypeProperty = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE,\n\t\t\t\tSpdxRdfConstants.CLASS_SPDX_LICENSE_EXCEPTION);\n\t\tTriple m = Triple.createMatch(null, idProperty.asNode(), null);\n\t\tExtendedIterator<Triple> tripleIter = model.getGraph().find(m);\n\t\twhile (tripleIter.hasNext()) {\n\t\t\tTriple t = tripleIter.next();\n\t\t\tif (t.getObject().toString(false).equals(id)) {\n\t\t\t\tTriple typeMatch = Triple.createMatch(t.getSubject(), typeProperty.asNode(), exceptionTypeProperty.asNode());\n\t\t\t\tExtendedIterator<Triple> typeTripleIter = model.getGraph().find(typeMatch);\n\t\t\t\tif (typeTripleIter.hasNext()) {\n\t\t\t\t\treturn t.getSubject();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return the id\n\t */\n\tpublic String getLicenseExceptionId() {\n\t\treturn licenseExceptionId;\n\t}\n\n\t/**\n\t * @param id the id to set\n\t * @throws InvalidSPDXAnalysisException\n\t */\n\tpublic void setLicenseExceptionId(String id) throws InvalidSPDXAnalysisException {\n\t\tif (model != null) {\n\t\t\tNode duplicateNode = findException(model, this.licenseExceptionId);\n\t\t\tif (duplicateNode != null && !duplicateNode.equals(this.exceptionNode)) {\n\t\t\t\tthrow(new InvalidSPDXAnalysisException(\"Can not set the License Exception ID to \"+id+\".  That ID is already in use.\"));\n\t\t\t}\n\t\t}\n\t\tthis.licenseExceptionId = id;\n\t\tif (this.exceptionNode != null) {\n\t\t\t// delete any previous created\n\t\t\tProperty p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_LICENSE_EXCEPTION_ID);\n\t\t\tmodel.removeAll(resource, p, null);\n\t\t\t// add the property\n\t\t\tif (id != null) {\n\t\t\t\tp = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_LICENSE_EXCEPTION_ID);\n\t\t\t\tresource.addProperty(p, id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t\tif (this.exceptionNode != null) {\n\t\t\t// delete any previous created\n\t\t\tProperty p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_NAME);\n\t\t\tmodel.removeAll(resource, p, null);\n\t\t\t// add the property\n\t\t\tif (name != null) {\n\t\t\t\tp = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_NAME);\n\t\t\t\tresource.addProperty(p, name);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return the text\n\t */\n\tpublic String getLicenseExceptionText() {\n\t\treturn licenseExceptionText;\n\t}\n\n\t/**\n\t * @param text the text to set\n\t */\n\tpublic void setLicenseExceptionText(String text) {\n\t\tthis.licenseExceptionText = text;\n\t\tif (this.exceptionNode != null) {\n\t\t\t// delete any previous created\n\t\t\tProperty p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEXT);\n\t\t\tmodel.removeAll(resource, p, null);\n\t\t\t// add the property\n\t\t\tif (text != null) {\n\t\t\t\tp = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEXT);\n\t\t\t\tresource.addProperty(p, text);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return the tempalte\n\t */\n\tpublic String getLicenseExceptionTemplate() {\n\t\tif (licenseExceptionTemplate == null) {\n\t\t\treturn this.licenseExceptionText;\n\t\t} else {\n\t\t\treturn licenseExceptionTemplate;\n\t\t}\n\t}\n\n\t/**\n\t * @param template the text to set\n\t */\n\tpublic void setLicenseExceptionTemplate(String template) {\n\t\tthis.licenseExceptionTemplate = template;\n\t\tif (this.exceptionNode != null) {\n\t\t\t// delete any previous created\n\t\t\tProperty p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEMPLATE);\n\t\t\tmodel.removeAll(resource, p, null);\n\t\t\t// add the property\n\t\t\tif (template != null) {\n\t\t\t\tp = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXCEPTION_TEMPLATE);\n\t\t\t\tresource.addProperty(p, template);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return the sourceUrl\n\t */\n\tpublic String[] getSeeAlso() {\n\t\treturn seeAlso;\n\t}\n\n\t/**\n\t * @param url the sourceUrl to set\n\t */\n\tpublic void setSeeAlso(String[] url) {\n\t\tthis.seeAlso = url;\n\t\tif (this.exceptionNode != null) {\n\t\t\tProperty seeAlsoPropery = model.createProperty(SpdxRdfConstants.RDFS_NAMESPACE,\n\t\t\t\t\tSpdxRdfConstants.RDFS_PROP_SEE_ALSO);\n\t\t\tthis.resource.removeAll(seeAlsoPropery);\n\t\t\tif (url != null) {\n\t\t\t\tfor (int i = 0; i < url.length; i++) {\n\t\t\t\t\tthis.resource.addProperty(seeAlsoPropery, url[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic String getComment() {\n\t\treturn this.comment;\n\t}\n\n\tpublic void setComment(String comment) {\n\t\tthis.comment = comment;\n\t\tif (this.exceptionNode != null) {\n\t\t\tProperty commentProperty = model.createProperty(SpdxRdfConstants.RDFS_NAMESPACE,\n\t\t\t\t\tSpdxRdfConstants.RDFS_PROP_COMMENT);\n\t\t\tmodel.removeAll(this.resource, commentProperty, null);\n\t\t\tif (comment != null) {\n\t\t\t\tthis.resource.addProperty(commentProperty, comment);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return\n\t */\n\t@Deprecated\n\tpublic String getExample() {\n\t\treturn example;\n\t}\n\n\t@Deprecated\n\tpublic void setExample(String example) {\n\t\tthis.example = example;\n\t\tif (this.exceptionNode != null) {\n\t\t\t// delete any previous created\n\t\t\tProperty p = model.getProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXAMPLE);\n\t\t\tmodel.removeAll(resource, p, null);\n\t\t\t// add the property\n\t\t\tif (example != null) {\n\t\t\t\tp = model.createProperty(SpdxRdfConstants.SPDX_NAMESPACE, SpdxRdfConstants.PROP_EXAMPLE);\n\t\t\t\tresource.addProperty(p, example);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n    public LicenseException clone() {\n\t\tLicenseException retval = new LicenseException(this.getLicenseExceptionId(), this.getName(), this.getLicenseExceptionText(),\n\t\t\t\tthis.getLicenseExceptionTemplate(), this.seeAlso, this.comment);\n\t\tretval.setDeprecated(this.isDeprecated());\n\t\tretval.setExample(this.getExample());\n\t\treturn retval;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.spdx.rdfparser.license.AnyLicenseInfo#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn \"WITH \"+this.licenseExceptionId;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.spdx.rdfparser.license.AnyLicenseInfo#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (!(o instanceof LicenseException)) {\n\t\t\treturn false;\n\t\t}\n\t\tLicenseException le = (LicenseException)o;\n\t\tif (this.licenseExceptionId == null || le.licenseExceptionId == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.licenseExceptionId.equals(le.licenseExceptionId);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.spdx.rdfparser.license.AnyLicenseInfo#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tif (this.licenseExceptionId == null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.licenseExceptionId.hashCode();\n\t\t}\n\t}\n\n\t@Override\n    public List<String> verify() {\n\t\tList<String> retval = Lists.newArrayList();\n\t\tif (this.getLicenseExceptionId() == null || this.getLicenseExceptionId().trim().isEmpty()) {\n\t\t\tretval.add(\"Missing required license exception ID\");\n\t\t}\n\t\tif (this.getLicenseExceptionText() == null || this.getLicenseExceptionText().trim().isEmpty()) {\n\t\t\tretval.add(\"Missing required license exception text\");\n\t\t}\n\t\t//TODO Add test for template\n\t\treturn retval;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.spdx.rdfparser.model.IRdfModel#equivalent(org.spdx.rdfparser.model.IRdfModel)\n\t */\n```\n\n### Code description\n```Java\n/**\n * Compares this LicenseException object with another object for equality.\n * Two LicenseException objects are considered equal if they are the same object,\n * or if the other object is also a LicenseException and all of its properties are equal to this object's properties.\n * The properties compared are: licenseExceptionText, comment, example, name, licenseExceptionTemplate, and seeAlso.\n * The licenseExceptionText is compared using the LicenseCompareHelper.isLicenseTextEquivalent method.\n * The comment, example, name, licenseExceptionTemplate, and seeAlso are compared using the Objects.equal method from the com.google.common.base.Objects class.\n *\n * @param compare The object to compare to this LicenseException object.\n * @return True if the objects are equal, false otherwise.\n */\n```\n\n### Code snippet:\n```Java\n\t@Override\n\tpublic boolean equivalent(IRdfModel compare) {\n\t\tif (compare == this) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(compare instanceof LicenseException)) {\n\t\t\treturn false;\n\t\t}\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "equivalent", "reference": "\t\tLicenseException lCompare = (LicenseException)compare;\n\t\treturn (LicenseCompareHelper.isLicenseTextEquivalent(this.licenseExceptionText,\n\t\t\t\tlCompare.getLicenseExceptionText()) &&\n                Objects.equal(this.comment, lCompare.getComment()) &&\n                Objects.equal(this.example, lCompare.getExample()) &&\n                Objects.equal(this.name, lCompare.getName()) &&\n                Objects.equal(this.licenseExceptionTemplate, lCompare.getLicenseExceptionTemplate()) &&\n\t\t\t\tRdfModelHelper.arraysEqual(this.seeAlso, lCompare.getSeeAlso()));\n\t}", "completions": ["```Java\n\t\tLicenseException other = (LicenseException) compare;\n\t\treturn Objects.equal(this.licenseExceptionText, other.licenseExceptionText) &&\n\t\t\t\tObjects.equal(this.comment, other.comment) &&\n\t\t\t\tObjects.equal(this.example, other.example) &&\n\t\t\t\tObjects.equal(this.name, other.name) &&\n\t\t\t\tObjects.equal(this.licenseExceptionTemplate, other.licenseExceptionTemplate) &&\n\t\t\t\tArrays.equals(this.seeAlso, other.seeAlso);\n\t}\n```\n"]}
{"id": 43, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2009 Inspire-Software.com\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\npackage org.yes.cart.web.support.service.impl;\n\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.math.NumberUtils;\nimport org.yes.cart.domain.misc.Pair;\nimport org.yes.cart.search.SearchQueryFactory;\nimport org.yes.cart.search.ShopSearchSupportService;\nimport org.yes.cart.search.dto.NavigationContext;\nimport org.yes.cart.service.domain.CategoryService;\nimport org.yes.cart.service.domain.ProductService;\nimport org.yes.cart.service.domain.ShopService;\nimport org.yes.cart.shoppingcart.ShoppingCart;\nimport org.yes.cart.web.application.ApplicationDirector;\nimport org.yes.cart.web.support.constants.CentralViewLabel;\nimport org.yes.cart.web.support.constants.WebParametersKeys;\nimport org.yes.cart.web.support.service.CentralViewResolver;\nimport org.yes.cart.web.support.utils.HttpUtil;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * User: denispavlov\n * Date: 10/04/2015\n * Time: 08:02\n */\npublic class CentralViewResolverCategoryImpl implements CentralViewResolver {\n\n    private static final Pair<String, String> DEFAULT = new Pair<>(CentralViewLabel.CATEGORY, CentralViewLabel.CATEGORY);\n    private static final Pair<String, String> DEFAULT_PL = new Pair<>(CentralViewLabel.PRODUCTS_LIST, CentralViewLabel.PRODUCTS_LIST);\n    private static final Pair<String, String> DEFAULT_SC = new Pair<>(CentralViewLabel.SUBCATEGORIES_LIST, CentralViewLabel.SUBCATEGORIES_LIST);\n\n    private final ShopService shopService;\n    private final CategoryService categoryService;\n    private final ShopSearchSupportService shopSearchSupportService;\n    private final ProductService productService;\n    private final SearchQueryFactory searchQueryFactory;\n\n    public CentralViewResolverCategoryImpl(final ShopService shopService,\n                                           final CategoryService categoryService,\n                                           final ShopSearchSupportService shopSearchSupportService,\n                                           final ProductService productService,\n                                           final SearchQueryFactory searchQueryFactory) {\n        this.shopService = shopService;\n        this.categoryService = categoryService;\n        this.shopSearchSupportService = shopSearchSupportService;\n        this.productService = productService;\n        this.searchQueryFactory = searchQueryFactory;\n    }\n\n    /**\n     * Resolve category view if applicable.\n     * <p>\n     * Rules:<p>\n     * 1. If there is no {@link WebParametersKeys#CATEGORY_ID} then this resolver is not applicable, return null<p>\n     * 2. If category has template then use template.<p>\n     * 3. If category search yields at least one product hit then use category product type search template\n     *    {@link org.yes.cart.domain.entity.ProductType#getUisearchtemplate()} or {@link CentralViewLabel#PRODUCTS_LIST}\n     *    if not search template is set<p>\n     * 4. If category has children use {@link CentralViewLabel#SUBCATEGORIES_LIST}<p>\n     * 5. Otherwise use {@link CentralViewLabel#CATEGORY}<p>\n     *\n     * @param parameters            request parameters map\n     *\n     * @return category view label or null (if not applicable)\n     */\n```\n\n### Code description\n```Java\n/**\n * Checks if the specified collection is empty.\n * A collection is considered empty if it is null or contains no elements.\n *\n * @param collection the collection to check, may be null\n * @return true if the collection is empty or null\n * @see org.apache.commons.collections.CollectionUtils#isEmpty(java.util.Collection)\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Pair<String, String> resolveMainPanelRendererLabel(final Map parameters) {\n\n    if (parameters.containsKey(WebParametersKeys.CATEGORY_ID)) {\n        final long categoryId = NumberUtils.toLong(HttpUtil.getSingleValue(parameters.get(WebParametersKeys.CATEGORY_ID)));\n        if (categoryId > 0L) {\n\n            final ShoppingCart cart = ApplicationDirector.getShoppingCart();\n            final long shopId = cart.getShoppingContext().getShopId();\n            final long browsingShopId = cart.getShoppingContext().getCustomerShopId();\n            final String lang = cart.getCurrentLocale();\n\n            // If we have template just use it without any checks (saves us 1 FT query for each request)\n            final String template = shopService.getShopCategoryTemplate(browsingShopId, categoryId);\n            if (StringUtils.isNotBlank(template)) {\n                if (CentralViewLabel.PRODUCTS_LIST.equals(template)) {\n                    return DEFAULT_PL;\n                } else if (CentralViewLabel.SUBCATEGORIES_LIST.equals(template)) {\n                    return DEFAULT_SC;\n                }\n                return new Pair<>(template, CentralViewLabel.CATEGORY);\n            }\n\n            final Pair<List<Long>, Boolean> catIds = determineSearchCategories(categoryId, browsingShopId);\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "resolveMainPanelRendererLabel", "reference": "\n            if (CollectionUtils.isEmpty(catIds.getFirst())) {\n                return DEFAULT; // Must never be empty, as we should have at least current category\n            }\n\n            // shopId will be used for inStock check, because we have category IDs will always look in those\n            final NavigationContext hasProducts = searchQueryFactory.getFilteredNavigationQueryChain(shopId, browsingShopId, lang, catIds.getFirst(), catIds.getSecond(), null);\n\n            if (productService.getProductQty(hasProducts) > 0) {\n\n                final String searchTemplate = shopService.getShopCategorySearchTemplate(browsingShopId, categoryId);\n                if (StringUtils.isNotBlank(searchTemplate)) {\n                    return new Pair<>(searchTemplate, CentralViewLabel.PRODUCTS_LIST);\n                }\n\n                return DEFAULT_PL;\n            } else if (categoryService.isCategoryHasChildren(categoryId)) {\n                return DEFAULT_SC;\n            } else {\n                return DEFAULT;\n            }\n        }\n    }\n\n    return null;\n}", "completions": ["```Java\n/**\n * Checks if the specified collection is empty.\n * A collection is considered empty if it is null or contains no elements.\n *\n * @param collection the collection to check, may be null\n * @return true if the collection is empty or null\n * @see org.apache.commons.collections.CollectionUtils#isEmpty(java.util.Collection)\n */\n```\n"]}
{"id": 44, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jclouds.compute.extensions.internal;\n\nimport java.util.Map;\n\nimport javax.annotation.Resource;\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.jclouds.compute.config.ComputeServiceAdapterContextModule.AddDefaultCredentialsToImage;\nimport org.jclouds.compute.domain.CloneImageTemplate;\nimport org.jclouds.compute.domain.Image;\nimport org.jclouds.compute.domain.ImageBuilder;\nimport org.jclouds.compute.domain.ImageTemplate;\nimport org.jclouds.compute.extensions.ImageExtension;\nimport org.jclouds.compute.reference.ComputeServiceConstants;\nimport org.jclouds.compute.suppliers.ImageCacheSupplier;\nimport org.jclouds.domain.Credentials;\nimport org.jclouds.domain.LoginCredentials;\nimport org.jclouds.logging.Logger;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.util.concurrent.FutureCallback;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.inject.assistedinject.Assisted;\n\n/**\n * Delegates to the provider specific {@link ImageExtension} and takes care of\n * propagating the changes made to the images to the image cache.\n */\n@Beta\npublic class DelegatingImageExtension implements ImageExtension {\n\n   public interface Factory {\n      DelegatingImageExtension create(ImageCacheSupplier imageCache, ImageExtension delegate);\n   }\n\n   @Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected Logger logger = Logger.NULL;\n\n   private final ImageCacheSupplier imageCache;\n   private final ImageExtension delegate;\n   private final AddDefaultCredentialsToImage addDefaultCredentialsToImage;\n   private final Map<String, Credentials> credentialStore;\n\n   @Inject\n   DelegatingImageExtension(@Assisted ImageCacheSupplier imageCache, @Assisted ImageExtension delegate,\n         AddDefaultCredentialsToImage addDefaultCredentialsToImage, Map<String, Credentials> credentialStore) {\n      this.imageCache = imageCache;\n      this.delegate = delegate;\n      this.addDefaultCredentialsToImage = addDefaultCredentialsToImage;\n      this.credentialStore = credentialStore;\n   }\n\n   public ImageTemplate buildImageTemplateFromNode(String name, String id) {\n      return delegate.buildImageTemplateFromNode(name, id);\n   }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method creates an image based on the provided template and populates the default image credentials if missing.\n * It also adds a callback to the future to register the image in the cache upon successful creation.\n *\n * @param template The template used to create the image.\n * @return A ListenableFuture that will be completed with the created image.\n */\n```\n\n### Code snippet:\n```Java\npublic ListenableFuture<Image> createImage(final ImageTemplate template) {\n   ListenableFuture<Image> future = delegate.createImage(template);\n\n   // Populate the default image credentials, if missing\n   future = Futures.transform(future, new Function<Image, Image>() {\n      @Override\n      public Image apply(Image input) {\n         if (input.getDefaultCredentials() != null) {\n            return input;\n         }\n\n         // If the image has been created by cloning a node, then try to\n         // populate the known node credentials as the default image\n         // credentials\n         if (template instanceof CloneImageTemplate) {\n            final CloneImageTemplate cloneImageTemplate = (CloneImageTemplate) template;\n\n            Credentials nodeCredentials = credentialStore.get(\"node#\" + cloneImageTemplate.getSourceNodeId());\n            if (nodeCredentials != null) {\n               logger.info(\">> Adding node(%s) credentials to image(%s)...\", cloneImageTemplate.getSourceNodeId(),\n                     cloneImageTemplate.getName());\n               return ImageBuilder.fromImage(input)\n                     .defaultCredentials(LoginCredentials.fromCredentials(nodeCredentials)).build();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "createImage", "reference": "            }\n         }\n\n         // If no credentials are known for the node, populate the default\n         // credentials using the defined strategy\n         logger.info(\">> Adding default image credentials to image(%s)...\", template.getName());\n         return addDefaultCredentialsToImage.apply(input);\n      }\n   });\n\n   Futures.addCallback(future, new FutureCallback<Image>() {\n      @Override\n      public void onSuccess(Image result) {\n         imageCache.registerImage(result);\n      }\n\n      @Override\n      public void onFailure(Throwable t) {\n\n      }\n   });\n   return future;\n}", "completions": ["```Java\n```Java\n   }\n\n   return input;\n}\n```\n"]}
{"id": 45, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2009 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.css.compiler.passes;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.css.compiler.ast.CssCompilerPass;\nimport com.google.common.css.compiler.ast.CssCompositeValueNode;\nimport com.google.common.css.compiler.ast.CssConstantReferenceNode;\nimport com.google.common.css.compiler.ast.CssDeclarationNode;\nimport com.google.common.css.compiler.ast.CssFunctionArgumentsNode;\nimport com.google.common.css.compiler.ast.CssFunctionNode;\nimport com.google.common.css.compiler.ast.CssHexColorNode;\nimport com.google.common.css.compiler.ast.CssLiteralNode;\nimport com.google.common.css.compiler.ast.CssNode;\nimport com.google.common.css.compiler.ast.CssNumericNode;\nimport com.google.common.css.compiler.ast.CssPriorityNode;\nimport com.google.common.css.compiler.ast.CssPropertyNode;\nimport com.google.common.css.compiler.ast.CssPropertyValueNode;\nimport com.google.common.css.compiler.ast.CssValueNode;\nimport com.google.common.css.compiler.ast.DefaultTreeVisitor;\nimport com.google.common.css.compiler.ast.MutatingVisitController;\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\n/**\n * Compiler pass that BiDi flips all the flippable nodes.\n * TODO(user): Need to add a function to return tree before flipping.\n *\n * @author roozbeh@google.com (Roozbeh Pournader)\n */\npublic class BiDiFlipper extends DefaultTreeVisitor implements CssCompilerPass {\n\n  private static final DecimalFormat PERCENT_FORMATTER =\n      new DecimalFormat(\"#.########\", DecimalFormatSymbols.getInstance(Locale.US));\n  private final MutatingVisitController visitController;\n\n  private final boolean shouldSwapLeftRightInUrl;\n  private final boolean shouldSwapLtrRtlInUrl;\n  private final boolean shouldFlipConstantReferences;\n\n  public BiDiFlipper(MutatingVisitController visitController,\n      boolean swapLtrRtlInUrl,\n      boolean swapLeftRightInUrl,\n      boolean shouldFlipConstantReferences) {\n    this.visitController = visitController;\n    this.shouldSwapLtrRtlInUrl = swapLtrRtlInUrl;\n    this.shouldSwapLeftRightInUrl = swapLeftRightInUrl;\n    this.shouldFlipConstantReferences = shouldFlipConstantReferences;\n  }\n\n  public BiDiFlipper(MutatingVisitController visitController,\n      boolean swapLtrRtlInUrl,\n      boolean swapLeftRightInUrl) {\n    this(visitController,\n        swapLtrRtlInUrl,\n        swapLeftRightInUrl,\n        false /* Don't flip constant reference by default. */);\n  }\n\n  /**\n   * Map with exact strings to match and their corresponding flipped value. For example, in \"float:\n   * left\" we need an exact match to flip \"left\" because we don't want to touch things like\n   * \"background: left.png\".\n   */\n  private static final ImmutableMap<String, String> EXACT_MATCHING_FOR_FLIPPING =\n      new ImmutableMap.Builder<String, String>()\n          .put(\"ltr\", \"rtl\")\n          .put(\"rtl\", \"ltr\")\n          .put(\"left\", \"right\")\n          .put(\"right\", \"left\")\n          .put(\"e-resize\", \"w-resize\")\n          .put(\"w-resize\", \"e-resize\")\n          .put(\"ne-resize\", \"nw-resize\")\n          .put(\"nw-resize\", \"ne-resize\")\n          .put(\"nesw-resize\", \"nwse-resize\")\n          .put(\"nwse-resize\", \"nesw-resize\")\n          .put(\"se-resize\", \"sw-resize\")\n          .put(\"sw-resize\", \"se-resize\")\n          .build();\n\n  /**\n   * Map with the \"ends-with\" substrings that can be flipped and their corresponding flipped value.\n   * For example, for\n   *\n   * <p>padding-right: 2px\n   *\n   * <p>we need to match that the property name ends with \"-right\".\n   */\n  private static final ImmutableMap<String, String> ENDS_WITH_MATCHING_FOR_FLIPPING =\n      new ImmutableMap.Builder<String, String>()\n          .put(\"-left\", \"-right\")\n          .put(\"-right\", \"-left\")\n          .put(\"-bottomleft\", \"-bottomright\")\n          .put(\"-topleft\", \"-topright\")\n          .put(\"-bottomright\", \"-bottomleft\")\n          .put(\"-topright\", \"-topleft\")\n          .build();\n\n  /**\n   * Map with the \"contains\" substrings that can be flipped and their corresponding flipped value.\n   * For example, for\n   *\n   * <p>border-right-width: 2px\n   *\n   * <p>we need to match that the property name contains \"-right-\".\n   */\n  private static final ImmutableMap<String, String> CONTAINS_MATCHING_FOR_FLIPPING =\n      new ImmutableMap.Builder<String, String>()\n          .put(\"-left-\", \"-right-\")\n          .put(\"-right-\", \"-left-\")\n          .build();\n\n  /** Set of properties that have flippable percentage values. */\n  private static final ImmutableSet<String> PROPERTIES_WITH_FLIPPABLE_PERCENTAGE =\n      ImmutableSet.of(\n          \"background\",\n          \"background-position\",\n          \"background-position-x\",\n          \"-ms-background-position-x\");\n\n  /*\n   * Set of properties that are equivalent to border-radius.\n   * TODO(roozbeh): Replace the explicit listing of prefixes with a general\n   * pattern of \"-[a-z]+-\" to avoid maintaining a prefix list.\n   */\n  public static final ImmutableSet<String> BORDER_RADIUS_PROPERTIES =\n      ImmutableSet.of(\n          \"border-radius\",\n          \"-webkit-border-radius\",\n          \"-moz-border-radius\");\n\n  /** Set of properties whose property values may flip if they match the four-part pattern. */\n  public static final ImmutableSet<String> FOUR_PART_PROPERTIES_THAT_SHOULD_FLIP =\n      ImmutableSet.of(\"border-color\", \"border-style\", \"border-width\", \"margin\", \"padding\");\n\n  /**\n   * Map with the patterns to match URLs against if swap_ltr_rtl_in_url flag is true, and their\n   * replacement string. Only the first occurrence of the pattern is flipped. This would match \"ltr\"\n   * and \"rtl\" if they occur as a word inside the path specified by the url. For example, for\n   *\n   * <p>background: url(/foo/rtl/bkg.gif)\n   *\n   * <p>the flipped value would be\n   *\n   * <p>background: url(/foo/ltr/bkg.gif)\n   *\n   * <p>whereas for\n   *\n   * <p>background: url(/foo/bkg-ltr.gif)\n   *\n   * <p>the flipped value would be\n   *\n   * <p>background: url(/foo/bkg-rtl.gif)\n   *\n   * <p>\n   */\n  private static final ImmutableMap<Pattern, String> URL_LTRTL_PATTERN_FOR_FLIPPING =\n      new ImmutableMap.Builder<Pattern, String>()\n          .put(Pattern.compile(\"(?<![a-zA-Z])([-_\\\\./]*)ltr([-_\\\\./]+)\"), \"$1rtl$2\")\n          .put(Pattern.compile(\"(?<![a-zA-Z])([-_\\\\./]*)rtl([-_\\\\./]+)\"), \"$1ltr$2\")\n          .build();\n\n  /**\n   * Map with the patterns to match URLs against if swap_left_right_in_url flag is true, and their\n   * replacement string. Only the first occurrence of the pattern is flipped. This would match\n   * \"left\" and \"right\" if they occur as a word inside the path specified by the url. For example,\n   * for\n   *\n   * <p>background: url(/foo/right/bkg.gif)\n   *\n   * <p>the flipped value would be\n   *\n   * <p>background: url(/foo/left/bkg.gif)\n   *\n   * <p>whereas for\n   *\n   * <p>background: url(/foo/bkg-left.gif)\n   *\n   * <p>the flipped value would be\n   *\n   * <p>background: url(/foo/bkg-right.gif)\n   *\n   * <p>\n   */\n  private static final ImmutableMap<Pattern, String> URL_LEFTRIGHT_PATTERN_FOR_FLIPPING =\n      new ImmutableMap.Builder<Pattern, String>()\n          .put(Pattern.compile(\"(?<![a-zA-Z])([-_\\\\./]*)left([-_\\\\./]+)\"), \"$1right$2\")\n          .put(Pattern.compile(\"(?<![a-zA-Z])([-_\\\\./]*)right([-_\\\\./]+)\"), \"$1left$2\")\n          .build();\n\n  /** Return if the string is \"left\" or \"center\" or \"right\". */\n  private static boolean isLeftOrCenterOrRight(String value) {\n    return \"left\".equals(value)\n        || \"center\".equals(value)\n        || \"right\".equals(value);\n  }\n\n  /** Return if the node is a slash operator node. */\n  private static boolean isSlashNode(CssValueNode valueNode) {\n    if (valueNode instanceof CssCompositeValueNode) {\n      CssCompositeValueNode compositeNode = (CssCompositeValueNode) valueNode;\n      return\n          compositeNode.getOperator() == CssCompositeValueNode.Operator.SLASH;\n    }\n    return false;\n  }\n\n  /**\n   * Return if the node is ConstantReference and also flippable.\n   */\n  private boolean shouldFlipConstantReference(CssValueNode valueNode) {\n    if (!shouldFlipConstantReferences) {\n      return false;\n    }\n    if (!(valueNode instanceof CssConstantReferenceNode)) {\n      return false;\n    }\n    String ref = valueNode.getValue();\n    if (ref.startsWith(ResolveCustomFunctionNodesForChunks.DEF_PREFIX)) {\n      // Since gss function could generate multiple values, we can't do flip if\n      // there's gss function call in place, simply skip this case.\n      return false;\n    }\n    return true;\n  }\n\n  /** Return if the node is numeric and also has '%'. */\n  private static boolean isNumericAndHasPercentage(CssValueNode value) {\n    if (!(value instanceof CssNumericNode)) {\n      return false;\n    }\n    CssNumericNode numericNode = (CssNumericNode) value;\n    return \"%\".equals(numericNode.getUnit());\n  }\n\n  /**\n   * Returns if the percentage value of this node is flippable.\n   *\n   * <p>Assumes simpler CSS 2.1 use of background and background-position (multi-layer is not\n   * supported yet, neither is the extended CSS 3 syntax for positioning, like \"right 10% top 20%\").\n   * TODO(roozbeh): add support CSS 3 multi-layer backgrounds. TODO(roozbeh): add support for\n   * extended CSS 3 syntax for positioning.\n   */\n  private static boolean isValidForPercentageFlipping(\n      CssPropertyNode propertyNode, CssPropertyValueNode propertyValueNode, int valueIndex) {\n\n    String propertyName = propertyNode.getPropertyName();\n    if (PROPERTIES_WITH_FLIPPABLE_PERCENTAGE.contains(propertyName)) {\n      if (valueIndex == 0) {\n        return true; // If this is the first value, it's always flippable\n      }\n      if (\"background\".equals(propertyName)) {\n        // Make sure this is not the vertical position: Only flip if the\n        // previous value is not numeric or \"left\", \"center\", or \"right\".\n        CssValueNode previousValueNode =\n            propertyValueNode.getChildAt(valueIndex - 1);\n        if (!(previousValueNode instanceof CssNumericNode)\n            && !isLeftOrCenterOrRight(previousValueNode.getValue())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets the percentage to flipped value(100 - 'old value'), if the node is\n   * valid numeric node with percentage.\n   */\n  private CssValueNode flipPercentageValueNode(CssValueNode valueNode) {\n    if (!isNumericAndHasPercentage(valueNode)) {\n      return valueNode;\n    }\n\n    CssNumericNode numericNode = (CssNumericNode) valueNode;\n    String oldPercentageValue = numericNode.getNumericPart();\n    return new CssNumericNode(flipPercentageValue(oldPercentageValue), \"%\");\n  }\n\n  /**\n   * Returns a formatted string representing 100% - value. Neither the input nor the output contains\n   * a {@code %}.\n   */\n  public static String flipPercentageValue(String value) {\n    double newValue = 100 - Double.parseDouble(value);\n    return PERCENT_FORMATTER.format(newValue);\n  }\n\n  /**\n   * Flips corners of a border-radius property. Corners are reordered in the following way:\n   *\n   * <ul>\n   *   <li>0 1 is replaced with 1 0,\n   *   <li>0 1 2 is replaced with 1 0 1 2, and\n   *   <li>0 1 2 3 is replaced with 1 0 3 2.\n   * </ul>\n   *\n   * <p>Lists of other lengths are returned unchanged.\n   *\n   * @param valueNodes the list of values representing the corners of a border-radius property.\n   * @return a list of values with the corners flipped.\n   */\n  private static List<CssValueNode> flipCorners(List<CssValueNode> valueNodes) {\n    switch (valueNodes.size()) {\n      case 2:\n        {\n          List<CssValueNode> flipped = new ArrayList<>(2);\n          flipped.add(valueNodes.get(1));\n          flipped.add(valueNodes.get(0));\n          return flipped;\n        }\n      case 3:\n        {\n          List<CssValueNode> flipped = new ArrayList<>(4);\n          flipped.add(valueNodes.get(1));\n          flipped.add(valueNodes.get(0));\n          flipped.add(valueNodes.get(1).deepCopy());\n          flipped.add(valueNodes.get(2));\n          return flipped;\n        }\n      case 4:\n        {\n          List<CssValueNode> flipped = new ArrayList<>(4);\n          flipped.add(valueNodes.get(1));\n          flipped.add(valueNodes.get(0));\n          flipped.add(valueNodes.get(3));\n          flipped.add(valueNodes.get(2));\n          return flipped;\n        }\n      default:\n        return valueNodes;\n    }\n  }\n\n  /**\n   * Takes a list of property values that belong to a border-radius property and flips them. If\n   * there is a slash in the values, the data is divided around the slash. Then for each section,\n   * flipCorners is called.\n   */\n  private static List<CssValueNode> flipBorderRadius(List<CssValueNode> valueNodes) {\n\n    int count = 0;\n    int slashLocation = -1;\n    CssCompositeValueNode slashNode = null;\n    for (CssValueNode valueNode : valueNodes) {\n      if (isSlashNode(valueNode)) {\n        slashLocation = count;\n        slashNode = (CssCompositeValueNode) valueNode;\n        break;\n      }\n      ++count;\n    }\n\n    if (slashLocation == -1) { // No slash found, just one set of values\n      return flipCorners(valueNodes);\n    }\n\n    // The parser treats slashes as combinging the two values around the slash\n    // into one composite value node. This is not really the correct semantics\n    // for the border-radius properties, as the parser will treat\n    // \"border-radius: 1px 2px / 5px 6px\" as having three value nodes: the first\n    // one will be \"1px\", the second one the composite value \"2px / 5px\",\n    // and the third one \"6px\". We work in this unfortunate parser model here,\n    // first deconstructing and later reconstructing that tree.\n\n    List<CssValueNode> slashNodeValues = slashNode.getValues();\n\n    // Create a list of horizontal values and flip them\n    List<CssValueNode> horizontalValues = new ArrayList<>();\n    horizontalValues.addAll(valueNodes.subList(0, slashLocation));\n    horizontalValues.add(slashNodeValues.get(0));\n    List<CssValueNode> newHorizontalValues = flipCorners(horizontalValues);\n\n    // Do the same for vertical values\n    List<CssValueNode> verticalValues = new ArrayList<>();\n    verticalValues.add(slashNodeValues.get(1));\n    verticalValues.addAll(valueNodes.subList(slashLocation + 1,\n        valueNodes.size()));\n    List<CssValueNode> newVerticalValues = flipCorners(verticalValues);\n\n    // Create a new slash node\n    List<CssValueNode> newSlashNodeValues = new ArrayList<>();\n    newSlashNodeValues.add(newHorizontalValues.get(\n        newHorizontalValues.size() - 1));\n    newSlashNodeValues.add(newVerticalValues.get(0));\n    CssCompositeValueNode newSlashNode = new CssCompositeValueNode(\n      newSlashNodeValues,\n      CssCompositeValueNode.Operator.SLASH,\n      null\n    );\n\n    List<CssValueNode> newValueList = new ArrayList<>();\n    newValueList.addAll(newHorizontalValues.subList(0,\n        newHorizontalValues.size() - 1));\n    newValueList.add(newSlashNode);\n    newValueList.addAll(newVerticalValues.subList(1, newVerticalValues.size()));\n\n    return newValueList;\n  }\n\n  /**\n   * Takes the list of property values, validate them, then swap the second and last values. So that\n   * 0 1 2 3 becomes 0 3 2 1.\n   *\n   * <p>That is unless the length of the list is not four, it belongs to a property that shouldn't\n   * be flipped, or it's border-radius, where it will be specially handled.\n   *\n   * <p>TODO(roozbeh): Add explicit flipping for 'border-image*' and '*-shadow' properties.\n   */\n  private List<CssValueNode> flipNumericValues(List<CssValueNode> valueNodes, String propertyName) {\n\n    if (BORDER_RADIUS_PROPERTIES.contains(propertyName)) {\n      return flipBorderRadius(valueNodes);\n    } else if (valueNodes.size() != 4\n        || !FOUR_PART_PROPERTIES_THAT_SHOULD_FLIP.contains(propertyName)) {\n      return valueNodes;\n    }\n\n    int count = 0;\n    CssValueNode secondValueNode = null;\n    CssValueNode fourthValueNode = null;\n    for (CssValueNode valueNode : valueNodes) {\n      if ((valueNode instanceof CssNumericNode)\n          || (valueNode instanceof CssLiteralNode)\n          || (valueNode instanceof CssHexColorNode)\n          || shouldFlipConstantReference(valueNode)) {\n        switch (count) {\n          case 3:\n            fourthValueNode = valueNode.deepCopy();\n            break;\n          case 1:\n            secondValueNode = valueNode.deepCopy();\n            break;\n          default: // fall out\n        }\n      } else {\n        return valueNodes;\n      }\n      count++;\n    }\n\n    // Swap second and last in the new list.\n    count = 0;\n    List<CssValueNode> newValueList = new ArrayList<>();\n    for (CssValueNode valueNode : valueNodes) {\n      if (1 == count) {\n        newValueList.add(fourthValueNode);\n      } else if (3 == count) {\n        newValueList.add(secondValueNode);\n      } else {\n        newValueList.add(valueNode);\n      }\n      count++;\n    }\n    return newValueList;\n  }\n\n  /** Performs appropriate replacements needed for BiDi flipping a literal value. */\n  public static String flipLiteralValue(String value) {\n    if (EXACT_MATCHING_FOR_FLIPPING.containsKey(value)) {\n      value = EXACT_MATCHING_FOR_FLIPPING.get(value);\n    }\n    for (String s : ENDS_WITH_MATCHING_FOR_FLIPPING.keySet()) {\n      if (value.endsWith(s)) {\n        value = value.replace(s, ENDS_WITH_MATCHING_FOR_FLIPPING.get(s));\n        break;\n      }\n    }\n    for (String s : CONTAINS_MATCHING_FOR_FLIPPING.keySet()) {\n      if (value.contains(s)) {\n        value = value.replace(s, CONTAINS_MATCHING_FOR_FLIPPING.get(s));\n        break;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns flipped node after making appropriate replacements needed for BiDi flipping, if the\n   * node is either a LiteralNode or PropertyNode. Eg: PropertyNode 'padding-right' would become\n   * 'padding-left'.\n   *\n   * <p>Subclasses can override to provide custom flipping behavior.\n   */\n  protected <T extends CssValueNode> T flipNode(T tNode) {\n    if (tNode instanceof CssLiteralNode) {\n      CssLiteralNode literalNode = (CssLiteralNode) tNode;\n      String oldValue = literalNode.getValue();\n      if (null == oldValue) {\n        return tNode;\n      }\n      String flippedValue = flipLiteralValue(oldValue);\n      if (flippedValue.equals(oldValue)) {\n        return tNode;\n      }\n\n      // This is safe because of the instanceof check above.\n      @SuppressWarnings(\"unchecked\")\n      T flippedLiteralNode = (T) new CssLiteralNode(flippedValue);\n\n      return flippedLiteralNode;\n    } else if (tNode instanceof CssPropertyNode) {\n      CssPropertyNode propertyNode = (CssPropertyNode) tNode;\n      String oldValue = propertyNode.getPropertyName();\n      if (null == oldValue) {\n        return tNode;\n      }\n      String flippedValue = flipLiteralValue(oldValue);\n      if (flippedValue.equals(oldValue)) {\n        return tNode;\n      }\n\n      // This is safe because of the instanceof check above.\n      @SuppressWarnings(\"unchecked\")\n      T flippedPropertyNode = (T) new CssPropertyNode(flippedValue);\n\n      return flippedPropertyNode;\n    } else {\n      return tNode;\n    }\n   }\n\n  /**\n   * Performs appropriate replacements required for flipping url.\n   */\n  private String flipUrlValue(String value) {\n    if (null == value) {\n      return null;\n    }\n    if (shouldSwapLtrRtlInUrl) {\n      for (Pattern p : URL_LTRTL_PATTERN_FOR_FLIPPING.keySet()) {\n        if (p.matcher(value).find()) {\n          String s = URL_LTRTL_PATTERN_FOR_FLIPPING.get(p);\n          value =  p.matcher(value).replaceFirst(s);\n          break;\n        }\n      }\n    }\n    if (shouldSwapLeftRightInUrl) {\n      for (Pattern p : URL_LEFTRIGHT_PATTERN_FOR_FLIPPING.keySet()) {\n        if (p.matcher(value).find()) {\n          String s = URL_LEFTRIGHT_PATTERN_FOR_FLIPPING.get(p);\n          value = p.matcher(value).replaceFirst(s);\n          break;\n        }\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Return node with flipped url, if it is a 'CssFunctionNode' with\n   * function 'URL'.\n   */\n  private CssValueNode flipUrlNode(CssValueNode valueNode) {\n    if (!((valueNode instanceof CssFunctionNode)\n          && (\"url\".equals(((CssFunctionNode) valueNode).getFunctionName())))) {\n      return valueNode;\n    }\n\n    // Get the url to be flipped.\n    CssFunctionNode oldFunctionNode = (CssFunctionNode) valueNode;\n    CssFunctionArgumentsNode functionArguments = oldFunctionNode.getArguments();\n\n    // Asserting if url function has more than one argument, which\n    // is unusual.\n    Preconditions.checkArgument((1 == functionArguments.numChildren()),\n                                \"url function taking more than one argument\");\n\n    CssValueNode oldArgument = functionArguments.getChildAt(0);\n    String oldUrlValue = oldArgument.getValue();\n    // Get the flipped url.\n    String newUrlValue = flipUrlValue(oldUrlValue);\n\n    // Make a new FunctionNode out of flipped url argument.\n    CssValueNode newArgument = oldArgument.deepCopy();\n    newArgument.setValue(newUrlValue);\n    List<CssValueNode> newArgumentsList = new ArrayList<CssValueNode>();\n    newArgumentsList.add(newArgument);\n\n    CssFunctionNode newFunctionNode = oldFunctionNode.deepCopy();\n    newFunctionNode.setArguments(new CssFunctionArgumentsNode(newArgumentsList));\n    return newFunctionNode;\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method is responsible for entering a CSS declaration node and updating its property name and value.\n * If the node is set to non-flippable, it returns true. Otherwise, it creates a deep copy of the declaration node,\n * flips the property name and value, and replaces the current block child with the new declaration node.\n *\n * @param declarationNode The CSS declaration node to be entered.\n * @return True if the node is set to non-flippable, false otherwise.\n * @throws IllegalArgumentException If the property name or value is invalid for flipping.\n * @see com.google.common.collect.Iterables#getLast(Iterable)\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic boolean enterDeclaration(CssDeclarationNode declarationNode) {\n  // Return if node is set to non-flippable.\n  if (!declarationNode.getShouldBeFlipped()) {\n    return true;\n  }\n\n  // Update the property name in the declaration.\n  CssDeclarationNode newDeclarationNode = declarationNode.deepCopy();\n  CssPropertyNode propertyNode = declarationNode.getPropertyName();\n  newDeclarationNode.setPropertyName(flipNode(propertyNode));\n\n  // Update the property value.\n  CssPropertyValueNode propertyValueNode = declarationNode.getPropertyValue();\n  List<CssValueNode> valueNodes = new ArrayList<>();\n  int valueIndex = 0;\n  for (CssValueNode valueNode : propertyValueNode.childIterable()) {\n    // Flip URL argument, if it is a valid url function.\n    CssValueNode temp = flipUrlNode(valueNode);\n    // Flip node value, if it is a property node or literal node with value\n    // that required flipping.\n    temp = flipNode(temp);\n    // Flip node value, if it is numeric and has percentage that\n    // needs flipping.\n    if (isValidForPercentageFlipping(propertyNode, propertyValueNode,\n                                     valueIndex)) {\n      temp = flipPercentageValueNode(temp);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "enterDeclaration", "reference": "    }\n    valueNodes.add(temp.deepCopy());\n    valueIndex++;\n  }\n  if (valueNodes.size() != 0) {\n    CssValueNode priority = null;\n    // Remove possible !important priority node.\n    if (!valueNodes.isEmpty() && Iterables.getLast(valueNodes) instanceof CssPriorityNode) {\n      priority = Iterables.getLast(valueNodes);\n      valueNodes = valueNodes.subList(0, valueNodes.size() - 1);\n    }\n    List<CssValueNode> newValueList =\n        flipNumericValues(valueNodes, propertyNode.getPropertyName());\n    // Re-add priority node if we removed it earlier.\n    if (priority != null) {\n      newValueList.add(priority);\n    }\n    newDeclarationNode.setPropertyValue(new CssPropertyValueNode(newValueList));\n  } else {\n    newDeclarationNode.setPropertyValue(propertyValueNode.deepCopy());\n  }\n\n  List<CssNode> replacementList = new ArrayList<>();\n  replacementList.add(newDeclarationNode);\n  visitController.replaceCurrentBlockChildWith(replacementList, false);\n  return true;\n}", "completions": ["```markdown\n```java\n/**\n * Description: This method is responsible for entering a CSS declaration node and updating its property name and value.\n * If the node is set to non-flippable, it returns true. Otherwise, it creates a deep copy of the declaration node,\n * flips the property name and value, and replaces the current block child with the new declaration node.\n *\n * @param declarationNode The CSS declaration node to be entered.\n * @return True if the node is set to non-flippable, false otherwise.\n * @throws IllegalArgumentException If the property name or value is invalid for flipping.\n * @see com.google.common.collect.Iterables#getLast(Iterable)\n */\n@Override\npublic boolean enterDeclaration(CssDeclarationNode declarationNode) {\n  // Return if node is set to non-flippable.\n  if (!declarationNode.getShouldBeFlipped()) {\n    return true;\n  }\n\n  // Update the property name in the declaration.\n  CssDeclarationNode newDeclarationNode = declarationNode.deepCopy();\n  CssPropertyNode propertyNode = declarationNode.getPropertyName();\n  newDeclarationNode.setPropertyName(flipNode(propertyNode));\n\n  // Update the property value.\n  CssPropertyValueNode propertyValueNode = declarationNode.getPropertyValue();\n  List<CssValueNode> valueNodes = new ArrayList<>();\n  int valueIndex = 0;\n  for (CssValueNode valueNode : propertyValueNode.childIterable()) {\n    // Flip URL argument, if it is a valid url function.\n    CssValueNode temp = flipUrlNode(valueNode);\n    // Flip node value, if it is a property node or literal node with value\n    // that required flipping.\n    temp = flipNode(temp);\n    // Flip node value, if it is numeric and has percentage that\n    // needs flipping.\n    if (isValidForPercentageFlipping(propertyNode, propertyValueNode,\n                                     valueIndex)) {\n      temp = flipPercentageValueNode(temp);\n    }\n    // Flip node value, if it is a numeric value and has '%' that\n    // needs flipping.\n    if (isNumericAndHasPercentage(valueNode)) {\n      temp = flipPercentageValueNode(temp);\n    }\n    valueNodes.add(temp);\n    ++valueIndex;\n  }\n  newDeclarationNode.setPropertyValue(new CssPropertyValueNode(valueNodes));\n\n  // Replace the current block child with the new declaration node.\n  visitController.replaceChild(declarationNode, newDeclarationNode);\n\n  return false;\n}\n```\n```\n"]}
{"id": 46, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.github.ebnew.ki4so.web.action;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport com.alibaba.fastjson.JSON;\nimport com.github.ebnew.ki4so.core.app.App;\nimport com.github.ebnew.ki4so.core.authentication.Credential;\nimport com.github.ebnew.ki4so.core.service.Ki4soService;\nimport com.github.ebnew.ki4so.web.utils.WebConstants;\n\n/**\n * \u767b\u51faweb\u63a7\u5236\u5668\uff0c\u5904\u7406\u767b\u51fa\u7684\u8bf7\u6c42\u3002\n * @author burgess yang\n *\n */\n@Controller\npublic class LogoutAction {\n\n\t\n\t@Autowired\n\tprotected CredentialResolver credentialResolver;\n\t\n\t@Autowired\n\tprotected Ki4soService ki4soService;\n\t\n\tpublic void setKi4soService(Ki4soService ki4soService) {\n\t\tthis.ki4soService = ki4soService;\n\t}\n\n\t/**\n\t * \u8bbe\u7f6e\u7528\u6237\u51ed\u636e\u89e3\u6790\u5668\u3002\n\t * @param credentialResolver\n\t */\n\tpublic void setCredentialResolver(CredentialResolver credentialResolver) {\n\t\tthis.credentialResolver = credentialResolver;\n\t}\n\t\n\t/**\n\t * \u67e5\u8be2\u7528\u6237\u767b\u5f55\u7684\u6240\u6709\u5e94\u7528\u5217\u8868\u3002\u8f93\u51fa\u4e00\u4e2ajsonp\u683c\u5f0f\u7684javascript\u4ee3\u7801\uff0c\u8be5\u4ee3\u7801\u8868\u793a\u7684\u662f\u5f53\u524d\u7528\u6237\u767b\u5f55\u7684\u5e94\u7528\u5217\u8868\u3002\n\t * jsonp\u4e32\u7684\u683c\u5f0f\u5982\u4e0b\u6240\u793a\uff1a\n\t * fetchAppList({[{appId:1, appName:'\u7cfb\u7edf1', logoutUrl:'http://www.test.com/app1/logout.do'}, {appId:2, appName:'\u7cfb\u7edf2', logoutUrl:'http://www.test.com/app2/logout.do'}]});\n\t * @param request \u8bf7\u6c42\u5bf9\u8c61\u3002\n\t * @param response \u54cd\u5e94\u5bf9\u8c61\u3002\n\t * @return \u6a21\u578b\u548c\u89c6\u56fe\u5bf9\u8c61\u3002\n\t */\n```\n\n### Code description\n```Java\n/**\n * Description: This method handles the HTTP request for getting the list of applications.\n * It resolves the user's credentials from the request, retrieves the list of applications using the provided credentials,\n * converts the list to a JSON string, wraps it in a callback function name and sends it back in the response.\n *\n * @param request The HttpServletRequest object representing the HTTP request.\n * @param response The HttpServletResponse object representing the HTTP response.\n * @throws IOException If an input or output exception occurred.\n */\n```\n\n### Code snippet:\n```Java\n@RequestMapping(\"/getAppList\")\npublic void getAppList(HttpServletRequest request,\n\t\tHttpServletResponse response){\n\t//\u89e3\u6790\u7528\u6237\u51ed\u636e\u3002\n\tCredential credential = credentialResolver.resolveCredential(request);\n\t//\u5b9e\u73b0\u8f93\u51fa\u4e3ajson\u4e32\u3002\n\tList<App> list =  this.ki4soService.getAppList(credential);\n\tString json = JSON.toJSONString(list);\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(getCallbackName(\"fetchAppList\", request))\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getAppList", "reference": "\t.append(\"(\")\n\t.append(json)\n\t.append(\");\");\n\ttry {\n\t\tresponse.setContentType(\"application/x-javascript\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\tresponse.getWriter().println(sb.toString());\n\t} catch (IOException e) {\n\t}\n}", "completions": ["```Java\n}\n```\n"]}
{"id": 47, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.logging.log4j.core.async;\n\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.core.util.Loader;\nimport org.apache.logging.log4j.status.StatusLogger;\nimport org.apache.logging.log4j.util.PropertiesUtil;\n\n/**\n * Creates {@link AsyncQueueFullPolicy} instances based on user-specified system properties. The {@code AsyncQueueFullPolicy}\n * created by this factory is used in AsyncLogger, AsyncLoggerConfig and AsyncAppender\n * to control if events are logged in the current thread, the background thread, or discarded.\n * <p>\n * Property {@code \"log4j2.AsyncQueueFullPolicy\"} controls the routing behaviour. If this property is not specified or has\n * value {@code \"Default\"}, this factory creates {@link DefaultAsyncQueueFullPolicy} objects.\n * </p> <p>\n * If this property has value {@code \"Discard\"}, this factory creates {@link DiscardingAsyncQueueFullPolicy} objects.\n * By default, this router discards events of level {@code INFO}, {@code DEBUG} and {@code TRACE} if the queue is full.\n * This can be adjusted with property {@code \"log4j2.DiscardThreshold\"} (name of the level at which to start\n * discarding).\n * </p> <p>\n * For any other value, this\n * factory interprets the value as the fully qualified name of a class implementing the {@link AsyncQueueFullPolicy}\n * interface. The class must have a default constructor.\n * </p>\n *\n * @since 2.6\n */\npublic class AsyncQueueFullPolicyFactory {\n    static final String PROPERTY_NAME_ASYNC_EVENT_ROUTER = \"log4j2.AsyncQueueFullPolicy\";\n    static final String PROPERTY_VALUE_DEFAULT_ASYNC_EVENT_ROUTER = \"Default\";\n    static final String PROPERTY_VALUE_DISCARDING_ASYNC_EVENT_ROUTER = \"Discard\";\n    static final String PROPERTY_NAME_DISCARDING_THRESHOLD_LEVEL = \"log4j2.DiscardThreshold\";\n\n    private static final Logger LOGGER = StatusLogger.getLogger();\n\n    /**\n     * Creates and returns {@link AsyncQueueFullPolicy} instances based on user-specified system properties.\n     * <p>\n     * Property {@code \"log4j2.AsyncQueueFullPolicy\"} controls the routing behaviour. If this property is not specified or\n     * has value {@code \"Default\"}, this method returns {@link DefaultAsyncQueueFullPolicy} objects.\n     * </p> <p>\n     * If this property has value {@code \"Discard\"}, this method returns {@link DiscardingAsyncQueueFullPolicy} objects.\n     * </p> <p>\n     * For any other value, this method interprets the value as the fully qualified name of a class implementing the\n     * {@link AsyncQueueFullPolicy} interface. The class must have a default constructor.\n     * </p>\n     *\n     * @return a new AsyncQueueFullPolicy\n     */\n```\n\n### Code description\n```Java\n/**\n * Creates an instance of AsyncQueueFullPolicy based on the configuration specified in the properties file.\n * The configuration is read from the property named PROPERTY_NAME_ASYNC_EVENT_ROUTER.\n * If the property is not set or set to the value PROPERTY_VALUE_DEFAULT_ASYNC_EVENT_ROUTER,\n * a new instance of DefaultAsyncQueueFullPolicy is returned.\n * If the property is set to the value PROPERTY_VALUE_DISCARDING_ASYNC_EVENT_ROUTER,\n * a new instance of DiscardingAsyncQueueFullPolicy is returned.\n * If the property is set to any other value, a custom router is created using the createCustomRouter method.\n *\n * @return An instance of AsyncQueueFullPolicy based on the configuration.\n */\n```\n\n### Code snippet:\n```Java\npublic static AsyncQueueFullPolicy create() {\n    final String router = PropertiesUtil.getProperties().getStringProperty(PROPERTY_NAME_ASYNC_EVENT_ROUTER);\n    if (router == null || isRouterSelected(\n            router, DefaultAsyncQueueFullPolicy.class, PROPERTY_VALUE_DEFAULT_ASYNC_EVENT_ROUTER)) {\n        return new DefaultAsyncQueueFullPolicy();\n    }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "create", "reference": "    if (isRouterSelected(\n            router, DiscardingAsyncQueueFullPolicy.class, PROPERTY_VALUE_DISCARDING_ASYNC_EVENT_ROUTER)) {\n        return createDiscardingAsyncQueueFullPolicy();\n    }\n    return createCustomRouter(router);\n}", "completions": ["```Java\n```Java\n/**\n * Creates an instance of AsyncQueueFullPolicy based on the configuration specified in the properties file.\n * The configuration is read from the property named PROPERTY_NAME_ASYNC_EVENT_ROUTER.\n * If the property is not set or set to the value PROPERTY_VALUE_DEFAULT_ASYNC_EVENT_ROUTER,\n * a new instance of DefaultAsyncQueueFullPolicy is returned.\n * If the property is set to the value PROPERTY_VALUE_DISCARDING_ASYNC_EVENT_ROUTER,\n * a new instance of DiscardingAsyncQueueFullPolicy is returned.\n * If the property is set to any other value, a custom router is created using the createCustomRouter method.\n *\n * @return An instance of AsyncQueueFullPolicy based on the configuration.\n */\npublic static AsyncQueueFullPolicy create() {\n    final String router = PropertiesUtil.getProperties().getStringProperty(PROPERTY_NAME_ASYNC_EVENT_ROUTER);\n    if (router == null || isRouterSelected(\n            router, DefaultAsyncQueueFullPolicy.class, PROPERTY_VALUE_DEFAULT_ASYNC_EVENT_ROUTER)) {\n        return new DefaultAsyncQueueFullPolicy();\n    } else if (isRouterSelected(\n            router, DiscardingAsyncQueueFullPolicy.class, PROPERTY_VALUE_DISCARDING_ASYNC_EVENT_ROUTER)) {\n        return new DiscardingAsyncQueueFullPolicy();\n    } else {\n        return createCustomRouter();\n    }\n}\n```\n```\n"]}
{"id": 48, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.spi.security.authentication;\n\nimport java.io.IOException;\nimport java.security.Principal;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.jcr.Credentials;\nimport javax.jcr.NoSuchWorkspaceException;\nimport javax.security.auth.DestroyFailedException;\nimport javax.security.auth.Destroyable;\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.login.LoginException;\nimport javax.security.auth.spi.LoginModule;\n\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.ImmutableSet;\nimport org.apache.jackrabbit.api.security.user.UserManager;\nimport org.apache.jackrabbit.oak.api.AuthInfo;\nimport org.apache.jackrabbit.oak.api.ContentRepository;\nimport org.apache.jackrabbit.oak.api.ContentSession;\nimport org.apache.jackrabbit.oak.api.Root;\nimport org.apache.jackrabbit.oak.namepath.NamePathMapper;\nimport org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\nimport org.apache.jackrabbit.oak.spi.security.SecurityProvider;\nimport org.apache.jackrabbit.oak.spi.security.authentication.callback.CredentialsCallback;\nimport org.apache.jackrabbit.oak.spi.security.authentication.callback.PrincipalProviderCallback;\nimport org.apache.jackrabbit.oak.spi.security.authentication.callback.RepositoryCallback;\nimport org.apache.jackrabbit.oak.spi.security.authentication.callback.UserManagerCallback;\nimport org.apache.jackrabbit.oak.spi.security.authentication.callback.WhiteboardCallback;\nimport org.apache.jackrabbit.oak.spi.security.principal.PrincipalConfiguration;\nimport org.apache.jackrabbit.oak.spi.security.principal.PrincipalProvider;\nimport org.apache.jackrabbit.oak.spi.security.user.UserConfiguration;\nimport org.apache.jackrabbit.oak.spi.whiteboard.Whiteboard;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Abstract implementation of the {@link LoginModule} interface that can act\n * as base class for login modules that aim to authenticate subjects against\n * information stored in the content repository.\n * <p>\n * <h2>LoginModule Methods</h2>\n * This base class provides a simple implementation for the following methods\n * of the {@code LoginModule} interface:\n * <p>\n * <ul>\n * <li>{@link LoginModule#initialize(Subject, CallbackHandler, Map, Map) Initialize}:\n * Initialization of this abstract module sets the following protected instance\n * fields:\n * <ul>\n * <li>subject: The subject to be authenticated,</li>\n * <li>callbackHandler: The callback handler passed to the login module,</li>\n * <li>shareState: The map used to share state information with other login modules,</li>\n * <li>options: The configuration options of this login module as specified\n * in the {@link javax.security.auth.login.Configuration}.</li>\n * </ul>\n * </li>\n * <li>{@link LoginModule#logout() Logout}:\n * If the authenticated subject is not empty this logout implementation\n * attempts to clear both principals and public credentials and returns\n * {@code true}.</li>\n * <li>{@link LoginModule#abort() Abort}: Clears the state of this login\n * module by setting all private instance variables created in phase 1 or 2\n * to {@code null}. Subclasses are in charge of releasing their own state\n * information by either overriding {@link #clearState()}.</li>\n * </ul>\n * <p>\n * <h2>Utility Methods</h2>\n * The following methods are provided in addition:\n * <p>\n * <ul>\n * <li>{@link #clearState()}: Clears all private state information that has\n * be created during login. This method in called in {@link #abort()} and\n * subclasses are expected to override this method.</li>\n * <li>{@link #getSupportedCredentials()}: Abstract method used by\n * {@link #getCredentials()} that reveals which credential implementations\n * are supported by the {@code LoginModule}.</li>\n * <li>{@link #getCredentials()}: Tries to retrieve valid (supported)\n * Credentials in the following order:\n * <ol>\n * <li>using a {@link CredentialsCallback},</li>\n * <li>looking for a {@link #SHARED_KEY_CREDENTIALS} entry in the shared\n * state (see also {@link #getSharedCredentials()} and finally by</li>\n * <li>searching for valid credentials in the subject.</li>\n * </ol></li>\n * <li>{@link #getSharedCredentials()}: This method returns credentials\n * passed to the login module with the share state. The key to share credentials\n * with a another module extending from this base class is\n * {@link #SHARED_KEY_CREDENTIALS}. Note, that this method does not verify\n * if the credentials provided by the shared state are\n * {@link #getSupportedCredentials() supported}.</li>\n * <li>{@link #getSharedLoginName()}: If the shared state contains an entry\n * for {@link #SHARED_KEY_LOGIN_NAME} this method returns the value as login name.</li>\n * <li>{@link #getSecurityProvider()}: Returns the configured security\n * provider or {@code null}.</li>\n * <li>{@link #getRoot()}: Provides access to the latest state of the\n * repository in order to retrieve user or principal information required to\n * authenticate the subject as well as to write back information during\n * {@link #commit()}.</li>\n * <li>{@link #getUserManager()}: Returns an instance of the configured\n * {@link UserManager} or {@code null}.</li>\n * <li>{@link #getPrincipalProvider()}: Returns an instance of the configured\n * principal provider or {@code null}.</li>\n * <li>{@link #getPrincipals(String)}: Utility that returns all principals\n * associated with a given user id. This method might be be called after\n * successful authentication in order to be able to populate the subject\n * during {@link #commit()}. The implementation is a shortcut for calling\n * {@link PrincipalProvider#getPrincipals(String) getPrincipals(String userId}\n * on the provider exposed by {@link #getPrincipalProvider()}</li>\n * </ul>\n */\n@ProviderType\npublic abstract class AbstractLoginModule implements LoginModule {\n\n    /**\n     * logger instance\n     */\n    private static final Logger log = LoggerFactory.getLogger(AbstractLoginModule.class);\n\n    /**\n     * Key of the sharedState entry referring to validated Credentials that is\n     * shared between multiple login modules.\n     */\n    public static final String SHARED_KEY_CREDENTIALS = \"org.apache.jackrabbit.credentials\";\n\n    /**\n     * Key of the sharedState entry referring to a valid login ID that is shared\n     * between multiple login modules.\n     */\n    public static final String SHARED_KEY_LOGIN_NAME = \"javax.security.auth.login.name\";\n\n    /**\n     * Key of the sharedState entry referring to public attributes that are shared\n     * between multiple login modules.\n     */\n    public static final String SHARED_KEY_ATTRIBUTES = \"javax.security.auth.login.attributes\";\n\n    /**\n     * Key of the sharedState entry referring to pre authenticated login information that is shared\n     * between multiple login modules.\n     */\n    public static final String SHARED_KEY_PRE_AUTH_LOGIN = PreAuthenticatedLogin.class.getName();\n\n    protected Subject subject;\n    protected CallbackHandler callbackHandler;\n    protected Map sharedState;\n    protected ConfigurationParameters options;\n\n    private SecurityProvider securityProvider;\n    private LoginModuleMonitor loginModuleMonitor;\n    private Whiteboard whiteboard;\n\n    private ContentSession systemSession;\n    private Root root;\n\n    //--------------------------------------------------------< LoginModule >---\n    @Override\n    public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options) {\n        this.subject = subject;\n        this.callbackHandler = callbackHandler;\n        this.sharedState = sharedState;\n        this.options = (options == null) ? ConfigurationParameters.EMPTY : ConfigurationParameters.of(options);\n    }\n\n    /**\n     * Besteffort default implementation of {@link LoginModule#logout()}, which removes all principals and all public\n     * credentials of type {@link Credentials} and {@link AuthInfo} from the subject.\n     * It will return {@code false}, if either principal set or credentials set is empty.\n     *\n     * Note, that this implementation is not able to only remove those principals/credentials that have been added\n     * by {@code this} very login module instance. Therefore subclasses should overwrite this method to provide a fully\n     * compliant solution of {@link #logout()}. They may however take advantage of {@link #logout(Set, Set)}\n     * in order to simplify the implementation of a logout that is compatible with the {@link LoginModule#logout()}\n     * contract incorporating the additional recommendations highlighted at\n     * <a href=\"https://docs.oracle.com/en/java/javase/13/security/java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-E9C5810B-ADB6-4454-869D-B269ECA8145F__LOGINMODULE.LOGOUTMETHOD-21144F6A\">JAAS LoginModule Dev Guide</a>\n     *\n     * @return {@code true} if neither principals nor public credentials of type {@link Credentials} or {@link AuthInfo}\n     * stored in the {@link Subject} are empty; {@code false} otherwise\n     * @throws LoginException if the subject is readonly and destroying {@link Destroyable} credentials fails\n     * with {@link DestroyFailedException}.\n     */\n    @Override\n    public boolean logout() throws LoginException {\n        boolean success = false;\n        Set<Object> creds = ImmutableSet.builder()\n                .addAll(subject.getPublicCredentials(Credentials.class))\n                .addAll(subject.getPublicCredentials(AuthInfo.class)).build();\n        if (!subject.getPrincipals().isEmpty() && !creds.isEmpty()) {\n            // clear subject if not readonly\n            if (!subject.isReadOnly()) {\n                subject.getPrincipals().clear();\n                subject.getPublicCredentials().removeAll(creds);\n            } else {\n                destroyCredentials(creds);\n            }\n            success = true;\n        }\n        return success;\n    }\n\n    @Override\n    public boolean abort() throws LoginException {\n        clearState();\n        return true;\n    }\n\n    //--------------------------------------------------------------------------\n\n    /**\n     * Clear state information that has been created during {@link #login()}.\n     */\n    protected void clearState() {\n        securityProvider = null;\n        closeSystemSession();\n    }\n\n    /**\n     * Close the system session acquired upon {@link #getRoot()} and reset the associated root field.\n     * This method should be used instead of {@link #clearState()}, if {@link #login()} and {@link #commit()} were\n     * successfully completed but the system session is not needed for a successful {@link #logout()}\n     */\n    protected void closeSystemSession() {\n        if (systemSession != null) {\n            try {\n                systemSession.close();\n            } catch (IOException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n            systemSession = null;\n            root = null;\n        }\n    }\n\n    /**\n     * General logout-helper that will return {@code false} if both {@code credentials} and {@code principals} are {@code null}.\n     * Note, that this implementation will only throw {@code LoginException} if the {@code subject} is marked readonly\n     * and destroying {@link Destroyable} credentials fails.\n     *\n     * @param credentials The set of credentials extracted by this instance during login/commit to be removed from {@link Subject#getPublicCredentials()}\n     * @param principals A set of principals extracted by this instance during login/commit to be removed from {@link Subject#getPrincipals()}\n     * @return {@code true} if either the credential set or the principal set is not {@code null}, {@code false} otherwise.\n     * @throws LoginException If the subject is readonly and an error occurs while destroying any of the given credentials.\n     * @see <a href=\"https://docs.oracle.com/en/java/javase/13/security/java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-E9C5810B-ADB6-4454-869D-B269ECA8145F__LOGINMODULE.LOGOUTMETHOD-21144F6A\">JAASLMDevGuide</a>\n     */\n    protected boolean logout(@Nullable Set<Object> credentials, @Nullable Set<? extends Principal> principals) throws LoginException {\n        if (credentials != null || principals != null) {\n            if (!subject.isReadOnly()) {\n                if (credentials != null) {\n                    subject.getPublicCredentials().removeAll(credentials);\n                }\n                if (principals != null) {\n                    subject.getPrincipals().removeAll(principals);\n                }\n            } else if (credentials != null) {\n                destroyCredentials(credentials);\n            }\n            return true;\n        } else {\n            // this login module didn't add credentials/authinfo/principals to the subject upon commit\n            // -> logout of this LoginModule should be ignored\n            return false;\n        }\n    }\n\n    private static void destroyCredentials(@NotNull Iterable<Object> credentials) throws LoginException {\n        for (Object cred : credentials) {\n            if (cred instanceof Destroyable) {\n                try {\n                    ((Destroyable) cred).destroy();\n                } catch (DestroyFailedException e) {\n                    throw new LoginException(e.getMessage());\n                }\n            } else {\n                log.debug(\"Unable to destroy credentials ({}) of read-only subject.\", credentials.getClass().getName());\n            }\n        }\n    }\n\n    /**\n     * @return A set of supported credential classes.\n     */\n    @NotNull\n    protected abstract Set<Class> getSupportedCredentials();\n\n    /**\n     * Tries to retrieve valid (supported) Credentials:\n     * <ol>\n     * <li>using a {@link CredentialsCallback},</li>\n     * <li>looking for a {@link #SHARED_KEY_CREDENTIALS} entry in the\n     * shared state (see also {@link #getSharedCredentials()} and finally by</li>\n     * <li>searching for valid credentials in the subject.</li>\n     * </ol>\n     *\n     * @return Valid (supported) credentials or {@code null}.\n     */\n    @Nullable\n    protected Credentials getCredentials() {\n        Set<Class> supported = getSupportedCredentials();\n        if (callbackHandler != null) {\n            log.debug(\"Login: retrieving Credentials using callback.\");\n            try {\n                CredentialsCallback callback = new CredentialsCallback();\n                callbackHandler.handle(new Callback[]{callback});\n                Credentials creds = callback.getCredentials();\n                if (creds != null && supported.contains(creds.getClass())) {\n                    log.debug(\"Login: Credentials '{}' obtained from callback\", creds);\n                    return creds;\n                } else {\n                    log.debug(\"Login: No supported credentials obtained from callback; trying shared state.\");\n                }\n            } catch (UnsupportedCallbackException | IOException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        Credentials creds = getSharedCredentials();\n        if (creds != null && supported.contains(creds.getClass())) {\n            log.debug(\"Login: Credentials obtained from shared state.\");\n            return creds;\n        } else {\n            log.debug(\"Login: No supported credentials found in shared state; looking for credentials in subject.\");\n            for (Class clz : getSupportedCredentials()) {\n                Set<Credentials> cds = subject.getPublicCredentials(clz);\n                if (!cds.isEmpty()) {\n                    log.debug(\"Login: Credentials found in subject.\");\n                    return cds.iterator().next();\n                }\n            }\n        }\n\n        log.debug(\"No credentials found.\");\n        return null;\n    }\n\n    /**\n     * @return The credentials passed to this login module with the shared state.\n     * @see #SHARED_KEY_CREDENTIALS\n     */\n    @Nullable\n    protected Credentials getSharedCredentials() {\n        Credentials shared = null;\n        if (sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {\n            Object sc = sharedState.get(SHARED_KEY_CREDENTIALS);\n            if (sc instanceof Credentials) {\n                shared = (Credentials) sc;\n            } else {\n                log.debug(\"Login: Invalid value for share state entry {}. Credentials expected.\", SHARED_KEY_CREDENTIALS);\n            }\n        }\n\n        return shared;\n    }\n\n    /**\n     * @return The login name passed to this login module with the shared state.\n     * @see #SHARED_KEY_LOGIN_NAME\n     */\n    @Nullable\n    protected String getSharedLoginName() {\n        if (sharedState.containsKey(SHARED_KEY_LOGIN_NAME)) {\n            return sharedState.get(SHARED_KEY_LOGIN_NAME).toString();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @return The pre authenticated login or {@code null}\n     * @see #SHARED_KEY_PRE_AUTH_LOGIN\n     */\n    @Nullable\n    protected PreAuthenticatedLogin getSharedPreAuthLogin() {\n        Object login = sharedState.get(SHARED_KEY_PRE_AUTH_LOGIN);\n        if (login instanceof PreAuthenticatedLogin) {\n            return (PreAuthenticatedLogin) login;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Tries to obtain the {@code SecurityProvider} object from the callback\n     * handler using a new SecurityProviderCallback and keeps the value as\n     * private field. If the callback handler isn't able to handle the\n     * SecurityProviderCallback this method returns {@code null}.\n     *\n     * @return The {@code SecurityProvider} associated with this\n     *         {@code LoginModule} or {@code null}.\n     */\n    @Nullable\n    protected SecurityProvider getSecurityProvider() {\n        if (securityProvider == null && callbackHandler != null) {\n            RepositoryCallback rcb = new RepositoryCallback();\n            try {\n                callbackHandler.handle(new Callback[]{rcb});\n                securityProvider = rcb.getSecurityProvider();\n            } catch (IOException | UnsupportedCallbackException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n        return securityProvider;\n    }\n\n    /**\n     * Tries to obtain the {@code Whiteboard} object from the callback\n     * handler using a new WhiteboardCallback and keeps the value as\n     * private field. If the callback handler isn't able to handle the\n     * WhiteboardCallback this method returns {@code null}.\n     *\n     * @return The {@code Whiteboard} associated with this\n     *         {@code LoginModule} or {@code null}.\n     */\n    @Nullable\n    protected Whiteboard getWhiteboard() {\n        if (whiteboard == null && callbackHandler != null) {\n            WhiteboardCallback cb = new WhiteboardCallback();\n            try {\n                callbackHandler.handle(new Callback[]{cb});\n                whiteboard = cb.getWhiteboard();\n            } catch (IOException | UnsupportedCallbackException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n        return whiteboard;\n    }\n\n    /**\n     * Tries to obtain a {@code Root} object from the callback handler using\n     * a new RepositoryCallback and keeps the value as private field.\n     * If the callback handler isn't able to handle the RepositoryCallback\n     * this method returns {@code null}.\n     *\n     * @return The {@code Root} associated with this {@code LoginModule} or\n     *         {@code null}.\n     */\n    @Nullable\n    protected Root getRoot() {\n        if (root == null && callbackHandler != null) {\n            try {\n                final RepositoryCallback rcb = new RepositoryCallback();\n                callbackHandler.handle(new Callback[]{rcb});\n\n                final ContentRepository repository = rcb.getContentRepository();\n                if (repository != null) {\n                    systemSession = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<ContentSession>() {\n                        @Override\n                        public ContentSession run() throws LoginException, NoSuchWorkspaceException {\n                            return repository.login(null, rcb.getWorkspaceName());\n                        }\n                    });\n                    root = systemSession.getLatestRoot();\n                } else {\n                    log.error(\"Unable to retrieve the Root via RepositoryCallback; ContentRepository not available.\");\n                }\n            } catch (IOException | UnsupportedCallbackException | PrivilegedActionException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n        return root;\n    }\n\n    /**\n     * Retrieves the {@link UserManager} that should be used to handle\n     * this authentication. If no user manager has been configure this\n     * method returns {@code null}.\n     *\n     * @return A instance of {@code UserManager} or {@code null}.\n     */\n    @Nullable\n    protected UserManager getUserManager() {\n        UserManager userManager = null;\n        SecurityProvider sp = getSecurityProvider();\n        Root r = getRoot();\n        if (r != null && sp != null) {\n            UserConfiguration uc = sp.getConfiguration(UserConfiguration.class);\n            userManager = uc.getUserManager(r, NamePathMapper.DEFAULT);\n        }\n\n        if (userManager == null && callbackHandler != null) {\n            try {\n                UserManagerCallback userCallBack = new UserManagerCallback();\n                callbackHandler.handle(new Callback[]{userCallBack});\n                userManager = userCallBack.getUserManager();\n            } catch (IOException | UnsupportedCallbackException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        return userManager;\n    }\n\n    /**\n     * Retrieves the {@link PrincipalProvider} that should be used to handle\n     * this authentication. If no principal provider has been configure this\n     * method returns {@code null}.\n     *\n     * @return A instance of {@code PrincipalProvider} or {@code null}.\n     */\n    @Nullable\n    protected PrincipalProvider getPrincipalProvider() {\n        PrincipalProvider principalProvider = null;\n        SecurityProvider sp = getSecurityProvider();\n        Root r = getRoot();\n        if (r != null && sp != null) {\n            PrincipalConfiguration pc = sp.getConfiguration(PrincipalConfiguration.class);\n            principalProvider = pc.getPrincipalProvider(r, NamePathMapper.DEFAULT);\n        }\n\n        if (principalProvider == null && callbackHandler != null) {\n            try {\n                PrincipalProviderCallback principalCallBack = new PrincipalProviderCallback();\n                callbackHandler.handle(new Callback[]{principalCallBack});\n                principalProvider = principalCallBack.getPrincipalProvider();\n            } catch (IOException | UnsupportedCallbackException e) {\n                onError();\n                log.error(e.getMessage(), e);\n            }\n        }\n        return principalProvider;\n    }\n\n    /**\n     * Retrieves all principals associated with the specified {@code userId} for\n     * the configured principal provider.\n     *\n     * @param userId The id of the user.\n     * @return The set of principals associated with the given {@code userId}.\n     * @see #getPrincipalProvider()\n     */\n```\n\n### Code description\n```Java\n/**\n * Retrieves the set of principals associated with the given user ID.\n * If no principal provider is configured, it logs a debug message and returns an empty set.\n * Otherwise, it measures the time taken to retrieve the principals using a Stopwatch, logs the elapsed time and the number of principals retrieved, and returns the set of principals.\n *\n * @param userId The ID of the user for which to retrieve the principals.\n * @return A set of principals associated with the given user ID.\n * @throws NullPointerException if the userId is null.\n */\n```\n\n### Code snippet:\n```Java\n@NotNull\nprotected Set<? extends Principal> getPrincipals(@NotNull String userId) {\n    PrincipalProvider principalProvider = getPrincipalProvider();\n    if (principalProvider == null) {\n        log.debug(\"Cannot retrieve principals. No principal provider configured.\");\n        return Collections.emptySet();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getPrincipals", "reference": "    } else {\n        Stopwatch watch = Stopwatch.createStarted();\n        Set<? extends Principal> principals = principalProvider.getPrincipals(userId);\n        getLoginModuleMonitor().principalsCollected(watch.elapsed(NANOSECONDS), principals.size());\n        return principals;\n    }\n}", "completions": ["```Java\n```Java\nprotected Set<? extends Principal> getPrincipals(@NotNull String userId) {\n    PrincipalProvider principalProvider = getPrincipalProvider();\n    if (principalProvider == null) {\n        log.debug(\"Cannot retrieve principals. No principal provider configured.\");\n        return Collections.emptySet();\n    }\n\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    try {\n        Set<? extends Principal> principals = principalProvider.getPrincipals(userId);\n        stopwatch.stop();\n        log.debug(\"Retrieved {} principals for user {} in {} ms.\", principals.size(), userId, stopwatch.elapsed(NANOSECONDS));\n        return principals;\n    } catch (IOException | UnsupportedCallbackException e) {\n        onError();\n        log.error(e.getMessage(), e);\n        stopwatch.stop();\n        return Collections.emptySet();\n    }\n}\n```\n```\n"]}
{"id": 49, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2013 Netflix, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage feign.sax;\n\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Type;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport feign.Response;\nimport feign.Util;\nimport feign.codec.DecodeException;\nimport feign.codec.Decoder;\n\nimport static feign.Util.checkNotNull;\nimport static feign.Util.checkState;\nimport static feign.Util.ensureClosed;\nimport static feign.Util.resolveLastTypeParameter;\n\n/**\n * Decodes responses using SAX, which is supported both in normal JVM environments, as well Android.\n * <br> <h4>Basic example with with Feign.Builder</h4> <br>\n * <pre>\n * api = Feign.builder()\n *            .decoder(SAXDecoder.builder()\n *                               .registerContentHandler(ContentHandlerForFoo.class)\n *                               .registerContentHandler(ContentHandlerForBar.class)\n *                               .build())\n *            .target(MyApi.class, \"http://api\");\n * </pre>\n */\npublic class SAXDecoder implements Decoder {\n\n  private final Map<Type, ContentHandlerWithResult.Factory<?>> handlerFactories;\n\n  private SAXDecoder(Map<Type, ContentHandlerWithResult.Factory<?>> handlerFactories) {\n    this.handlerFactories = handlerFactories;\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method decodes a response from a server into an object of a specified type.\n * It uses the feign.Util.emptyValueOf method to create an empty value of the specified type.\n * If the response status is 404, it returns an empty value of the specified type.\n * If the response body is null, it returns null.\n * It then retrieves a ContentHandlerWithResult.Factory from a map of handlers based on the specified type.\n * It checks that the factory is not null and throws an IllegalStateException if it is.\n * It creates a ContentHandlerWithResult from the factory and uses it to parse the response body as XML.\n * It sets various XMLReader features to prevent XXE attacks.\n * It sets the ContentHandler of the XMLReader to the handler and parses the response body.\n * It finally returns the result of the handler.\n * If a SAXException occurs, it throws a DecodeException.\n *\n * @param response The response from the server to be decoded.\n * @param type The type of the object to be created from the response.\n * @return The decoded object of the specified type.\n * @throws IOException If an I/O error occurs.\n * @throws DecodeException If a DecodeException occurs.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Object decode(Response response, Type type) throws IOException, DecodeException {\n  if (response.status() == 404) return Util.emptyValueOf(type);\n  if (response.body() == null) return null;\n  ContentHandlerWithResult.Factory<?> handlerFactory = handlerFactories.get(type);\n  checkState(handlerFactory != null, \"type %s not in configured handlers %s\", type,\n             handlerFactories.keySet());\n  ContentHandlerWithResult<?> handler = handlerFactory.create();\n  try {\n    XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/validation\", false);\n    /* Explicitly control sax configuration to prevent XXE attacks */\n    xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "decode", "reference": "    xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n    xmlReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n    xmlReader.setContentHandler(handler);\n    InputStream inputStream = response.body().asInputStream();\n    try {\n      xmlReader.parse(new InputSource(inputStream));\n    } finally {\n      ensureClosed(inputStream);\n    }\n    return handler.result();\n  } catch (SAXException e) {\n    throw new DecodeException(e.getMessage(), e);\n  }\n}", "completions": ["```Java\n```java\n    xmlReader.setFeature(\"http://xml.org/sax/features/string-interning\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces-public\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces-prefix-mismatch\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/validation\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/cdata-sections\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/character-data-declaration\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/dtd-validation\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/external-dtd-entities\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces-mapping\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/rng-handler\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-version\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xinclude-support\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xinclude-validation\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xlink-support\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xpath-support\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-base\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.0-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.0-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.1-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.1-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.2-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.2-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.3-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.3-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.4-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.4-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.5-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.5-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.6-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.6-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.7-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.7-ext\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.8-basic\", false);\n    xmlReader.setFeature(\"http://xml.org/sax/features/xml-1.8-ext"]}
{"id": 50, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.ovirt.engine.core.dao.network;\n\nimport static org.ovirt.engine.core.dao.network.HostNetworkQosDaoImpl.HostNetworkQosDaoDbFacadaeImplMapper.MAPPER;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang.Validate;\nimport org.ovirt.engine.core.common.businessentities.network.AnonymousHostNetworkQos;\nimport org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration;\nimport org.ovirt.engine.core.common.businessentities.network.HostNetworkQos;\nimport org.ovirt.engine.core.common.businessentities.network.IPv4Address;\nimport org.ovirt.engine.core.common.businessentities.network.IpConfiguration;\nimport org.ovirt.engine.core.common.businessentities.network.IpV6Address;\nimport org.ovirt.engine.core.common.businessentities.network.Ipv4BootProtocol;\nimport org.ovirt.engine.core.common.businessentities.network.Ipv6BootProtocol;\nimport org.ovirt.engine.core.common.businessentities.network.NetworkAttachment;\nimport org.ovirt.engine.core.common.utils.EnumUtils;\nimport org.ovirt.engine.core.compat.Guid;\nimport org.ovirt.engine.core.dao.DefaultGenericDao;\nimport org.ovirt.engine.core.utils.SerializationFactory;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n\n@Named\n@Singleton\npublic class NetworkAttachmentDaoImpl extends DefaultGenericDao<NetworkAttachment, Guid> implements NetworkAttachmentDao {\n\n    @Inject\n    private HostNetworkQosDao hostNetworkQosDao;\n\n    @Inject\n    private DnsResolverConfigurationDao dnsResolverConfigurationDao;\n\n\n    private final RowMapper<HostNetworkQos> qosDaoRetriever = (rs, rowNum) -> hostNetworkQosDao.get(getGuid(rs, \"id\"));\n    private final RowMapper<DnsResolverConfiguration> dnsDaoRetriever = (rs, rowNum) ->\n            dnsResolverConfigurationDao.get(getGuid(rs, \"dns_resolver_configuration_id\")\n    );\n    private final NetworkAttachmentRowMapper qosDaoAttachmentMapper = new NetworkAttachmentRowMapper(\n            qosDaoRetriever, dnsDaoRetriever\n    );\n\n    private final RowMapper<HostNetworkQos> qosResultSetMapper = (rs, rowNum) -> {\n        HostNetworkQos qos = null;\n        if (getGuid(rs, \"qos_id\") != null) {\n            qos = MAPPER.createQosEntity(rs);\n            qos.setId(getGuid(rs, \"id\"));\n        }\n        return qos;\n    };\n\n    private final NetworkAttachmentRowMapper attachmentWithQosMapper = new NetworkAttachmentRowMapper(\n            qosResultSetMapper, dnsDaoRetriever\n    );\n\n    private static final class NetworkAttachmentRowMapper  implements RowMapper<NetworkAttachment>  {\n\n        private final RowMapper<HostNetworkQos> hostNetworkQosMapper;\n        private final RowMapper<DnsResolverConfiguration> dnsMapper;\n\n        NetworkAttachmentRowMapper(RowMapper<HostNetworkQos> qosMapper, RowMapper<DnsResolverConfiguration> dnsMapper) {\n            this.hostNetworkQosMapper = qosMapper;\n            this.dnsMapper = dnsMapper;\n        }\n\n        @Override\n        public NetworkAttachment mapRow(ResultSet rs, int rowNum) throws SQLException {\n            NetworkAttachment entity = new NetworkAttachment();\n            entity.setId(getGuid(rs, \"id\"));\n            entity.setNetworkId(getGuid(rs, \"network_id\"));\n            entity.setNicId(getGuid(rs, \"nic_id\"));\n            entity.setProperties(getCustomProperties(rs));\n\n            final IpConfiguration ipConfiguration = new IpConfiguration();\n\n            final String bootProtocol = rs.getString(\"boot_protocol\");\n            if (bootProtocol != null) {\n                final IPv4Address iPv4Address = createIpv4Address(rs, bootProtocol);\n                ipConfiguration.getIPv4Addresses().add(iPv4Address);\n            }\n\n            final String v6BootProtocol = rs.getString(\"ipv6_boot_protocol\");\n            if (v6BootProtocol != null) {\n                final IpV6Address ipV6Address = createIpV6Address(rs, v6BootProtocol);\n                ipConfiguration.getIpV6Addresses().add(ipV6Address);\n            }\n\n            if (bootProtocol != null || v6BootProtocol != null) {\n                entity.setIpConfiguration(ipConfiguration);\n            }\n            entity.setHostNetworkQos(asAnonymousHostNetworkQos(hostNetworkQosMapper.mapRow(rs, rowNum)));\n\n            entity.setDnsResolverConfiguration(dnsMapper.mapRow(rs, rowNum));\n\n            return entity;\n        }\n    }\n\n    public NetworkAttachmentDaoImpl() {\n        super(\"NetworkAttachment\");\n    }\n\n    @Override\n    public List<NetworkAttachment> getAllForNic(Guid nicId) {\n        return getCallsHandler().executeReadList(\"GetNetworkAttachmentsByNicId\",\n                qosDaoAttachmentMapper,\n                getCustomMapSqlParameterSource().addValue(\"nic_id\", nicId));\n    }\n\n    @Override\n    public List<NetworkAttachment> getAllForNetwork(Guid networkId) {\n        return getCallsHandler().executeReadList(\"GetNetworkAttachmentsByNetworkId\",\n                qosDaoAttachmentMapper,\n                getCustomMapSqlParameterSource().addValue(\"network_id\", networkId));\n    }\n\n    @Override\n    public NetworkAttachment getNetworkAttachmentByNicIdAndNetworkId(Guid nicId, Guid networkId) {\n        Objects.requireNonNull(nicId, \"nicId cannot be null\");\n        Objects.requireNonNull(networkId, \"networkId cannot be null\");\n\n        return getCallsHandler().executeRead(\"GetNetworkAttachmentWithQosByNicIdAndNetworkId\",\n                attachmentWithQosMapper,\n                getCustomMapSqlParameterSource().addValue(\"nic_id\", nicId).addValue(\"network_id\", networkId));\n    }\n\n    @Override\n    public List<NetworkAttachment> getAllForHost(Guid hostId) {\n        return getCallsHandler().executeReadList(\"GetNetworkAttachmentsWithQosByHostId\",\n                attachmentWithQosMapper,\n                getCustomMapSqlParameterSource().addValue(\"host_id\", hostId));\n    }\n\n    @Override\n    public void remove(Guid id) {\n        hostNetworkQosDao.remove(id);\n        dnsResolverConfigurationDao.removeByNetworkAttachmentId(id);\n        super.remove(id);\n    }\n\n    @Override\n    public void removeByNetworkId(Guid networkId) {\n        List<NetworkAttachment> networkAttachments = getAllForNetwork(networkId);\n        for (NetworkAttachment networkAttachment : networkAttachments) {\n            hostNetworkQosDao.remove(networkAttachment.getId());\n        }\n\n        getCallsHandler().executeModification(\"RemoveNetworkAttachmentByNetworkId\", createIdParameterMapper(networkId));\n    }\n\n    @Override\n    protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {\n        MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId())\n                .addValue(\"network_id\", networkAttachment.getNetworkId())\n                .addValue(\"nic_id\", networkAttachment.getNicId())\n                .addValue(\"custom_properties\",\n                    SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));\n\n        mapIpConfiguration(networkAttachment, mapper);\n\n        mapper.addValue(\"dns_resolver_configuration_id\", getDnsResolverConfigurationId(networkAttachment));\n        return mapper;\n    }\n\n    private Guid getDnsResolverConfigurationId(NetworkAttachment networkAttachment) {\n        DnsResolverConfiguration dnsResolverConfiguration = networkAttachment.getDnsResolverConfiguration();\n        if (dnsResolverConfiguration == null) {\n            return null;\n        }\n\n        return dnsResolverConfiguration.getId();\n    }\n\n    private void mapIpConfiguration(NetworkAttachment networkAttachment, MapSqlParameterSource mapper) {\n        final IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration() == null\n                ? new IpConfiguration()\n                : networkAttachment.getIpConfiguration();\n        mapIpv4Configuration(mapper, ipConfiguration);\n        mapIpv6Configuration(mapper, ipConfiguration);\n    }\n\n    private void mapIpv4Configuration(MapSqlParameterSource mapper, IpConfiguration ipConfiguration) {\n        if (ipConfiguration.hasIpv4PrimaryAddressSet()) {\n            final IPv4Address primaryIpv4Address = ipConfiguration.getIpv4PrimaryAddress();\n            mapper.addValue(\"boot_protocol\", EnumUtils.nameOrNull(primaryIpv4Address.getBootProtocol()))\n                    .addValue(\"address\", primaryIpv4Address.getAddress())\n                    .addValue(\"netmask\", primaryIpv4Address.getNetmask())\n                    .addValue(\"gateway\", primaryIpv4Address.getGateway());\n        } else {\n            mapper.addValue(\"boot_protocol\", null)\n                    .addValue(\"address\", null)\n                    .addValue(\"netmask\", null)\n                    .addValue(\"gateway\", null);\n        }\n    }\n\n    private void mapIpv6Configuration(MapSqlParameterSource mapper, IpConfiguration ipConfiguration) {\n        if (ipConfiguration.hasIpv6PrimaryAddressSet()) {\n            final IpV6Address primaryIpv6Address = ipConfiguration.getIpv6PrimaryAddress();\n            mapper.addValue(\"ipv6_boot_protocol\", EnumUtils.nameOrNull(primaryIpv6Address.getBootProtocol()))\n                    .addValue(\"ipv6_address\", primaryIpv6Address.getAddress())\n                    .addValue(\"ipv6_prefix\", primaryIpv6Address.getPrefix())\n                    .addValue(\"ipv6_gateway\", primaryIpv6Address.getGateway());\n        } else {\n            mapper.addValue(\"ipv6_boot_protocol\", null)\n                    .addValue(\"ipv6_address\", null)\n                    .addValue(\"ipv6_prefix\", null)\n                    .addValue(\"ipv6_gateway\", null);\n        }\n    }\n\n    @Override\n    protected MapSqlParameterSource createIdParameterMapper(Guid id) {\n        return getCustomMapSqlParameterSource().addValue(\"id\", id);\n    }\n\n    @Override\n    protected RowMapper<NetworkAttachment> createEntityRowMapper() {\n        return qosDaoAttachmentMapper;\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Saves the given NetworkAttachment entity.\n * This method first verifies the relation with the host network QoS.\n * Then, it persists the QoS changes for the entity.\n * If the entity has a DNS resolver configuration, it validates that the ID is null and saves the configuration.\n * Finally, it calls the superclass's save method to save the entity.\n *\n * @param entity The NetworkAttachment entity to be saved.\n * @throws IllegalArgumentException If the DNS resolver configuration ID is not null.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic void save(NetworkAttachment entity) {\n    verifyRelationWithHostNetworkQos(entity);\n    hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));\n\n    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "save", "reference": "    if (dnsResolverConfiguration != null) {\n        Validate.isTrue(dnsResolverConfiguration.getId() == null);\n        dnsResolverConfigurationDao.save(dnsResolverConfiguration);\n    }\n\n    super.save(entity);\n}", "completions": ["```Java\n```Java\n@Override\npublic void save(NetworkAttachment entity) {\n    verifyRelationWithHostNetworkQos(entity);\n    Guid qosId = hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));\n\n    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();\n    if (dnsResolverConfiguration != null && dnsResolverConfiguration.getId() != null) {\n        throw new IllegalArgumentException(\"DNS resolver configuration ID cannot be null\");\n    }\n\n    if (dnsResolverConfiguration != null) {\n        dnsResolverConfiguration.setId(null);\n        dnsResolverConfigurationDao.persist(dnsResolverConfiguration);\n    }\n\n    super.save(entity);\n}\n```\n```\n"]}
{"id": 51, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.mahout.utils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.BitSet;\n\nimport com.google.common.base.Preconditions;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.io.Charsets;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.SequenceFile;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.util.ToolRunner;\nimport org.apache.mahout.common.AbstractJob;\nimport org.apache.mahout.common.CommandLineUtil;\nimport org.apache.mahout.common.HadoopUtil;\nimport org.apache.mahout.common.Pair;\nimport org.apache.mahout.common.RandomUtils;\nimport org.apache.mahout.common.commandline.DefaultOptionCreator;\nimport org.apache.mahout.common.iterator.sequencefile.PathFilters;\nimport org.apache.mahout.common.iterator.sequencefile.SequenceFileIterator;\nimport org.apache.mahout.math.jet.random.sampling.RandomSampler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility for splitting files in the input format used by the Bayes\n * classifiers or anything else that has one item per line or SequenceFiles (key/value)\n * into training and test sets in order to perform cross-validation.\n * <p/>\n * <p/>\n * This class can be used to split directories of files or individual files into\n * training and test sets using a number of different methods.\n * <p/>\n * When executed via {@link #splitDirectory(Path)} or {@link #splitFile(Path)},\n * the lines read from one or more, input files are written to files of the same\n * name into the directories specified by the\n * {@link #setTestOutputDirectory(Path)} and\n * {@link #setTrainingOutputDirectory(Path)} methods.\n * <p/>\n * The composition of the test set is determined using one of the following\n * approaches:\n * <ul>\n * <li>A contiguous set of items can be chosen from the input file(s) using the\n * {@link #setTestSplitSize(int)} or {@link #setTestSplitPct(int)} methods.\n * {@link #setTestSplitSize(int)} allocates a fixed number of items, while\n * {@link #setTestSplitPct(int)} allocates a percentage of the original input,\n * rounded up to the nearest integer. {@link #setSplitLocation(int)} is used to\n * control the position in the input from which the test data is extracted and\n * is described further below.</li>\n * <li>A random sampling of items can be chosen from the input files(s) using\n * the {@link #setTestRandomSelectionSize(int)} or\n * {@link #setTestRandomSelectionPct(int)} methods, each choosing a fixed test\n * set size or percentage of the input set size as described above. The\n * {@link RandomSampler} class from {@code mahout-math} is used to create a sample\n * of the appropriate size.</li>\n * </ul>\n * <p/>\n * Any one of the methods above can be used to control the size of the test set.\n * If multiple methods are called, a runtime exception will be thrown at\n * execution time.\n * <p/>\n * The {@link #setSplitLocation(int)} method is passed an integer from 0 to 100\n * (inclusive) which is translated into the position of the start of the test\n * data within the input file.\n * <p/>\n * Given:\n * <ul>\n * <li>an input file of 1500 lines</li>\n * <li>a desired test data size of 10 percent</li>\n * </ul>\n * <p/>\n * <ul>\n * <li>A split location of 0 will cause the first 150 items appearing in the\n * input set to be written to the test set.</li>\n * <li>A split location of 25 will cause items 375-525 to be written to the test\n * set.</li>\n * <li>A split location of 100 will cause the last 150 items in the input to be\n * written to the test set</li>\n * </ul>\n * The start of the split will always be adjusted forwards in order to ensure\n * that the desired test set size is allocated. Split location has no effect is\n * random sampling is employed.\n */\npublic class SplitInput extends AbstractJob {\n\n  private static final Logger log = LoggerFactory.getLogger(SplitInput.class);\n\n  private int testSplitSize = -1;\n  private int testSplitPct = -1;\n  private int splitLocation = 100;\n  private int testRandomSelectionSize = -1;\n  private int testRandomSelectionPct = -1;\n  private int keepPct = 100;\n  private Charset charset = Charsets.UTF_8;\n  private boolean useSequence;\n  private boolean useMapRed;\n\n  private Path inputDirectory;\n  private Path trainingOutputDirectory;\n  private Path testOutputDirectory;\n  private Path mapRedOutputDirectory;\n\n  private SplitCallback callback;\n\n  @Override\n  public int run(String[] args) throws Exception {\n\n    if (parseArgs(args)) {\n      splitDirectory();\n    }\n    return 0;\n  }\n\n  public static void main(String[] args) throws Exception {\n    ToolRunner.run(new Configuration(), new SplitInput(), args);\n  }\n\n  /**\n   * Configure this instance based on the command-line arguments contained within provided array.\n   * Calls {@link #validate()} to ensure consistency of configuration.\n   *\n   * @return true if the arguments were parsed successfully and execution should proceed.\n   * @throws Exception if there is a problem parsing the command-line arguments or the particular\n   *                   combination would violate class invariants.\n   */\n  private boolean parseArgs(String[] args) throws Exception {\n\n    addInputOption();\n    addOption(\"trainingOutput\", \"tr\", \"The training data output directory\", false);\n    addOption(\"testOutput\", \"te\", \"The test data output directory\", false);\n    addOption(\"testSplitSize\", \"ss\", \"The number of documents held back as test data for each category\", false);\n    addOption(\"testSplitPct\", \"sp\", \"The % of documents held back as test data for each category\", false);\n    addOption(\"splitLocation\", \"sl\", \"Location for start of test data expressed as a percentage of the input file \"\n        + \"size (0=start, 50=middle, 100=end\", false);\n    addOption(\"randomSelectionSize\", \"rs\", \"The number of items to be randomly selected as test data \", false);\n    addOption(\"randomSelectionPct\", \"rp\", \"Percentage of items to be randomly selected as test data when using \"\n        + \"mapreduce mode\", false);\n    addOption(\"charset\", \"c\", \"The name of the character encoding of the input files (not needed if using \"\n        + \"SequenceFiles)\", false);\n    addOption(buildOption(\"sequenceFiles\", \"seq\", \"Set if the input files are sequence files.  Default is false\",\n        false, false, \"false\"));\n    addOption(DefaultOptionCreator.methodOption().create());\n    addOption(DefaultOptionCreator.overwriteOption().create());\n    //TODO: extend this to sequential mode\n    addOption(\"keepPct\", \"k\", \"The percentage of total data to keep in map-reduce mode, the rest will be ignored.  \"\n        + \"Default is 100%\", false);\n    addOption(\"mapRedOutputDir\", \"mro\", \"Output directory for map reduce jobs\", false);\n\n    if (parseArguments(args) == null) {\n      return false;\n    }\n\n    try {\n      inputDirectory = getInputPath();\n\n      useMapRed = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.MAPREDUCE_METHOD);\n\n      if (useMapRed) {\n        if (!hasOption(\"randomSelectionPct\")) {\n          throw new OptionException(getCLIOption(\"randomSelectionPct\"),\n                  \"must set randomSelectionPct when mapRed option is used\");\n        }\n        if (!hasOption(\"mapRedOutputDir\")) {\n          throw new OptionException(getCLIOption(\"mapRedOutputDir\"),\n                                    \"mapRedOutputDir must be set when mapRed option is used\");\n        }\n        mapRedOutputDirectory = new Path(getOption(\"mapRedOutputDir\"));\n        if (hasOption(\"keepPct\")) {\n          keepPct = Integer.parseInt(getOption(\"keepPct\"));\n        }\n        if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {\n          HadoopUtil.delete(getConf(), mapRedOutputDirectory);\n        }\n      } else {\n        if (!hasOption(\"trainingOutput\")\n                || !hasOption(\"testOutput\")) {\n          throw new OptionException(getCLIOption(\"trainingOutput\"),\n                  \"trainingOutput and testOutput must be set if mapRed option is not used\");\n        }\n        if (!hasOption(\"testSplitSize\")\n                && !hasOption(\"testSplitPct\")\n                && !hasOption(\"randomSelectionPct\")\n                && !hasOption(\"randomSelectionSize\")) {\n          throw new OptionException(getCLIOption(\"testSplitSize\"),\n                  \"must set one of test split size/percentage or randomSelectionSize/percentage\");\n        }\n\n        trainingOutputDirectory = new Path(getOption(\"trainingOutput\"));\n        testOutputDirectory = new Path(getOption(\"testOutput\"));\n        FileSystem fs = trainingOutputDirectory.getFileSystem(getConf());\n        if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {\n          HadoopUtil.delete(fs.getConf(), trainingOutputDirectory);\n          HadoopUtil.delete(fs.getConf(), testOutputDirectory);\n        }\n        fs.mkdirs(trainingOutputDirectory);\n        fs.mkdirs(testOutputDirectory);\n      }\n\n      if (hasOption(\"charset\")) {\n        charset = Charset.forName(getOption(\"charset\"));\n      }\n\n      if (hasOption(\"testSplitSize\") && hasOption(\"testSplitPct\")) {\n        throw new OptionException(getCLIOption(\"testSplitPct\"), \"must have either split size or split percentage \"\n            + \"option, not BOTH\");\n      }\n\n      if (hasOption(\"testSplitSize\")) {\n        setTestSplitSize(Integer.parseInt(getOption(\"testSplitSize\")));\n      }\n\n      if (hasOption(\"testSplitPct\")) {\n        setTestSplitPct(Integer.parseInt(getOption(\"testSplitPct\")));\n      }\n\n      if (hasOption(\"splitLocation\")) {\n        setSplitLocation(Integer.parseInt(getOption(\"splitLocation\")));\n      }\n\n      if (hasOption(\"randomSelectionSize\")) {\n        setTestRandomSelectionSize(Integer.parseInt(getOption(\"randomSelectionSize\")));\n      }\n\n      if (hasOption(\"randomSelectionPct\")) {\n        setTestRandomSelectionPct(Integer.parseInt(getOption(\"randomSelectionPct\")));\n      }\n\n      useSequence = hasOption(\"sequenceFiles\");\n\n    } catch (OptionException e) {\n      log.error(\"Command-line option Exception\", e);\n      CommandLineUtil.printHelp(getGroup());\n      return false;\n    }\n\n    validate();\n    return true;\n  }\n\n  /**\n   * Perform a split on directory specified by {@link #setInputDirectory(Path)} by calling {@link #splitFile(Path)}\n   * on each file found within that directory.\n   */\n  public void splitDirectory() throws IOException, ClassNotFoundException, InterruptedException {\n    this.splitDirectory(inputDirectory);\n  }\n\n  /**\n   * Perform a split on the specified directory by calling {@link #splitFile(Path)} on each file found within that\n   * directory.\n   */\n  public void splitDirectory(Path inputDir) throws IOException, ClassNotFoundException, InterruptedException {\n    Configuration conf = getConf();\n    splitDirectory(conf, inputDir);\n  }\n\n  /*\n   * See also splitDirectory(Path inputDir)\n   * */\n  public void splitDirectory(Configuration conf, Path inputDir)\n    throws IOException, ClassNotFoundException, InterruptedException {\n    FileSystem fs = inputDir.getFileSystem(conf);\n    if (fs.getFileStatus(inputDir) == null) {\n      throw new IOException(inputDir + \" does not exist\");\n    }\n    if (!fs.getFileStatus(inputDir).isDir()) {\n      throw new IOException(inputDir + \" is not a directory\");\n    }\n\n    if (useMapRed) {\n      SplitInputJob.run(conf, inputDir, mapRedOutputDirectory,\n            keepPct, testRandomSelectionPct);\n    } else {\n      // input dir contains one file per category.\n      FileStatus[] fileStats = fs.listStatus(inputDir, PathFilters.logsCRCFilter());\n      for (FileStatus inputFile : fileStats) {\n        if (!inputFile.isDir()) {\n          splitFile(inputFile.getPath());\n        }\n      }\n    }\n  }\n\n  /**\n   * Perform a split on the specified input file. Results will be written to files of the same name in the specified\n   * training and test output directories. The {@link #validate()} method is called prior to executing the split.\n   */\n  public void splitFile(Path inputFile) throws IOException {\n    Configuration conf = getConf();\n    FileSystem fs = inputFile.getFileSystem(conf);\n    if (fs.getFileStatus(inputFile) == null) {\n      throw new IOException(inputFile + \" does not exist\");\n    }\n    if (fs.getFileStatus(inputFile).isDir()) {\n      throw new IOException(inputFile + \" is a directory\");\n    }\n\n    validate();\n\n    Path testOutputFile = new Path(testOutputDirectory, inputFile.getName());\n    Path trainingOutputFile = new Path(trainingOutputDirectory, inputFile.getName());\n\n    int lineCount = countLines(fs, inputFile, charset);\n\n    log.info(\"{} has {} lines\", inputFile.getName(), lineCount);\n\n    int testSplitStart = 0;\n    int testSplitSize = this.testSplitSize; // don't modify state\n    BitSet randomSel = null;\n\n    if (testRandomSelectionPct > 0 || testRandomSelectionSize > 0) {\n      testSplitSize = this.testRandomSelectionSize;\n\n      if (testRandomSelectionPct > 0) {\n        testSplitSize = Math.round(lineCount * testRandomSelectionPct / 100.0f);\n      }\n      log.info(\"{} test split size is {} based on random selection percentage {}\",\n               inputFile.getName(), testSplitSize, testRandomSelectionPct);\n      long[] ridx = new long[testSplitSize];\n      RandomSampler.sample(testSplitSize, lineCount - 1, testSplitSize, 0, ridx, 0, RandomUtils.getRandom());\n      randomSel = new BitSet(lineCount);\n      for (long idx : ridx) {\n        randomSel.set((int) idx + 1);\n      }\n    } else {\n      if (testSplitPct > 0) { // calculate split size based on percentage\n        testSplitSize = Math.round(lineCount * testSplitPct / 100.0f);\n        log.info(\"{} test split size is {} based on percentage {}\",\n                 inputFile.getName(), testSplitSize, testSplitPct);\n      } else {\n        log.info(\"{} test split size is {}\", inputFile.getName(), testSplitSize);\n      }\n\n      if (splitLocation > 0) { // calculate start of split based on percentage\n        testSplitStart = Math.round(lineCount * splitLocation / 100.0f);\n        if (lineCount - testSplitStart < testSplitSize) {\n          // adjust split start downwards based on split size.\n          testSplitStart = lineCount - testSplitSize;\n        }\n        log.info(\"{} test split start is {} based on split location {}\",\n                 inputFile.getName(), testSplitStart, splitLocation);\n      }\n\n      if (testSplitStart < 0) {\n        throw new IllegalArgumentException(\"test split size for \" + inputFile + \" is too large, it would produce an \"\n                + \"empty training set from the initial set of \" + lineCount + \" examples\");\n      } else if (lineCount - testSplitSize < testSplitSize) {\n        log.warn(\"Test set size for {} may be too large, {} is larger than the number of \"\n                + \"lines remaining in the training set: {}\",\n                 inputFile, testSplitSize, lineCount - testSplitSize);\n      }\n    }\n    int trainCount = 0;\n    int testCount = 0;\n    if (!useSequence) {\n      try (BufferedReader reader = new BufferedReader(new InputStreamReader(fs.open(inputFile), charset));\n           Writer trainingWriter = new OutputStreamWriter(fs.create(trainingOutputFile), charset);\n           Writer testWriter = new OutputStreamWriter(fs.create(testOutputFile), charset)){\n\n        String line;\n        int pos = 0;\n        while ((line = reader.readLine()) != null) {\n          pos++;\n\n          Writer writer;\n          if (testRandomSelectionPct > 0) { // Randomly choose\n            writer = randomSel.get(pos) ? testWriter : trainingWriter;\n          } else { // Choose based on location\n            writer = pos > testSplitStart ? testWriter : trainingWriter;\n          }\n\n          if (writer == testWriter) {\n            if (testCount >= testSplitSize) {\n              writer = trainingWriter;\n            } else {\n              testCount++;\n            }\n          }\n          if (writer == trainingWriter) {\n            trainCount++;\n          }\n          writer.write(line);\n          writer.write('\\n');\n        }\n\n      }\n    } else {\n      try (SequenceFileIterator<Writable, Writable> iterator =\n               new SequenceFileIterator<>(inputFile, false, fs.getConf());\n           SequenceFile.Writer trainingWriter = SequenceFile.createWriter(fs, fs.getConf(), trainingOutputFile,\n               iterator.getKeyClass(), iterator.getValueClass());\n           SequenceFile.Writer testWriter = SequenceFile.createWriter(fs, fs.getConf(), testOutputFile,\n               iterator.getKeyClass(), iterator.getValueClass())) {\n\n        int pos = 0;\n        while (iterator.hasNext()) {\n          pos++;\n          SequenceFile.Writer writer;\n          if (testRandomSelectionPct > 0) { // Randomly choose\n            writer = randomSel.get(pos) ? testWriter : trainingWriter;\n          } else { // Choose based on location\n            writer = pos > testSplitStart ? testWriter : trainingWriter;\n          }\n\n          if (writer == testWriter) {\n            if (testCount >= testSplitSize) {\n              writer = trainingWriter;\n            } else {\n              testCount++;\n            }\n          }\n          if (writer == trainingWriter) {\n            trainCount++;\n          }\n          Pair<Writable, Writable> pair = iterator.next();\n          writer.append(pair.getFirst(), pair.getSecond());\n        }\n\n      }\n    }\n    log.info(\"file: {}, input: {} train: {}, test: {} starting at {}\",\n             inputFile.getName(), lineCount, trainCount, testCount, testSplitStart);\n\n    // testing;\n    if (callback != null) {\n      callback.splitComplete(inputFile, lineCount, trainCount, testCount, testSplitStart);\n    }\n  }\n\n  public int getTestSplitSize() {\n    return testSplitSize;\n  }\n\n  public void setTestSplitSize(int testSplitSize) {\n    this.testSplitSize = testSplitSize;\n  }\n\n  public int getTestSplitPct() {\n    return testSplitPct;\n  }\n\n  /**\n   * Sets the percentage of the input data to allocate to the test split\n   *\n   * @param testSplitPct a value between 0 and 100 inclusive.\n   */\n  public void setTestSplitPct(int testSplitPct) {\n    this.testSplitPct = testSplitPct;\n  }\n\n  /**\n   * Sets the percentage of the input data to keep in a map reduce split input job\n   *\n   * @param keepPct a value between 0 and 100 inclusive.\n   */\n  public void setKeepPct(int keepPct) {\n    this.keepPct = keepPct;\n  }\n\n  /**\n   * Set to true to use map reduce to split the input\n   *\n   * @param useMapRed a boolean to indicate whether map reduce should be used\n   */\n  public void setUseMapRed(boolean useMapRed) {\n    this.useMapRed = useMapRed;\n  }\n\n  public void setMapRedOutputDirectory(Path mapRedOutputDirectory) {\n    this.mapRedOutputDirectory = mapRedOutputDirectory;\n  }\n\n  public int getSplitLocation() {\n    return splitLocation;\n  }\n\n  /**\n   * Set the location of the start of the test/training data split. Expressed as percentage of lines, for example\n   * 0 indicates that the test data should be taken from the start of the file, 100 indicates that the test data\n   * should be taken from the end of the input file, while 25 indicates that the test data should be taken from the\n   * first quarter of the file.\n   * <p/>\n   * This option is only relevant in cases where random selection is not employed\n   *\n   * @param splitLocation a value between 0 and 100 inclusive.\n   */\n  public void setSplitLocation(int splitLocation) {\n    this.splitLocation = splitLocation;\n  }\n\n  public Charset getCharset() {\n    return charset;\n  }\n\n  /**\n   * Set the charset used to read and write files\n   */\n  public void setCharset(Charset charset) {\n    this.charset = charset;\n  }\n\n  public Path getInputDirectory() {\n    return inputDirectory;\n  }\n\n  /**\n   * Set the directory from which input data will be read when the the {@link #splitDirectory()} method is invoked\n   */\n  public void setInputDirectory(Path inputDir) {\n    this.inputDirectory = inputDir;\n  }\n\n  public Path getTrainingOutputDirectory() {\n    return trainingOutputDirectory;\n  }\n\n  /**\n   * Set the directory to which training data will be written.\n   */\n  public void setTrainingOutputDirectory(Path trainingOutputDir) {\n    this.trainingOutputDirectory = trainingOutputDir;\n  }\n\n  public Path getTestOutputDirectory() {\n    return testOutputDirectory;\n  }\n\n  /**\n   * Set the directory to which test data will be written.\n   */\n  public void setTestOutputDirectory(Path testOutputDir) {\n    this.testOutputDirectory = testOutputDir;\n  }\n\n  public SplitCallback getCallback() {\n    return callback;\n  }\n\n  /**\n   * Sets the callback used to inform the caller that an input file has been successfully split\n   */\n  public void setCallback(SplitCallback callback) {\n    this.callback = callback;\n  }\n\n  public int getTestRandomSelectionSize() {\n    return testRandomSelectionSize;\n  }\n\n  /**\n   * Sets number of random input samples that will be saved to the test set.\n   */\n  public void setTestRandomSelectionSize(int testRandomSelectionSize) {\n    this.testRandomSelectionSize = testRandomSelectionSize;\n  }\n\n  public int getTestRandomSelectionPct() {\n\n    return testRandomSelectionPct;\n  }\n\n  /**\n   * Sets number of random input samples that will be saved to the test set as a percentage of the size of the\n   * input set.\n   *\n   * @param randomSelectionPct a value between 0 and 100 inclusive.\n   */\n  public void setTestRandomSelectionPct(int randomSelectionPct) {\n    this.testRandomSelectionPct = randomSelectionPct;\n  }\n\n  /**\n   * Validates that the current instance is in a consistent state\n   *\n   * @throws IllegalArgumentException if settings violate class invariants.\n   * @throws IOException              if output directories do not exist or are not directories.\n   */\n```\n\n### Code description\n```Java\n/**\n * Validates the configuration of the class.\n *\n * This method checks the following conditions:\n * 1. testSplitSize must be greater than or equal to 1 or equal to -1.\n * 2. splitLocation must be between 0 and 100 inclusive, or equal to -1.\n * 3. testSplitPct must be between 0 and 100 inclusive, or equal to -1.\n * 4. testRandomSelectionPct must be between 0 and 100 inclusive, or equal to -1.\n * 5. Either trainingOutputDirectory or useMapRed must be set.\n * 6. Either testOutputDirectory or useMapRed must be set.\n * 7. Exactly one of testSplitSize, testSplitPct, testRandomSelectionSize, testRandomSelectionPct must be set.\n *\n * If useMapRed is false, it also checks if trainingOutputDirectory and testOutputDirectory are directories.\n *\n * @throws IOException if an I/O error occurs\n */\n```\n\n### Code snippet:\n```Java\npublic void validate() throws IOException {\n  Preconditions.checkArgument(testSplitSize >= 1 || testSplitSize == -1,\n      \"Invalid testSplitSize: \" + testSplitSize + \". Must be: testSplitSize >= 1 or testSplitSize = -1\");\n  Preconditions.checkArgument(splitLocation >= 0 && splitLocation <= 100 || splitLocation == -1,\n      \"Invalid splitLocation percentage: \" + splitLocation + \". Must be: 0 <= splitLocation <= 100 or splitLocation = -1\");\n  Preconditions.checkArgument(testSplitPct >= 0 && testSplitPct <= 100 || testSplitPct == -1,\n      \"Invalid testSplitPct percentage: \" + testSplitPct + \". Must be: 0 <= testSplitPct <= 100 or testSplitPct = -1\");\n  Preconditions.checkArgument(testRandomSelectionPct >= 0 && testRandomSelectionPct <= 100\n          || testRandomSelectionPct == -1,\"Invalid testRandomSelectionPct percentage: \" + testRandomSelectionPct +\n      \". Must be: 0 <= testRandomSelectionPct <= 100 or testRandomSelectionPct = -1\");\n\n  Preconditions.checkArgument(trainingOutputDirectory != null || useMapRed,\n      \"No training output directory was specified\");\n  Preconditions.checkArgument(testOutputDirectory != null || useMapRed, \"No test output directory was specified\");\n\n  // only one of the following may be set, one must be set.\n  int count = 0;\n  if (testSplitSize > 0) {\n    count++;\n  }\n  if (testSplitPct > 0) {\n    count++;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "validate", "reference": "  }\n  if (testRandomSelectionSize > 0) {\n    count++;\n  }\n  if (testRandomSelectionPct > 0) {\n    count++;\n  }\n\n  Preconditions.checkArgument(count == 1, \"Exactly one of testSplitSize, testSplitPct, testRandomSelectionSize, \"\n      + \"testRandomSelectionPct should be set\");\n\n  if (!useMapRed) {\n    Configuration conf = getConf();\n    FileSystem fs = trainingOutputDirectory.getFileSystem(conf);\n    FileStatus trainingOutputDirStatus = fs.getFileStatus(trainingOutputDirectory);\n    Preconditions.checkArgument(trainingOutputDirStatus != null && trainingOutputDirStatus.isDir(),\n        \"%s is not a directory\", trainingOutputDirectory);\n    FileStatus testOutputDirStatus = fs.getFileStatus(testOutputDirectory);\n    Preconditions.checkArgument(testOutputDirStatus != null && testOutputDirStatus.isDir(),\n        \"%s is not a directory\", testOutputDirectory);\n  }\n}", "completions": ["```markdown\n## Code snippet:\n```Java\npublic void validate() throws IOException {\n  Preconditions.checkArgument(testSplitSize >= 1 || testSplitSize == -1,\n      \"Invalid testSplitSize: \" + testSplitSize + \". Must be: testSplitSize >= 1 or testSplitSize = -1\");\n  Preconditions.checkArgument(splitLocation >= 0 && splitLocation <= 100 || splitLocation == -1,\n      \"Invalid splitLocation percentage: \" + splitLocation + \". Must be: 0 <= splitLocation <= 100 or splitLocation = -1\");\n  Preconditions.checkArgument(testSplitPct >= 0 && testSplitPct <= 100 || testSplitPct == -1,\n      \"Invalid testSplitPct percentage: \" + testSplitPct + \". Must be: 0 <= testSplitPct <= 100 or testSplitPct = -1\");\n  Preconditions.checkArgument(testRandomSelectionPct >= 0 && testRandomSelectionPct <= 100\n          || testRandomSelectionPct == -1,\"Invalid testRandomSelectionPct percentage: \" + testRandomSelectionPct +\n      \". Must be: 0 <= testRandomSelectionPct <= 100 or testRandomSelectionPct = -1\");\n\n  Preconditions.checkArgument(trainingOutputDirectory != null || useMapRed,\n      \"No training output directory was specified\");\n  Preconditions.checkArgument(testOutputDirectory != null || useMapRed, \"No test output directory was specified\");\n\n  // only one of the following may be set, one must be set.\n  int count = 0;\n  if (testSplitSize > 0) {\n    count++;\n  }\n  if (testSplitPct > 0) {\n    count++;\n  }\n  if (testRandomSelectionPct > 0) {\n    count++;\n  }\n  Preconditions.checkArgument(count == 1, \"Exactly one of testSplitSize, testSplitPct, testRandomSelectionSize, testRandomSelectionPct must be set\");\n\n  if (!useMapRed) {\n    Preconditions.checkArgument(trainingOutputDirectory != null && trainingOutputDirectory.isDirectory(),\n        \"Training output directory does not exist or is not a directory\");\n    Preconditions.checkArgument(testOutputDirectory != null && testOutputDirectory.isDirectory(),\n        \"Test output directory does not exist or is not a directory\");\n  }\n}\n```\n```\n"]}
{"id": 52, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2014 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage org.sonar.api.config;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.sonar.api.BatchComponent;\nimport org.sonar.api.ServerComponent;\nimport org.sonar.api.utils.DateUtils;\n\nimport javax.annotation.Nullable;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * Project settings on batch side, or global settings on server side. This component does not access to database, so\n * property changed via setter methods are not persisted.\n * <p/>\n * <p>\n * For testing, you can create a new empty {@link Settings} component using {@link #Settings()} and then\n * populate it using all variant of {@code setProperty}. <br/>\n * If you want to test with default values of your properties taken into account there are two ways dependening on how you declare your properties.\n * <ul>\n * <li>If you are using annotations like:\n * <pre>\n * <code>{@literal @}Properties({\n *   {@literal @}Property(\n *     key = \"sonar.myProp\",\n *     defaultValue = \"A default value\",\n *     name = \"My property\"),\n * })\n * public class MyPlugin extends SonarPlugin {\n * </code>\n * </pre>\n * then you can use:\n * <pre>\n * <code>new Settings(new PropertyDefinitions(MyPlugin.class))\n * </code>\n * </pre>\n * </li>\n * <li>If you are using the {@link PropertyDefinition#builder(String)} way like:\n * <pre>\n * <code>\n * public class MyPlugin extends SonarPlugin {\n *     public List getExtensions() {\n *       return Arrays.asList(\n *         PropertyDefinition.builder(\"sonar.myProp\").name(\"My property\").defaultValue(\"A default value\").build()\n *       );\n *     }\n *   }\n * </code>\n * </pre>\n * then you can use:\n * <pre>\n * <code>new Settings(new PropertyDefinitions(new MyPlugin().getExtensions()))\n * </code>\n * </pre>\n * </li>\n * </p>\n * @since 2.12\n */\npublic class Settings implements BatchComponent, ServerComponent {\n\n  protected Map<String, String> properties;\n  protected PropertyDefinitions definitions;\n  private Encryption encryption;\n\n  public Settings() {\n    this(new PropertyDefinitions());\n  }\n\n  public Settings(PropertyDefinitions definitions) {\n    this.properties = Maps.newHashMap();\n    this.definitions = definitions;\n    this.encryption = new Encryption(null);\n  }\n\n  /**\n   * Clone settings. Actions are not propagated to cloned settings.\n   *\n   * @since 3.1\n   */\n  public Settings(Settings other) {\n    this.properties = Maps.newHashMap(other.properties);\n    this.definitions = other.definitions;\n    this.encryption = other.encryption;\n  }\n\n  public Encryption getEncryption() {\n    return encryption;\n  }\n\n  public String getDefaultValue(String key) {\n    return definitions.getDefaultValue(key);\n  }\n\n  public boolean hasKey(String key) {\n    return properties.containsKey(key);\n  }\n\n  public boolean hasDefaultValue(String key) {\n    return StringUtils.isNotEmpty(getDefaultValue(key));\n  }\n\n  public String getString(String key) {\n    String value = getClearString(key);\n    if (value != null && encryption.isEncrypted(value)) {\n      try {\n        value = encryption.decrypt(value);\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Fail to decrypt the property \" + key + \". Please check your secret key.\", e);\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Does not decrypt value.\n   */\n  protected String getClearString(String key) {\n    doOnGetProperties(key);\n    String validKey = definitions.validKey(key);\n    String value = properties.get(validKey);\n    if (value == null) {\n      value = getDefaultValue(validKey);\n    }\n    return value;\n  }\n\n  public boolean getBoolean(String key) {\n    String value = getString(key);\n    return StringUtils.isNotEmpty(value) && Boolean.parseBoolean(value);\n  }\n\n  /**\n   * @return the value as int. If the property does not exist and has no default value, then 0 is returned.\n   */\n  public int getInt(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      return Integer.parseInt(value);\n    }\n    return 0;\n  }\n\n  public long getLong(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      return Long.parseLong(value);\n    }\n    return 0L;\n  }\n\n  public Date getDate(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      return DateUtils.parseDate(value);\n    }\n    return null;\n  }\n\n  public Date getDateTime(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      return DateUtils.parseDateTime(value);\n    }\n    return null;\n  }\n\n  public Float getFloat(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      try {\n        return Float.valueOf(value);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(String.format(\"The property '%s' is not a float value\", key));\n      }\n    }\n    return null;\n  }\n\n  public Double getDouble(String key) {\n    String value = getString(key);\n    if (StringUtils.isNotEmpty(value)) {\n      try {\n        return Double.valueOf(value);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(String.format(\"The property '%s' is not a double value\", key));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Value is split by comma and trimmed. Never returns null.\n   * <p/>\n   * Examples :\n   * <ul>\n   * <li>\"one,two,three \" -> [\"one\", \"two\", \"three\"]</li>\n   * <li>\"  one, two, three \" -> [\"one\", \"two\", \"three\"]</li>\n   * <li>\"one, , three\" -> [\"one\", \"\", \"three\"]</li>\n   * </ul>\n   */\n```\n\n### Code description\n```Java\n/**\n * This method retrieves a string array based on the provided key.\n * It uses the Google Guava library's Splitter API to split the string value by commas.\n * If the property is not null and has multiple values, it replaces the \"%2C\" with \",\" in each value.\n * If the value is null, it returns an empty string array.\n * If the property does not have multiple values, it calls the getStringArrayBySeparator method with a comma separator.\n *\n * @param key The key to retrieve the string array.\n * @return An array of strings.\n */\n```\n\n### Code snippet:\n```Java\npublic String[] getStringArray(String key) {\n  PropertyDefinition property = getDefinitions().get(key);\n  if ((null != property) && (property.multiValues())) {\n    String value = getString(key);\n    if (value == null) {\n      return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getStringArray", "reference": "    List<String> values = Lists.newArrayList();\n    for (String v : Splitter.on(\",\").trimResults().split(value)) {\n      values.add(v.replace(\"%2C\", \",\"));\n    }\n    return values.toArray(new String[values.size()]);\n  }\n\n  return getStringArrayBySeparator(key, \",\");\n}", "completions": ["```Java\n    return ArrayUtils.toStringArray(Splitter.on(\",\").trimResults().split(value));\n  }\n  else {\n    return getStringArrayBySeparator(key, \",\");\n  }\n}\n```\n"]}
{"id": 53, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*-\n * -\\-\\-\n * Helios Services\n * --\n * Copyright (C) 2016 Spotify AB\n * --\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * -/-/-\n */\n\npackage com.spotify.helios.servicescommon.coordination;\n\nimport static com.google.common.collect.MapDifference.ValueDifference;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.apache.zookeeper.KeeperException.ConnectionLossException;\nimport static org.apache.zookeeper.KeeperException.NoNodeException;\nimport static org.apache.zookeeper.KeeperException.NodeExistsException;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Suppliers;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.MapDifference;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.AbstractIdleService;\nimport com.spotify.helios.agent.BoundedRandomExponentialBackoff;\nimport com.spotify.helios.agent.RetryScheduler;\nimport com.spotify.helios.servicescommon.DefaultReactor;\nimport com.spotify.helios.servicescommon.PersistentAtomicReference;\nimport com.spotify.helios.servicescommon.Reactor;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.utils.ZKPaths;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.common.PathUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A map that persists modification locally on disk and attempt to replicate modifications to\n * ZooKeeper, retrying forever until successful. Note that ZooKeeper is only written to and never\n * read from, so this is not a distributed map. Multiple changes to the same key are folded and only\n * the last value is written to ZooKeeper.\n */\npublic class ZooKeeperUpdatingPersistentDirectory extends AbstractIdleService {\n\n  private static final Logger log =\n      LoggerFactory.getLogger(ZooKeeperUpdatingPersistentDirectory.class);\n\n  private static final long RETRY_INTERVAL_MILLIS = 5000;\n\n  private static final Map<String, byte[]> EMPTY_ENTRIES = Collections.emptyMap();\n  private static final TypeReference<Map<String, byte[]>> ENTRIES_TYPE =\n      new TypeReference<Map<String, byte[]>>() {};\n\n  private static final Equivalence<? super byte[]> BYTE_ARRAY_EQUIVALENCE =\n      new Equivalence<byte[]>() {\n        @Override\n        protected boolean doEquivalent(final byte[] bytes1, final byte[] bytes2) {\n          return Arrays.equals(bytes1, bytes2);\n        }\n\n        @Override\n        protected int doHash(final byte[] bytes) {\n          return Arrays.hashCode(bytes);\n        }\n      };\n\n  private final ZooKeeperClientProvider provider;\n  private final String path;\n  private final Reactor reactor;\n  private final PersistentAtomicReference<Map<String, byte[]>> entries;\n\n  private final Object lock = new Object() {};\n\n  private Map<String, byte[]> remote = Maps.newHashMap();\n  private volatile boolean initialized;\n\n  private final ConnectionStateListener connectionStateListener = new ConnectionStateListener() {\n    @Override\n    public void stateChanged(final CuratorFramework client, final ConnectionState newState) {\n      switch (newState) {\n        case CONNECTED:\n          break;\n        case SUSPENDED:\n          break;\n        case RECONNECTED:\n          initialized = false;\n          reactor.signal();\n          break;\n        case LOST:\n        case READ_ONLY:\n        default:\n          break;\n      }\n    }\n  };\n\n  private ZooKeeperUpdatingPersistentDirectory(final String name,\n                                               final ZooKeeperClientProvider provider,\n                                               final Path stateFile,\n                                               final String path)\n      throws IOException, InterruptedException {\n    this.provider = provider;\n    this.path = path;\n    this.entries = PersistentAtomicReference.create(stateFile, ENTRIES_TYPE,\n        Suppliers.ofInstance(EMPTY_ENTRIES));\n    this.reactor = new DefaultReactor(name, new Update(), RETRY_INTERVAL_MILLIS);\n  }\n\n  public byte[] put(final String key, final byte[] value) throws InterruptedException {\n    Preconditions.checkArgument(key.indexOf('/') == -1);\n    PathUtils.validatePath(ZKPaths.makePath(path, key));\n    final byte[] prev;\n    synchronized (lock) {\n      final Map<String, byte[]> mutable = Maps.newHashMap(entries.get());\n      prev = mutable.put(key, value);\n      try {\n        entries.set(ImmutableMap.copyOf(mutable));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    reactor.signal();\n    return prev;\n  }\n\n  public byte[] remove(final Object key) throws InterruptedException {\n    if (!(key instanceof String)) {\n      return null;\n    }\n    return remove((String) key);\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Removes a key-value pair from the entries map.\n *\n * @param key The key to be removed.\n * @return The value associated with the removed key.\n * @throws InterruptedException If the thread is interrupted while waiting.\n * @throws IllegalArgumentException If the key contains a '/'.\n */\n```\n\n### Code snippet:\n```Java\nprivate byte[] remove(final String key) throws InterruptedException {\n  Preconditions.checkArgument(key.indexOf('/') == -1);\n  PathUtils.validatePath(ZKPaths.makePath(path, key));\n  final byte[] value;\n  synchronized (lock) {\n    final Map<String, byte[]> mutable = Maps.newHashMap(entries.get());\n    value = mutable.remove(key);\n    try {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "remove", "reference": "      entries.set(ImmutableMap.copyOf(mutable));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  reactor.signal();\n  return value;\n}", "completions": ["```Java\n    final Map<String, byte[]> mutable = Maps.newHashMap(entries.get());\n    value = mutable.remove(key);\n    try {\n      entries.set(ImmutableMap.copyOf(mutable));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  reactor.signal();\n  return value;\n}\n```\n"]}
{"id": 54, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ambari.server.controller.internal;\n\nimport static org.apache.ambari.server.agent.ExecutionCommand.KeyNames.JDK_LOCATION;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.ambari.server.AmbariException;\nimport org.apache.ambari.server.StaticallyInject;\nimport org.apache.ambari.server.actionmanager.ActionManager;\nimport org.apache.ambari.server.actionmanager.RequestFactory;\nimport org.apache.ambari.server.actionmanager.Stage;\nimport org.apache.ambari.server.actionmanager.StageFactory;\nimport org.apache.ambari.server.api.services.AmbariMetaInfo;\nimport org.apache.ambari.server.configuration.Configuration;\nimport org.apache.ambari.server.controller.ActionExecutionContext;\nimport org.apache.ambari.server.controller.AmbariActionExecutionHelper;\nimport org.apache.ambari.server.controller.AmbariManagementController;\nimport org.apache.ambari.server.controller.spi.NoSuchParentResourceException;\nimport org.apache.ambari.server.controller.spi.NoSuchResourceException;\nimport org.apache.ambari.server.controller.spi.Predicate;\nimport org.apache.ambari.server.controller.spi.Request;\nimport org.apache.ambari.server.controller.spi.RequestStatus;\nimport org.apache.ambari.server.controller.spi.Resource;\nimport org.apache.ambari.server.controller.spi.Resource.Type;\nimport org.apache.ambari.server.controller.spi.ResourceAlreadyExistsException;\nimport org.apache.ambari.server.controller.spi.SystemException;\nimport org.apache.ambari.server.controller.spi.UnsupportedPropertyException;\nimport org.apache.ambari.server.controller.utilities.PropertyHelper;\nimport org.apache.ambari.server.orm.dao.HostVersionDAO;\nimport org.apache.ambari.server.orm.dao.RepositoryVersionDAO;\nimport org.apache.ambari.server.orm.entities.HostVersionEntity;\nimport org.apache.ambari.server.orm.entities.RepoOsEntity;\nimport org.apache.ambari.server.orm.entities.RepositoryVersionEntity;\nimport org.apache.ambari.server.state.Cluster;\nimport org.apache.ambari.server.state.Host;\nimport org.apache.ambari.server.state.RepositoryVersionState;\nimport org.apache.ambari.server.state.ServiceComponentHost;\nimport org.apache.ambari.server.state.StackId;\nimport org.apache.ambari.server.state.stack.upgrade.RepositoryVersionHelper;\nimport org.apache.ambari.server.utils.StageUtils;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang.BooleanUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.collect.Sets;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\n\n/**\n * Resource provider for host stack versions resources.\n */\n@StaticallyInject\npublic class HostStackVersionResourceProvider extends AbstractControllerResourceProvider {\n\n  private static final Logger LOG = LoggerFactory.getLogger(HostStackVersionResourceProvider.class);\n\n  // ----- Property ID constants ---------------------------------------------\n\n  protected static final String HOST_STACK_VERSION_ID_PROPERTY_ID              = PropertyHelper.getPropertyId(\"HostStackVersions\", \"id\");\n  protected static final String HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID    = PropertyHelper.getPropertyId(\"HostStackVersions\", \"cluster_name\");\n  protected static final String HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID       = PropertyHelper.getPropertyId(\"HostStackVersions\", \"host_name\");\n  protected static final String HOST_STACK_VERSION_STACK_PROPERTY_ID           = PropertyHelper.getPropertyId(\"HostStackVersions\", \"stack\");\n  protected static final String HOST_STACK_VERSION_VERSION_PROPERTY_ID         = PropertyHelper.getPropertyId(\"HostStackVersions\", \"version\");\n  protected static final String HOST_STACK_VERSION_STATE_PROPERTY_ID           = PropertyHelper.getPropertyId(\"HostStackVersions\", \"state\");\n  protected static final String HOST_STACK_VERSION_REPOSITORIES_PROPERTY_ID    = PropertyHelper.getPropertyId(\"HostStackVersions\", \"repositories\");\n  protected static final String HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID    = PropertyHelper.getPropertyId(\"HostStackVersions\", \"repository_version\");\n\n  /**\n   * Whether to force creating of install command on a host which is not member of any cluster yet.\n   * This will also run hdp-select for specified stack version.\n   */\n  protected static final String HOST_STACK_VERSION_FORCE_INSTALL_ON_NON_MEMBER_HOST_PROPERTY_ID = PropertyHelper\n    .getPropertyId(\"HostStackVersions\", \"force_non_member_install\");\n\n  /**\n   * In case of force_non_member_install = true a list of component names must be provided in the request.\n   */\n  protected static final String HOST_STACK_VERSION_COMPONENT_NAMES_PROPERTY_ID = PropertyHelper.getPropertyId(\"HostStackVersions\", \"components\");\n  protected static final String COMPONENT_NAME_PROPERTY_ID = \"name\";\n\n  protected static final String INSTALL_PACKAGES_ACTION = \"install_packages\";\n  protected static final String STACK_SELECT_ACTION = \"stack_select_set_all\";\n  protected static final String INSTALL_PACKAGES_FULL_NAME = \"Install Version\";\n\n\n  private static Set<String> pkPropertyIds = Sets.newHashSet(\n          HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_ID_PROPERTY_ID,\n          HOST_STACK_VERSION_STACK_PROPERTY_ID,\n          HOST_STACK_VERSION_VERSION_PROPERTY_ID,\n          HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID);\n\n  private static Set<String> propertyIds = Sets.newHashSet(\n          HOST_STACK_VERSION_ID_PROPERTY_ID,\n          HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_STACK_PROPERTY_ID,\n          HOST_STACK_VERSION_VERSION_PROPERTY_ID,\n          HOST_STACK_VERSION_STATE_PROPERTY_ID,\n          HOST_STACK_VERSION_REPOSITORIES_PROPERTY_ID,\n          HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID,\n          HOST_STACK_VERSION_FORCE_INSTALL_ON_NON_MEMBER_HOST_PROPERTY_ID,\n          HOST_STACK_VERSION_COMPONENT_NAMES_PROPERTY_ID);\n\n  private static Map<Type, String> keyPropertyIds = new HashMap<Type, String>() {\n    {\n      put(Type.Cluster, HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);\n      put(Type.Host, HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID);\n      put(Type.HostStackVersion, HOST_STACK_VERSION_ID_PROPERTY_ID);\n      put(Type.Stack, HOST_STACK_VERSION_STACK_PROPERTY_ID);\n      put(Type.StackVersion, HOST_STACK_VERSION_VERSION_PROPERTY_ID);\n      put(Type.RepositoryVersion, HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID);\n    }\n  };\n\n  @Inject\n  private static HostVersionDAO hostVersionDAO;\n\n  @Inject\n  private static RepositoryVersionDAO repositoryVersionDAO;\n\n  @Inject\n  private static StageFactory stageFactory;\n\n  @Inject\n  private static RequestFactory requestFactory;\n\n  @Inject\n  private static Provider<AmbariActionExecutionHelper> actionExecutionHelper;\n\n  @Inject\n  private static Configuration configuration;\n\n  @Inject\n  private static RepositoryVersionHelper repoVersionHelper;\n\n  /**\n   * Constructor.\n   */\n  public HostStackVersionResourceProvider(\n          AmbariManagementController managementController) {\n    super(Type.HostStackVersion, propertyIds, keyPropertyIds, managementController);\n  }\n\n  @Override\n  public Set<Resource> getResources(Request request, Predicate predicate) throws\n      SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n    final Set<Resource> resources = new HashSet<>();\n    final Set<String> requestedIds = getRequestPropertyIds(request, predicate);\n    final Set<Map<String, Object>> propertyMaps = getPropertyMaps(predicate);\n\n    for (Map<String, Object> propertyMap: propertyMaps) {\n      final String hostName = propertyMap.get(HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID).toString();\n      String clusterName = null;\n      if (propertyMap.containsKey(HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID)) {\n        clusterName = propertyMap.get(HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID).toString();\n      }\n      final Long id;\n      List<HostVersionEntity> requestedEntities;\n      if (propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID) == null) {\n        if (clusterName == null) {\n          requestedEntities = hostVersionDAO.findByHost(hostName);\n        } else {\n          requestedEntities = hostVersionDAO.findByClusterAndHost(clusterName, hostName);\n        }\n      } else {\n        try {\n          id = Long.parseLong(propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID).toString());\n        } catch (Exception ex) {\n          throw new SystemException(\"Stack version should have numerical id\");\n        }\n        final HostVersionEntity entity = hostVersionDAO.findByPK(id);\n        if (entity == null) {\n          throw new NoSuchResourceException(\"There is no stack version with id \" + id);\n        } else {\n          requestedEntities = Collections.singletonList(entity);\n        }\n      }\n      if (requestedEntities != null) {\n        addRequestedEntities(resources, requestedEntities, requestedIds, clusterName);\n      }\n    }\n\n    return resources;\n  }\n\n\n  /**\n   * Adds requested entities to resources\n   * @param resources a list of resources to add to\n   * @param requestedEntities requested entities\n   * @param requestedIds\n   * @param clusterName name of cluster or null if no any\n   */\n  public void addRequestedEntities(Set<Resource> resources,\n                                   List<HostVersionEntity> requestedEntities,\n                                   Set<String> requestedIds,\n                                   String clusterName) {\n    for (HostVersionEntity entity: requestedEntities) {\n      StackId stackId = new StackId(entity.getRepositoryVersion().getStack());\n\n      RepositoryVersionEntity repoVerEntity = repositoryVersionDAO.findByStackAndVersion(\n          stackId, entity.getRepositoryVersion().getVersion());\n\n      final Resource resource = new ResourceImpl(Resource.Type.HostStackVersion);\n\n      setResourceProperty(resource, HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID, entity.getHostName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_ID_PROPERTY_ID, entity.getId(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STACK_PROPERTY_ID, stackId.getStackName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_VERSION_PROPERTY_ID, stackId.getStackVersion(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STATE_PROPERTY_ID, entity.getState().name(), requestedIds);\n\n      if (clusterName != null) {\n        setResourceProperty(resource, HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID, clusterName, requestedIds);\n      }\n\n      if (repoVerEntity != null) {\n        Long repoVersionId = repoVerEntity.getId();\n        setResourceProperty(resource, HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID, repoVersionId, requestedIds);\n      }\n\n      resources.add(resource);\n    }\n  }\n\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method creates resources based on the provided request.\n * It validates the request properties and creates a request to install packages.\n *\n * @param request The request containing the properties for resource creation.\n * @return The status of the request after resource creation.\n * @throws SystemException If a system-level exception occurs.\n * @throws UnsupportedPropertyException If an unsupported property is encountered.\n * @throws ResourceAlreadyExistsException If the resource already exists.\n * @throws NoSuchParentResourceException If the parent resource does not exist.\n * @throws UnsupportedOperationException If multiple requests are executed at the same time.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic RequestStatus createResources(Request request) throws SystemException,\n        UnsupportedPropertyException, ResourceAlreadyExistsException,\n        NoSuchParentResourceException {\n  Iterator<Map<String,Object>> iterator = request.getProperties().iterator();\n  String hostName;\n  final String desiredRepoVersion;\n  String stackName;\n  String stackVersion;\n  if (request.getProperties().size() > 1) {\n    throw new UnsupportedOperationException(\"Multiple requests cannot be executed at the same time.\");\n  }\n\n  Map<String, Object> propertyMap  = iterator.next();\n\n  Set<String> requiredProperties = Sets.newHashSet(\n          HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID,\n          HOST_STACK_VERSION_STACK_PROPERTY_ID,\n          HOST_STACK_VERSION_VERSION_PROPERTY_ID);\n\n  for (String requiredProperty : requiredProperties) {\n    Validate.isTrue(propertyMap.containsKey(requiredProperty),\n            String.format(\"The required property %s is not defined\", requiredProperty));\n  }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "createResources", "reference": "\n  String clName = (String) propertyMap.get (HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);\n  hostName = (String) propertyMap.get(HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID);\n  desiredRepoVersion = (String) propertyMap.get(HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID);\n  stackName = (String) propertyMap.get(HOST_STACK_VERSION_STACK_PROPERTY_ID);\n  stackVersion = (String) propertyMap.get(HOST_STACK_VERSION_VERSION_PROPERTY_ID);\n\n  boolean forceInstallOnNonMemberHost = false;\n  Set<Map<String, String>> componentNames = null;\n  String forceInstallOnNonMemberHostString = (String) propertyMap.get\n    (HOST_STACK_VERSION_FORCE_INSTALL_ON_NON_MEMBER_HOST_PROPERTY_ID);\n\n  if (BooleanUtils.toBoolean(forceInstallOnNonMemberHostString)) {\n    forceInstallOnNonMemberHost = true;\n    componentNames = (Set<Map<String, String>>) propertyMap.get(HOST_STACK_VERSION_COMPONENT_NAMES_PROPERTY_ID);\n    if (componentNames == null) {\n      throw new IllegalArgumentException(\"In case \" + HOST_STACK_VERSION_FORCE_INSTALL_ON_NON_MEMBER_HOST_PROPERTY_ID + \" is set to true, the list of \" +\n        \"components should be specified in request.\");\n    }\n  }\n\n  RequestStageContainer req = createInstallPackagesRequest(hostName, desiredRepoVersion, stackName, stackVersion,\n    clName, forceInstallOnNonMemberHost, componentNames);\n  return getRequestStatus(req.getRequestStatusResponse());\n}", "completions": ["```markdown\n```java\n/**\n * Description: This method creates resources based on the provided request.\n * It validates the request properties and creates a request to install packages.\n *\n * @param request The request containing the properties for resource creation.\n * @return The status of the request after resource creation.\n * @throws SystemException If a system-level exception occurs.\n * @throws UnsupportedPropertyException If an unsupported property is encountered.\n * @throws ResourceAlreadyExistsException If the resource already exists.\n * @throws NoSuchParentResourceException If the parent resource does not exist.\n * @throws UnsupportedOperationException If multiple requests are executed at the same time.\n */\npublic RequestStatus createResources(Request request) throws SystemException,\n        UnsupportedPropertyException, ResourceAlreadyExistsException,\n        NoSuchParentResourceException {\n  Iterator<Map<String,Object>> iterator = request.getProperties().iterator();\n  String hostName;\n  final String desiredRepoVersion;\n  String stackName;\n  String stackVersion;\n  if (request.getProperties().size() > 1) {\n    throw new UnsupportedOperationException(\"Multiple requests cannot be executed at the same time.\");\n  }\n\n  Map<String, Object> propertyMap  = iterator.next();\n\n  Set<String> requiredProperties = Sets.newHashSet(\n          HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID,\n          HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID,\n          HOST_STACK_VERSION_STACK_PROPERTY_ID,\n          HOST_STACK_VERSION_VERSION_PROPERTY_ID);\n\n  for (String requiredProperty : requiredProperties) {\n    Validate.isTrue(propertyMap.containsKey(requiredProperty),\n            String.format(\"The required property %s is not defined\", requiredProperty));\n  }\n\n  // TODO: Implement the logic to create resources based on the request properties.\n\n  return RequestStatus.SUCCESS;\n}\n```\n```\n"]}
{"id": 55, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n */\n\npackage org.apache.synapse.config.xml;\n\nimport org.apache.synapse.config.xml.endpoints.TemplateSerializer;\nimport org.apache.synapse.config.xml.inbound.InboundEndpointSerializer;\nimport org.apache.synapse.config.xml.rest.APISerializer;\nimport org.apache.synapse.deployers.SynapseArtifactDeploymentStore;\nimport org.apache.synapse.config.SynapseConfiguration;\nimport org.apache.synapse.config.Entry;\nimport org.apache.synapse.config.xml.eventing.EventSourceSerializer;\nimport org.apache.synapse.config.xml.endpoints.EndpointSerializer;\nimport org.apache.synapse.endpoints.Template;\nimport org.apache.synapse.inbound.InboundEndpoint;\nimport org.apache.synapse.libraries.imports.SynapseImport;\nimport org.apache.synapse.mediators.template.TemplateMediator;\nimport org.apache.synapse.message.processor.MessageProcessor;\nimport org.apache.synapse.registry.Registry;\nimport org.apache.synapse.core.axis2.ProxyService;\nimport org.apache.synapse.eventing.SynapseEventSource;\nimport org.apache.synapse.Startup;\nimport org.apache.synapse.SynapseConstants;\nimport org.apache.synapse.message.store.MessageStore;\nimport org.apache.synapse.api.API;\nimport org.apache.synapse.startup.AbstractStartup;\nimport org.apache.synapse.commons.executors.PriorityExecutor;\nimport org.apache.synapse.commons.executors.config.PriorityExecutorSerializer;\nimport org.apache.synapse.endpoints.Endpoint;\nimport org.apache.synapse.endpoints.AbstractEndpoint;\nimport org.apache.synapse.mediators.base.SequenceMediator;\nimport org.apache.axiom.om.OMElement;\nimport org.apache.axiom.om.OMFactory;\nimport org.apache.axiom.om.OMAbstractFactory;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.axis2.util.XMLPrettyPrinter;\nimport org.apache.synapse.task.TaskManager;\n\nimport java.io.*;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.util.Collection;\nimport java.util.Date;\n\npublic class MultiXMLConfigurationSerializer {\n\n    private static final Log log = LogFactory.getLog(MultiXMLConfigurationSerializer.class);\n\n    private File rootDirectory;\n    private File currentDirectory;\n\n    public MultiXMLConfigurationSerializer(String directoryPath) {\n        rootDirectory = new File(directoryPath);\n        currentDirectory = rootDirectory;\n    }\n\n    /**\n     * Serializes the given SynapseConfiguration to the file system. This method is NOT\n     * thread safe and hence it must not be called by multiple concurrent threads. This method\n     * will first serialize the configuration to a temporary directory at the same level as the\n     * rootDirectory and then rename/move it as the new rootDirectory. If an error occurs\n     * while saving the configuration, the temporary files will be not be removed from the\n     * file system.\n     *\n     * @param synapseConfig configuration to be serialized\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method serializes the Synapse configuration to the file system. It uses the API of org.apache.commons.io.FileUtils.copyDirectory to copy the temporary directory structure to the root directory.\n * \n * @param synapseConfig The Synapse configuration to be serialized.\n */\n```\n\n### Code snippet:\n```Java\npublic void serialize(SynapseConfiguration synapseConfig) {\n    if (log.isDebugEnabled()) {\n        log.debug(\"Serializing Synapse configuration to the file system\");\n    }\n\n    OMFactory fac = OMAbstractFactory.getOMFactory();\n    OMElement definitions = fac.createOMElement(\"definitions\",\n            XMLConfigConstants.SYNAPSE_OMNAMESPACE);\n\n    boolean errorOccurred = false;\n\n    try {\n        currentDirectory = createTempDirectoryStructure();\n\n        if (synapseConfig.getRegistry() != null) {\n            serializeSynapseRegistry(synapseConfig.getRegistry(), synapseConfig, definitions);\n        }\n\n        if (synapseConfig.getTaskManager() != null) {\n            serializeTaskManager(synapseConfig.getTaskManager(), synapseConfig, definitions);\n        }\n\n        serializeProxyServices(synapseConfig.getProxyServices(), synapseConfig, definitions);\n        serializeEventSources(synapseConfig.getEventSources(), synapseConfig, definitions);\n        serializeTasks(synapseConfig.getStartups(), synapseConfig, definitions);\n        serializeLocalRegistryValues(synapseConfig.getLocalRegistry().values(),\n                                     synapseConfig, definitions);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "serialize", "reference": "        serializeExecutors(synapseConfig.getPriorityExecutors().values(),\n                           synapseConfig, definitions);\n        serializeMessageStores(synapseConfig.getMessageStores().values(), synapseConfig,\n                               definitions);\n        serializeMessageProcessors(synapseConfig.getMessageProcessors().values(), synapseConfig,\n                                   definitions);\n        serializeAPIs(synapseConfig.getAPIs(), synapseConfig, definitions);\n        serializeInboundEndpoints(synapseConfig.getInboundEndpoints(), synapseConfig, definitions);\n        serializeImports(synapseConfig.getSynapseImports().values(), synapseConfig, definitions);\n        serializeComments(synapseConfig.getCommentedTextList(), definitions);\n        serializeSynapseXML(definitions);\n\n        markConfigurationForSerialization(synapseConfig);\n        if (rootDirectory.exists()) {\n            cleanupOldFiles();\n        }\n        FileUtils.copyDirectory(currentDirectory, rootDirectory);\n\n    } catch (Exception e) {\n        log.error(\"Error while serializing the configuration to the file system\", e);\n        errorOccurred = true;\n    } finally {\n        if (!errorOccurred) {\n            deleteTempDirectory();\n        }\n        currentDirectory = rootDirectory;\n    }\n}", "completions": ["```Java\n        serializeEndpoints(synapseConfig.getEndpoints(), synapseConfig, definitions);\n        serializeMessageStores(synapseConfig.getMessageStores(), synapseConfig, definitions);\n        serializeMessageProcessors(synapseConfig.getMessageProcessors(), synapseConfig, definitions);\n        serializeMediators(synapseConfig.getMediators(), synapseConfig, definitions);\n        serializeAPIs(synapseConfig.getAPIs(), synapseConfig, definitions);\n        serializeTemplates(synapseConfig.getTemplates(), synapseConfig, definitions);\n        serializeEventing(synapseConfig.getEventing(), synapseConfig, definitions);\n        serializeSecurity(synapseConfig.getSecurity(), synapseConfig, definitions);\n        serializeRegistry(synapseConfig.getRegistry(), synapseConfig, definitions);\n        serializeStartup(synapseConfig.getStartup(), synapseConfig, definitions);\n        serializeExecutor(synapseConfig.getExecutor(), synapseConfig, definitions);\n        serializePriorityExecutor(synapseConfig.getPriorityExecutor(), synapseConfig, definitions);\n        serializeTemplateSerializer(synapseConfig.getTemplateSerializer(), synapseConfig, definitions);\n        serializeInboundEndpointSerializer(synapseConfig.getInboundEndpointSerializer(), synapseConfig, definitions);\n        serializeAPISerializer(synapseConfig.getAPISerializer(), synapseConfig, definitions);\n        serializeEventSourceSerializer(synapseConfig.getEventSourceSerializer(), synapseConfig, definitions);\n        serializeEndpointSerializer(synapseConfig.getEndpointSerializer(), synapseConfig, definitions);\n        serializeTemplateMediator(synapseConfig.getTemplateMediator(), synapseConfig, definitions);\n        serializeSequenceMediator(synapseConfig.getSequenceMediator(), synapseConfig, definitions);\n\n        FileUtils.copyDirectory(currentDirectory, rootDirectory);\n\n    } catch (IOException e) {\n        errorOccurred = true;\n        log.error(\"Error occurred while serializing Synapse configuration\", e);\n    } finally {\n        if (errorOccurred) {\n            try {\n                FileUtils.deleteDirectory(currentDirectory);\n            } catch (IOException e) {\n                log.error(\"Error occurred while deleting temporary directory\", e);\n            }\n        }\n    }\n}\n```\n"]}
{"id": 56, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage edu.illinois.library.cantaloupe.source;\n\nimport com.microsoft.azure.storage.StorageException;\nimport com.microsoft.azure.storage.blob.CloudBlockBlob;\nimport edu.illinois.library.cantaloupe.config.Configuration;\nimport edu.illinois.library.cantaloupe.config.Key;\nimport edu.illinois.library.cantaloupe.source.stream.HTTPImageInputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.imageio.stream.ImageInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Source of streams for {@link AzureStorageSource}, returned from {@link\n * AzureStorageSource#newStreamFactory()}.\n */\nclass AzureStorageStreamFactory implements StreamFactory {\n\n    private static final Logger LOGGER =\n            LoggerFactory.getLogger(AzureStorageStreamFactory.class);\n\n    private static final int DEFAULT_CHUNK_SIZE       = 1024 * 512;\n    private static final int DEFAULT_CHUNK_CACHE_SIZE = 1024 * 1024 * 10;\n\n    private final CloudBlockBlob blob;\n\n    AzureStorageStreamFactory(CloudBlockBlob blob) {\n        this.blob = blob;\n    }\n\n    @Override\n    public InputStream newInputStream() throws IOException {\n        try {\n            return blob.openInputStream();\n        } catch (StorageException e) {\n            throw new IOException(e.getMessage(), e);\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Creates a new seekable stream for the blob. If chunking is enabled, it creates an HTTPImageInputStream with the blob's properties and sets the window size and max chunk cache size if applicable. If chunking is disabled, it calls the super method to create a new seekable stream.\n *\n * @return An ImageInputStream representing the seekable stream for the blob.\n * @throws IOException If an I/O error occurs while creating the stream.\n * @see org.apache.commons.io.IOUtils#closeQuietly(Closeable)\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic ImageInputStream newSeekableStream() throws IOException {\n    if (isChunkingEnabled()) {\n        final int chunkSize = getChunkSize();\n        LOGGER.debug(\"newSeekableStream(): using {}-byte chunks\",\n                chunkSize);\n\n        final AzureStorageHTTPImageInputStreamClient client =\n                new AzureStorageHTTPImageInputStreamClient(blob);\n\n        try {\n            // Populate the blob's properties, if they haven't been already.\n            blob.exists();\n        } catch (StorageException e) {\n            LOGGER.warn(\"newSeekableStream(): {}\", e.getMessage());\n        }\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "newSeekableStream", "reference": "        HTTPImageInputStream stream = new HTTPImageInputStream(\n                client, blob.getProperties().getLength());\n        try {\n            stream.setWindowSize(chunkSize);\n            if (isChunkCacheEnabled()) {\n                stream.setMaxChunkCacheSize(getMaxChunkCacheSize());\n            }\n            return stream;\n        } catch (Throwable t) {\n            IOUtils.closeQuietly(stream);\n            throw t;\n        }\n    } else {\n        LOGGER.debug(\"newSeekableStream(): chunking is disabled\");\n        return StreamFactory.super.newSeekableStream();\n    }\n}", "completions": ["```Java\n        // Set the window size and max chunk cache size, if applicable.\n        if (isChunkingEnabled()) {\n            client.setWindowSize(chunkSize);\n            client.setMaxChunkCacheSize(getMaxChunkCacheSize());\n        }\n\n        return client;\n    }\n}\n```\n"]}
{"id": 57, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.reporting.prometheus;\n\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Gauge;\nimport org.apache.nifi.annotation.documentation.CapabilityDescription;\nimport org.apache.nifi.annotation.documentation.Tags;\nimport org.apache.nifi.annotation.lifecycle.OnDisabled;\nimport org.apache.nifi.annotation.lifecycle.OnEnabled;\nimport org.apache.nifi.annotation.lifecycle.OnShutdown;\nimport org.apache.nifi.components.PropertyDescriptor;\nimport org.apache.nifi.controller.AbstractControllerService;\nimport org.apache.nifi.controller.ConfigurationContext;\nimport org.apache.nifi.processor.exception.ProcessException;\nimport org.apache.nifi.record.sink.RecordSinkService;\nimport org.apache.nifi.reporting.ReportingContext;\nimport org.apache.nifi.prometheus.util.PrometheusMetricsUtil;\nimport org.apache.nifi.serialization.WriteResult;\nimport org.apache.nifi.serialization.record.DataType;\nimport org.apache.nifi.serialization.record.Record;\nimport org.apache.nifi.serialization.record.RecordField;\nimport org.apache.nifi.serialization.record.RecordFieldType;\nimport org.apache.nifi.serialization.record.RecordSchema;\nimport org.apache.nifi.serialization.record.RecordSet;\nimport org.apache.nifi.ssl.RestrictedSSLContextService;\nimport org.apache.nifi.ssl.SSLContextService;\nimport org.eclipse.jetty.server.Server;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\n\n@Tags({\"record\", \"send\", \"write\", \"prometheus\"})\n@CapabilityDescription(\"Specifies a Record Sink Service that exposes data points to a Prometheus scraping service. Numeric fields are exposed as Gauges, String fields are the \"\n        + \"label values for the gauges, and all other fields are ignored.\")\n\npublic class PrometheusRecordSink extends AbstractControllerService implements RecordSinkService {\n\n    private volatile PrometheusServer prometheusServer;\n    private volatile RecordSchema recordSchema;\n    private volatile String[] labelNames;\n    private volatile Map<String, Gauge> gauges;\n    private static final CollectorRegistry RECORD_REGISTRY = new CollectorRegistry();\n\n    public static final PropertyDescriptor SSL_CONTEXT = new PropertyDescriptor.Builder()\n            .name(\"prometheus-reporting-task-ssl-context\")\n            .displayName(\"SSL Context Service\")\n            .description(\"The SSL Context Service to use in order to secure the server. If specified, the server will\"\n                    + \"accept only HTTPS requests; otherwise, the server will accept only HTTP requests\")\n            .required(false)\n            .identifiesControllerService(RestrictedSSLContextService.class)\n            .build();\n\n    private static final List<PropertyDescriptor> properties;\n\n    static {\n        List<PropertyDescriptor> props = new ArrayList<>();\n        props.add(PrometheusMetricsUtil.METRICS_ENDPOINT_PORT);\n        props.add(PrometheusMetricsUtil.INSTANCE_ID);\n        props.add(SSL_CONTEXT);\n        props.add(PrometheusMetricsUtil.CLIENT_AUTH);\n        properties = Collections.unmodifiableList(props);\n    }\n\n    @Override\n    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {\n        return properties;\n    }\n\n    @OnEnabled\n    public void onScheduled(final ConfigurationContext context) {\n        RECORD_REGISTRY.clear();\n        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT).asControllerService(SSLContextService.class);\n        final String metricsEndpointPort = context.getProperty(PrometheusMetricsUtil.METRICS_ENDPOINT_PORT).evaluateAttributeExpressions().getValue();\n\n        try {\n            List<Function<ReportingContext, CollectorRegistry>> metricsCollectors = new ArrayList<>();\n            if (sslContextService == null) {\n                prometheusServer = new PrometheusServer(new InetSocketAddress(Integer.parseInt(metricsEndpointPort)), getLogger());\n            } else {\n                final String clientAuthValue = context.getProperty(PrometheusMetricsUtil.CLIENT_AUTH).getValue();\n                final boolean need;\n                final boolean want;\n                if (PrometheusMetricsUtil.CLIENT_NEED.getValue().equals(clientAuthValue)) {\n                    need = true;\n                    want = false;\n                } else if (PrometheusMetricsUtil.CLIENT_WANT.getValue().equals(clientAuthValue)) {\n                    need = false;\n                    want = true;\n                } else {\n                    need = false;\n                    want = false;\n                }\n                prometheusServer = new PrometheusServer(Integer.parseInt(metricsEndpointPort), sslContextService, getLogger(), need, want);\n            }\n            Function<ReportingContext, CollectorRegistry> nifiMetrics = (reportingContext) -> RECORD_REGISTRY;\n            metricsCollectors.add(nifiMetrics);\n\n            prometheusServer.setMetricsCollectors(metricsCollectors);\n            getLogger().info(\"Started Jetty server\");\n        } catch (Exception e) {\n            // Don't allow this to finish successfully, onTrigger should not be called if the Jetty server wasn't started\n            throw new ProcessException(\"Failed to start Jetty server\", e);\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Sends data to a Prometheus Gauge.\n *\n * This method sends data from a RecordSet to a Prometheus Gauge. It first checks if the recordSchema is null,\n * in which case it creates the registry, registers the Gauges, and sets the label names. It then iterates over\n * each record in the RecordSet, setting the gauge values based on the record data. Finally, it updates the\n * attributes map with the record count and returns a WriteResult.\n *\n * @param recordSet The RecordSet containing the data to be sent.\n * @param attributes A map of attributes to be updated with the record count.\n * @param sendZeroResults A boolean indicating whether to send zero results.\n * @return A WriteResult containing the number of records sent and the updated attributes.\n * @throws IOException If an I/O error occurs.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic WriteResult sendData(RecordSet recordSet, Map<String, String> attributes, boolean sendZeroResults) throws IOException {\n    WriteResult writeResult = null;\n    if (recordSchema == null) {\n        // The first time through, create the registry, then create the Gauges and register them\n        recordSchema = recordSet.getSchema();\n        RECORD_REGISTRY.clear();\n\n        // String fields are labels, collect them first\n        labelNames = recordSchema.getFields().stream().filter(\n                (f) -> isLabel(f.getDataType().getFieldType())).map(RecordField::getFieldName).toArray(String[]::new);\n\n        gauges = new HashMap<>();\n        recordSchema.getFields().stream().filter((field) -> isNumeric(field.getDataType().getFieldType())).forEach(\n                // Create, register, and add gauge to the list\n                (field) -> gauges.put(field.getFieldName(), Gauge.build()\n                        .name(field.getFieldName())\n                        .help(\"Metric for \" + field.getFieldName())\n                        .labelNames(labelNames)\n                        .register(RECORD_REGISTRY))\n        );\n    }\n    int recordCount = 0;\n    Record r;\n    while ((r = recordSet.next()) != null) {\n        final Record record = r;\n        // Get label values, set empty strings for null values\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "sendData", "reference": "        String[] labelValues = Arrays.stream(labelNames).map((labelName) -> {\n            String value = record.getAsString(labelName);\n            return (value != null) ? value : \"\";\n        }).toArray(String[]::new);\n\n        // Get value for each gauge and update the data point\n\n        gauges.forEach((name, gauge) -> {\n            Optional<DataType> dataType = record.getSchema().getDataType(name);\n            if (dataType.isPresent()) {\n                RecordFieldType recordFieldType = dataType.get().getFieldType();\n                // Change boolean fields to doubles\n                final double value;\n                if (RecordFieldType.BOOLEAN.equals(recordFieldType)) {\n                    value = record.getAsBoolean(name) ? 1.0 : 0.0;\n                } else {\n                    value = record.getAsDouble(name);\n                }\n                gauge.labels(labelValues).set(value);\n            }\n        });\n        recordCount++;\n    }\n    attributes.put(\"record.count\", Integer.toString(recordCount));\n    writeResult = WriteResult.of(recordCount, attributes);\n    return writeResult;\n}", "completions": ["```Java\n        // Get label values, set empty strings for null values\n        List<String> labelValues = new ArrayList<>();\n        for (String labelName : labelNames) {\n            labelValues.add(record.getFieldValue(labelName).toString());\n        }\n        // Set label values\n        gauges.forEach((name, gauge) -> gauge.labels(labelValues.toArray(new String[0])).set(record.getFieldValue(name).asDouble()));\n        recordCount++;\n    }\n    // Update attributes\n    attributes.put(\"record_count\", String.valueOf(recordCount));\n    writeResult = new WriteResult(recordCount, attributes);\n    return writeResult;\n}\n```\n"]}
{"id": 58, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.harry.renthouse.service.auth.impl;\n\nimport com.aliyuncs.DefaultAcsClient;\nimport com.aliyuncs.IAcsClient;\nimport com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;\nimport com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;\nimport com.aliyuncs.exceptions.ClientException;\nimport com.aliyuncs.profile.DefaultProfile;\nimport com.google.gson.Gson;\nimport com.harry.renthouse.base.ApiResponseEnum;\nimport com.harry.renthouse.exception.BusinessException;\nimport com.harry.renthouse.property.ALiYunSmsProperty;\nimport com.harry.renthouse.service.auth.SmsCodeService;\nimport com.harry.renthouse.validate.code.SmsCodeGenerator;\nimport com.harry.renthouse.validate.code.ValidateCodeTypeEnum;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author Harry Xu\n * @date 2020/5/22 11:54\n */\n@Service\n@Slf4j\npublic class SmsCodeServiceImpl implements SmsCodeService {\n\n    @Resource\n    private ALiYunSmsProperty aLiYunSmsProperties;\n\n    @Resource\n    private SmsCodeGenerator smsCodeGenerator;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Resource\n    private Gson gson;\n\n    private static final int REDIS_SMS_CONTENT_KEY_EXPIRE = 60 * 15; // \u5185\u5bb9key15\u5206\u949f\u8fc7\u671f\n\n    private static final int REDIS_SMS_INTERVAL_KEY_EXPIRE = 60; // \u95f4\u9694key 1\u5206\u949f\u8fc7\u671f\n\n    private static final String SMS_CODE_INTERVAL_PREFIX = \"sms:code:interval:\";\n    private static final String SMS_CODE_CONTENT_PREFIX = \"sms:code:content:\";\n\n    @Override\n    public String sendSms(String phone, String operationType) {\n        String intervalKey = SMS_CODE_INTERVAL_PREFIX + generateSmsKey(phone, operationType);\n        if(stringRedisTemplate.opsForValue().get(intervalKey) != null){\n            throw new BusinessException(ApiResponseEnum.PHONE_SEND_SMS_BUSY);\n        }\n        String contentKey = SMS_CODE_CONTENT_PREFIX + generateSmsKey(phone, operationType);\n        String code = RandomStringUtils.randomNumeric(aLiYunSmsProperties.getLength());\n        aliSendSms(phone, code);\n        log.debug(\"\u9a8c\u8bc1\u7801:{}\", code);\n        stringRedisTemplate.opsForValue().set(contentKey, code, REDIS_SMS_CONTENT_KEY_EXPIRE, TimeUnit.SECONDS);\n        stringRedisTemplate.opsForValue().set(intervalKey, code, REDIS_SMS_INTERVAL_KEY_EXPIRE, TimeUnit.SECONDS);\n        return code;\n    }\n    @Override\n    public String getSmsCode(String phone, String operationType) {\n        String contentKey = SMS_CODE_CONTENT_PREFIX + generateSmsKey(phone, operationType);\n        return stringRedisTemplate.opsForValue().get(contentKey);\n    }\n\n    public void deleteSmsCode(String phone, String operationType){\n        stringRedisTemplate.delete(SMS_CODE_CONTENT_PREFIX + generateSmsKey(phone, operationType));\n    }\n\n    private String generateSmsKey(String phone, String type){\n        ValidateCodeTypeEnum validateCodeTypeEnum = ValidateCodeTypeEnum.fromValue(type).orElseThrow(() -> new BusinessException(ApiResponseEnum.PHONE_SMS_NOT_VALID_TYPE));\n        return validateCodeTypeEnum.getValue() + \":\" + phone;\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Sends an SMS message using the Aliyun SMS service.\n *\n * @param phone The phone number to send the SMS to.\n * @param code The verification code to include in the SMS message.\n * @throws BusinessException If the SMS sending fails or if there is a client exception.\n */\n```\n\n### Code snippet:\n```Java\npublic void aliSendSms(String phone, String code){\n    try{\n        DefaultProfile profile = DefaultProfile.getProfile(\"cn-hangzhou\", aLiYunSmsProperties.getAccessKey(), aLiYunSmsProperties.getAccessSecret());\n        IAcsClient client = new DefaultAcsClient(profile);\n        //\u7ec4\u88c5\u8bf7\u6c42\u5bf9\u8c61-\u5177\u4f53\u63cf\u8ff0\u89c1\u63a7\u5236\u53f0-\u6587\u6863\u90e8\u5206\u5185\u5bb9\n        SendSmsRequest request = new SendSmsRequest();\n        //\u5fc5\u586b:\u5f85\u53d1\u9001\u624b\u673a\u53f7\n        request.setPhoneNumbers(phone);\n        //\u5fc5\u586b:\u77ed\u4fe1\u7b7e\u540d-\u53ef\u5728\u77ed\u4fe1\u63a7\u5236\u53f0\u4e2d\u627e\u5230\n        request.setSignName(aLiYunSmsProperties.getSignName());\n        //\u5fc5\u586b:\u77ed\u4fe1\u6a21\u677f-\u53ef\u5728\u77ed\u4fe1\u63a7\u5236\u53f0\u4e2d\u627e\u5230\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "aliSendSms", "reference": "        request.setTemplateCode(aLiYunSmsProperties.getTemplateCode());\n        request.setTemplateParam(\"{\\\"code\\\":\\\"\" + code + \"\\\"}\");\n        SendSmsResponse acsResponse = client.getAcsResponse(request);\n        if(!StringUtils.equalsIgnoreCase(acsResponse.getCode(), \"OK\")){\n            log.warn(\"\u53d1\u9001\u77ed\u4fe1\u5931\u8d25: {}\", acsResponse.getMessage());\n            throw new BusinessException(ApiResponseEnum.PHONE_SEND_SMS_ERROR);\n        }\n    }catch (ClientException e){\n        log.error(\"\u77ed\u4fe1\u5ba2\u6237\u7aef\u5f02\u5e38:\", e);\n        throw new BusinessException(ApiResponseEnum.PHONE_SEND_SMS_ERROR);\n    }\n}", "completions": ["```Java\n        request.setTemplateCode(aLiYunSmsProperties.getTemplateCode());\n        //\u53ef\u9009:\u4e0a\u884c\u77ed\u4fe1\u81ea\u52a8\u53d1\u9001\u65f6\u95f4\uff0c\u53d6\u503c\u8303\u56f4[10, 180]\uff0c\u5355\u4f4d\u4e3a\u5206\u949f\u3002\n        request.setSmsUpExtendParam(\"10,180\");\n        //\u53ef\u9009:\u4e0a\u884c\u77ed\u4fe1\u56de\u4f20\u9009\u9879\uff0c\u53d6\u503c\u8303\u56f4[0,10]\uff0c0\u8868\u793a\u4e0d\u56de\u4f20\uff0c10\u8868\u793a\u56de\u4f20\u6210\u529f\u540e\u5c06\u56de\u4f20\u72b6\u6001\u62a5\u544a\u7ed9\u5ba2\u6237\u7aef\n        request.setSmsUpReturnParam(\"0\");\n        //\u53d1\u9001\u77ed\u4fe1\u5e76\u8fd4\u56de\u7ed3\u679c\n        SendSmsResponse response = client.getAcsResponse(request);\n        if(response.getCode() != null && response.getCode().equals(\"OK\")){\n            log.debug(\"SMS send successfully\");\n        }else{\n            log.error(\"SMS send failed, error message: {}\", response.getMsgId());\n            throw new BusinessException(ApiResponseEnum.PHONE_SEND_SMS_FAIL);\n        }\n    }catch(ClientException e){\n        log.error(\"ClientException: {}\", e.getMessage());\n        throw new BusinessException(ApiResponseEnum.PHONE_SEND_SMS_FAIL);\n    }\n}\n```\n"]}
{"id": 59, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.osm2world.core.math.algorithms;\n\nimport static java.lang.Double.NaN;\nimport static org.osm2world.core.math.GeometryUtil.getTrueLineSegmentIntersection;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.function.Function;\n\nimport javax.annotation.Nullable;\n\nimport org.osm2world.core.math.LineSegmentXZ;\nimport org.osm2world.core.math.VectorXZ;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Multimap;\n\n/**\n * Takes a set of line segments, and detects all intersections between them.\n * Uses a sweepline algorithm that sweeps in positive x direction (left to right).\n */\npublic final class LineSegmentIntersectionFinder {\n\n\t/** prevents instantiation */\n\tprivate LineSegmentIntersectionFinder() {}\n\n\t/** an intersection detected by the finder */\n\tpublic static class Intersection<E> {\n\n\t\tpublic final VectorXZ pos;\n\t\tpublic final E segmentA;\n\t\tpublic final E segmentB;\n\n\t\tpublic Intersection(VectorXZ pos, E segmentA, E segmentB) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.segmentA = segmentA;\n\t\t\tthis.segmentB = segmentB;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + ((pos == null) ? 0 : pos.hashCode());\n\t\t\tresult = prime * result + ((segmentA == null) ? 0 : segmentA.hashCode());\n\t\t\tresult = prime * result + ((segmentB == null) ? 0 : segmentB.hashCode());\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tIntersection<?> other = (Intersection<?>) obj;\n\t\t\tif (pos == null) {\n\t\t\t\tif (other.pos != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!pos.equals(other.pos))\n\t\t\t\treturn false;\n\t\t\tif (segmentA == null) {\n\t\t\t\tif (other.segmentA != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!segmentA.equals(other.segmentA))\n\t\t\t\treturn false;\n\t\t\tif (segmentB == null) {\n\t\t\t\tif (other.segmentB != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!segmentB.equals(other.segmentB))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn pos.toString();\n\t\t}\n\n\t}\n\n\t/**\n\t * finds all intersections in a set of line segments.\n\t * Only reports true intersections, not shared start or end points.\n\t *\n\t * Limitations: Does not work if three or more segments intersect in the same location.\n\t */\n\tpublic static final List<Intersection<LineSegmentXZ>> findAllIntersections(Iterable<? extends LineSegmentXZ> segments) {\n\t\treturn findAllIntersections(segments, Function.identity());\n\t}\n\n\t/**\n\t * a more flexible alternative to {@link #findAllIntersections(Iterable)}\n\t * @param <S>  the segment type, does not need to be {@link LineSegmentXZ}\n\t * @param toLineSegmentXZ  how to get from S to {@link LineSegmentXZ}\n\t */\n```\n\n### Code description\n```Java\n/**\n * Description: This method finds all intersections between a collection of segments.\n * It uses a provided function to convert segments to LineSegmentXZ objects, and then\n * finds all intersections between these segments. The method returns a list of Intersection\n * objects, where each Intersection contains the position of the intersection and the two\n * segments that intersect at that position.\n *\n * @param segments An Iterable of segments to find intersections for.\n * @param toLineSegmentXZ A Function that converts segments to LineSegmentXZ objects.\n * @return A List of Intersection objects, where each Intersection contains the position\n *         of the intersection and the two segments that intersect at that position.\n */\n```\n\n### Code snippet:\n```Java\npublic static final <S> List<Intersection<S>> findAllIntersections(Iterable<? extends S> segments,\n\t\tFunction<S, LineSegmentXZ> toLineSegmentXZ) {\n\n\tMultimap<OrderedSegment, S> originalSegmentsMap = HashMultimap.create();\n\tSet<OrderedSegment> orderedSegments = new HashSet<>();\n\n\tfor (S s : segments) {\n\t\tOrderedSegment orderedSegment = OrderedSegment.from(toLineSegmentXZ.apply(s));\n\t\toriginalSegmentsMap.put(orderedSegment, s);\n\t\torderedSegments.add(orderedSegment);\n\t}\n\n\tList<Intersection<OrderedSegment>> rawResult = findAllIntersections_impl(orderedSegments);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "findAllIntersections", "reference": "\n\tList<Intersection<S>> result = new ArrayList<>(rawResult.size());\n\n\tfor (Intersection<OrderedSegment> intersection : rawResult) {\n\t\tfor (S segmentA : originalSegmentsMap.get(intersection.segmentA)) {\n\t\t\tfor (S segmentB : originalSegmentsMap.get(intersection.segmentB)) {\n\t\t\t\tresult.add(new Intersection<S>(intersection.pos, segmentA, segmentB));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n\n}", "completions": ["```Java\n}\n\nprivate static final <E> List<Intersection<E>> findAllIntersections_impl(Set<E> orderedSegments) {\n\tList<Intersection<E>> result = new ArrayList<>();\n\tPriorityQueue<Intersection<E>> queue = new PriorityQueue<>(Comparator.comparing(Intersection::getX));\n\n\tfor (E e : orderedSegments) {\n\t\tList<Intersection<E>> intersections = getIntersections(e, orderedSegments);\n\t\tqueue.addAll(intersections);\n\t}\n\n\twhile (!queue.isEmpty()) {\n\t\tresult.add(queue.poll());\n\t}\n\n\treturn result;\n}\n\nprivate static final <E> List<Intersection<E>> getIntersections(E e, Set<E> orderedSegments) {\n\tList<Intersection<E>> intersections = new ArrayList<>();\n\n\tfor (E other : orderedSegments) {\n\t\tif (e.equals(other)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tLineSegmentXZ lineSegmentXZ = (LineSegmentXZ) e;\n\t\tLineSegmentXZ otherLineSegmentXZ = (LineSegmentXZ) other;\n\n\t\tVectorXZ intersection = getTrueLineSegmentIntersection(lineSegmentXZ, otherLineSegmentXZ);\n\t\tif (intersection != null) {\n\t\t\tintersections.add(new Intersection<>(intersection, e, other));\n\t\t}\n\t}\n\n\treturn intersections;\n}\n```\n"]}
{"id": 60, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.common.utils.UrlUtils;\nimport org.apache.dubbo.rpc.Exporter;\nimport org.apache.dubbo.rpc.ExporterListener;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.InvokerListener;\nimport org.apache.dubbo.rpc.Protocol;\nimport org.apache.dubbo.rpc.ProtocolServer;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.listener.ListenerExporterWrapper;\nimport org.apache.dubbo.rpc.listener.ListenerInvokerWrapper;\nimport org.apache.dubbo.rpc.model.ScopeModelUtil;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.EXPORTER_LISTENER_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;\nimport static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_CLUSTER_TYPE_KEY;\n\n/**\n * ListenerProtocol\n */\n@Activate(order = 200)\npublic class ProtocolListenerWrapper implements Protocol {\n\n    private final Protocol protocol;\n\n    public ProtocolListenerWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n\n    @Override\n    public int getDefaultPort() {\n        return protocol.getDefaultPort();\n    }\n\n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (UrlUtils.isRegistry(invoker.getUrl())) {\n            return protocol.export(invoker);\n        }\n        return new ListenerExporterWrapper<T>(protocol.export(invoker),\n                Collections.unmodifiableList(ScopeModelUtil.getExtensionLoader(ExporterListener.class, invoker.getUrl().getScopeModel())\n                        .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Refers to a service of the specified type and URL.\n * If the URL is a registry, it refers to the service directly.\n * Otherwise, it refers to the service and wraps it with a ListenerInvokerWrapper.\n * The ListenerInvokerWrapper is created with a list of InvokerListeners activated for the scope model of the URL.\n *\n * @param <T> The type of the service to refer to.\n * @param type The class of the service to refer to.\n * @param url The URL of the service to refer to.\n * @return An Invoker for the referred service.\n * @throws RpcException If an error occurs while referring to the service.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    if (UrlUtils.isRegistry(url)) {\n        return protocol.refer(type, url);\n    }\n\n    Invoker<T> invoker = protocol.refer(type, url);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "refer", "reference": "    if (StringUtils.isEmpty(url.getParameter(REGISTRY_CLUSTER_TYPE_KEY))) {\n        invoker = new ListenerInvokerWrapper<>(invoker,\n                Collections.unmodifiableList(\n                    ScopeModelUtil.getExtensionLoader(InvokerListener.class, invoker.getUrl().getScopeModel())\n                                .getActivateExtension(url, INVOKER_LISTENER_KEY)));\n    }\n    return invoker;\n}", "completions": ["```Java\n    return new ListenerInvokerWrapper<T>(invoker,\n            Collections.unmodifiableList(ScopeModelUtil.getExtensionLoader(InvokerListener.class, url.getScopeModel())\n                    .getActivateExtension(url, INVOKER_LISTENER_KEY)));\n}\n```\n"]}
{"id": 61, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.filter;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.rpc.Filter;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.RpcStatus;\n\nimport static org.apache.dubbo.rpc.Constants.EXECUTES_KEY;\n\n\n/**\n * The maximum parallel execution request count per method per service for the provider.If the max configured\n * <b>executes</b> is set to 10 and if invoke request where it is already 10 then it will throws exception. It\n * continue the same behaviour un till it is <10.\n */\n@Activate(group = CommonConstants.PROVIDER, value = EXECUTES_KEY)\npublic class ExecuteLimitFilter implements Filter, Filter.Listener {\n\n    private static final String EXECUTE_LIMIT_FILTER_START_TIME = \"execute_limit_filter_start_time\";\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method is used to invoke a method on a Dubbo invoker. It checks the maximum number of executions allowed for a method and starts the execution count if it is within the limit. If the limit is exceeded, it throws an RpcException.\n *\n * @param invoker The Dubbo invoker to invoke the method on.\n * @param invocation The invocation object containing the method name and parameters.\n * @return The result of the invocation.\n * @throws RpcException If the execution limit is exceeded or if there is an unexpected exception during invocation.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n    URL url = invoker.getUrl();\n    String methodName = invocation.getMethodName();\n    int max = url.getMethodParameter(methodName, EXECUTES_KEY, 0);\n    if (!RpcStatus.beginCount(url, methodName, max)) {\n        throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,\n                \"Failed to invoke method \" + invocation.getMethodName() + \" in provider \" +\n                        url + \", cause: The service using threads greater than <dubbo:service executes=\\\"\" + max +\n                        \"\\\" /> limited.\");\n    }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "invoke", "reference": "\n    invocation.put(EXECUTE_LIMIT_FILTER_START_TIME, System.currentTimeMillis());\n    try {\n        return invoker.invoke(invocation);\n    } catch (Throwable t) {\n        if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n        } else {\n            throw new RpcException(\"unexpected exception when ExecuteLimitFilter\", t);\n        }\n    }\n}", "completions": ["```Java\n```Java\n@Override\npublic Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n    URL url = invoker.getUrl();\n    String methodName = invocation.getMethodName();\n    int max = url.getMethodParameter(methodName, EXECUTES_KEY, 0);\n    if (!RpcStatus.beginCount(url, methodName, max)) {\n        throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,\n                \"Failed to invoke method \" + invocation.getMethodName() + \" in provider \" +\n                        url + \", cause: The service using threads greater than <dubbo:service executes=\\\"\" + max +\n                        \"\\\" /> limited.\");\n    }\n    Result result = invoker.invoke(invocation);\n    RpcStatus.endCount(url, methodName);\n    return result;\n}\n```\n```\n"]}
{"id": 62, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2016-2020 the original author or authors from the JHipster project.\n *\n * This file is part of the JHipster project, see https://www.jhipster.tech/\n * for more information.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.github.jhipster.config.apidoc;\n\nimport io.github.jhipster.config.JHipsterProperties;\nimport io.github.jhipster.config.apidoc.customizer.JHipsterSwaggerCustomizer;\nimport io.github.jhipster.config.apidoc.customizer.SwaggerCustomizer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.condition.*;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.util.StopWatch;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;\nimport springfox.documentation.schema.AlternateTypeRule;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\nimport javax.servlet.Servlet;\nimport java.nio.ByteBuffer;\nimport java.util.*;\n\nimport static io.github.jhipster.config.JHipsterConstants.SPRING_PROFILE_SWAGGER;\nimport static springfox.documentation.builders.PathSelectors.regex;\n\n/**\n * Springfox Swagger configuration.\n * <p>\n * Warning! When having a lot of REST endpoints, Springfox can become a performance issue.\n * In that case, you can use the \"no-swagger\" Spring profile, so that this bean is ignored.\n */\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({\n    ApiInfo.class,\n    BeanValidatorPluginsConfiguration.class,\n    Servlet.class,\n    DispatcherServlet.class,\n    Docket.class\n})\n@Profile(SPRING_PROFILE_SWAGGER)\n@AutoConfigureAfter(JHipsterProperties.class)\n@EnableSwagger2\n@Import(BeanValidatorPluginsConfiguration.class)\npublic class SwaggerAutoConfiguration {\n\n    static final String STARTING_MESSAGE = \"Starting Swagger\";\n    static final String STARTED_MESSAGE = \"Started Swagger in {} ms\";\n    static final String MANAGEMENT_TITLE_SUFFIX = \"Management API\";\n    static final String MANAGEMENT_GROUP_NAME = \"management\";\n    static final String MANAGEMENT_DESCRIPTION = \"Management endpoints documentation\";\n\n    private final Logger log = LoggerFactory.getLogger(SwaggerAutoConfiguration.class);\n\n    private final JHipsterProperties.Swagger properties;\n\n    /**\n     * <p>Constructor for SwaggerAutoConfiguration.</p>\n     *\n     * @param jHipsterProperties a {@link io.github.jhipster.config.JHipsterProperties} object.\n     */\n    public SwaggerAutoConfiguration(JHipsterProperties jHipsterProperties) {\n        this.properties = jHipsterProperties.getSwagger();\n    }\n\n    /**\n     * Springfox configuration for the API Swagger docs.\n     *\n     * @param swaggerCustomizers Swagger customizers\n     * @param alternateTypeRules alternate type rules\n     * @return the Swagger Springfox configuration\n     */\n    @Bean\n    @ConditionalOnMissingBean(name = \"swaggerSpringfoxApiDocket\")\n    public Docket swaggerSpringfoxApiDocket(List<SwaggerCustomizer> swaggerCustomizers,\n                                            ObjectProvider<AlternateTypeRule[]> alternateTypeRules) {\n        log.debug(STARTING_MESSAGE);\n        StopWatch watch = new StopWatch();\n        watch.start();\n\n        Docket docket = createDocket();\n\n        // Apply all SwaggerCustomizers orderly.\n        swaggerCustomizers.forEach(customizer -> customizer.customize(docket));\n\n        // Add all AlternateTypeRules if available in spring bean factory.\n        // Also you can add your rules in a customizer bean above.\n        Optional.ofNullable(alternateTypeRules.getIfAvailable()).ifPresent(docket::alternateTypeRules);\n\n        watch.stop();\n        log.debug(STARTED_MESSAGE, watch.getTotalTimeMillis());\n        return docket;\n    }\n\n    /**\n     * JHipster Swagger Customizer\n     *\n     * @return the Swagger Customizer of JHipster\n     */\n    @Bean\n    public JHipsterSwaggerCustomizer jHipsterSwaggerCustomizer() {\n        return new JHipsterSwaggerCustomizer(properties);\n    }\n\n    /**\n     * Springfox configuration for the management endpoints (actuator) Swagger docs.\n     *\n     * @param appName               the application name\n     * @param managementContextPath the path to access management endpoints\n     * @return the Swagger Springfox configuration\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method creates a Docket bean for Swagger configuration, specifically for management endpoints.\n * It uses the Spring Boot Actuator's ManagementServerProperties to conditionally create the bean.\n * The bean is created only if the 'org.springframework.boot.actuate.autoconfigure.web.server.ManagementServerProperties' class is present,\n * and if the 'management.endpoints.web.base-path' property is set and its length is greater than 0.\n * It also ensures that a bean with the name 'swaggerSpringfoxManagementDocket' is not already present.\n *\n * @param appName The name of the application. If not provided, defaults to 'application'.\n * @param managementContextPath The base path for management endpoints.\n * @return A Docket bean configured for Swagger, specifically for management endpoints.\n */\n```\n\n### Code snippet:\n```Java\n@Bean\n@ConditionalOnClass(name = \"org.springframework.boot.actuate.autoconfigure.web.server.ManagementServerProperties\")\n@ConditionalOnProperty(\"management.endpoints.web.base-path\")\n@ConditionalOnExpression(\"'${management.endpoints.web.base-path}'.length() > 0\")\n@ConditionalOnMissingBean(name = \"swaggerSpringfoxManagementDocket\")\npublic Docket swaggerSpringfoxManagementDocket(@Value(\"${spring.application.name:application}\") String appName,\n                                               @Value(\"${management.endpoints.web.base-path}\") String managementContextPath) {\n\n    ApiInfo apiInfo = new ApiInfo(\n        StringUtils.capitalize(appName) + \" \" + MANAGEMENT_TITLE_SUFFIX,\n        MANAGEMENT_DESCRIPTION,\n        properties.getVersion(),\n        \"\",\n        ApiInfo.DEFAULT_CONTACT,\n        \"\",\n        \"\",\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "swaggerSpringfoxManagementDocket", "reference": "        new ArrayList<>()\n    );\n\n    return createDocket()\n        .apiInfo(apiInfo)\n        .useDefaultResponseMessages(properties.isUseDefaultResponseMessages())\n        .groupName(MANAGEMENT_GROUP_NAME)\n        .host(properties.getHost())\n        .protocols(new HashSet<>(Arrays.asList(properties.getProtocols())))\n        .forCodeGeneration(true)\n        .directModelSubstitute(ByteBuffer.class, String.class)\n        .genericModelSubstitutes(ResponseEntity.class)\n        .ignoredParameterTypes(Pageable.class)\n        .select()\n        .paths(regex(managementContextPath + \".*\"))\n        .build();\n}", "completions": ["```Java\n```Java\n    ApiInfo.DEFAULT_CONTACT,\n        \"\",\n        \"\",\n        \"\",\n        new Contact(\"\", \"\", \"\"),\n        \"\",\n        \"\",\n        new ArrayList<>()\n    );\n\n    return new Docket(DocumentationType.SWAGGER_2)\n        .apiInfo(apiInfo)\n        .pathMapping(managementContextPath)\n        .select()\n        .paths(PathSelectors.regex(\"/management.*\"))\n        .build()\n        .apiInfo(apiInfo)\n        .useDefaultResponseMessages(false)\n        .forCodeGeneration(true);\n}\n```\n"]}
{"id": 63, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.mahout.cf.taste.impl.common;\n\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.mahout.common.RandomUtils;\n\nimport com.google.common.base.Preconditions;\n\n/**\n * <p>\n * This is an optimized {@link Map} implementation, based on algorithms described in Knuth's \"Art of Computer\n * Programming\", Vol. 3, p. 529.\n * </p>\n *\n * <p>\n * It should be faster than {@link java.util.HashMap} in some cases, but not all. Its main feature is a\n * \"max size\" and the ability to transparently, efficiently and semi-intelligently evict old entries when max\n * size is exceeded.\n * </p>\n *\n * <p>\n * This class is not a bit thread-safe.\n * </p>\n *\n * <p>\n * This implementation does not allow {@code null} as a key or value.\n * </p>\n */\npublic final class FastMap<K,V> implements Map<K,V>, Serializable, Cloneable {\n  \n  public static final int NO_MAX_SIZE = Integer.MAX_VALUE;\n  private static final float DEFAULT_LOAD_FACTOR = 1.5f;\n  \n  /** Dummy object used to represent a key that has been removed. */\n  private static final Object REMOVED = new Object();\n  \n  private K[] keys;\n  private V[] values;\n  private float loadFactor;\n  private int numEntries;\n  private int numSlotsUsed;\n  private final int maxSize;\n  private BitSet recentlyAccessed;\n  private final boolean countingAccesses;\n  \n  /** Creates a new {@link FastMap} with default capacity. */\n  public FastMap() {\n    this(2, NO_MAX_SIZE);\n  }\n  \n  public FastMap(int size) {\n    this(size, NO_MAX_SIZE);\n  }\n  \n  public FastMap(Map<K,V> other) {\n    this(other.size());\n    putAll(other);\n  }\n\n  public FastMap(int size, float loadFactor) {\n    this(size, NO_MAX_SIZE, loadFactor);\n  }\n\n  public FastMap(int size, int maxSize) {\n    this(size, maxSize, DEFAULT_LOAD_FACTOR);\n  }\n  \n  /**\n   * Creates a new  whose capacity can accommodate the given number of entries without rehash.\n   * \n   * @param size desired capacity\n   * @param maxSize max capacity\n   * @throws IllegalArgumentException if size is less than 0, maxSize is less than 1\n   *  or at least half of {@link RandomUtils#MAX_INT_SMALLER_TWIN_PRIME}, or\n   *  loadFactor is less than 1\n   */\n  public FastMap(int size, int maxSize, float loadFactor) {\n    Preconditions.checkArgument(size >= 0, \"size must be at least 0\");\n    Preconditions.checkArgument(loadFactor >= 1.0f, \"loadFactor must be at least 1.0\");\n    this.loadFactor = loadFactor;\n    int max = (int) (RandomUtils.MAX_INT_SMALLER_TWIN_PRIME / loadFactor);\n    Preconditions.checkArgument(size < max, \"size must be less than \" + max);\n    Preconditions.checkArgument(maxSize >= 1, \"maxSize must be at least 1\");\n    int hashSize = RandomUtils.nextTwinPrime((int) (loadFactor * size));\n    keys = (K[]) new Object[hashSize];\n    values = (V[]) new Object[hashSize];\n    this.maxSize = maxSize;\n    this.countingAccesses = maxSize != Integer.MAX_VALUE;\n    this.recentlyAccessed = countingAccesses ? new BitSet(hashSize) : null;\n  }\n  \n  private int find(Object key) {\n    int theHashCode = key.hashCode() & 0x7FFFFFFF; // make sure it's positive\n    K[] keys = this.keys;\n    int hashSize = keys.length;\n    int jump = 1 + theHashCode % (hashSize - 2);\n    int index = theHashCode % hashSize;\n    K currentKey = keys[index];\n    while (currentKey != null && !key.equals(currentKey)) {\n      index -= index < jump ? jump - hashSize : jump;\n      currentKey = keys[index];\n    }\n    return index;\n  }\n\n  private int findForAdd(Object key) {\n    int theHashCode = key.hashCode() & 0x7FFFFFFF; // make sure it's positive\n    K[] keys = this.keys;\n    int hashSize = keys.length;\n    int jump = 1 + theHashCode % (hashSize - 2);\n    int index = theHashCode % hashSize;\n    K currentKey = keys[index];\n    while (currentKey != null && currentKey != REMOVED && key != currentKey) {\n      index -= index < jump ? jump - hashSize : jump;\n      currentKey = keys[index];\n    }\n    if (currentKey != REMOVED) {\n      return index;\n    }\n    // If we're adding, it's here, but, the key might have a value already later\n    int addIndex = index;\n    while (currentKey != null && key != currentKey) {\n      index -= index < jump ? jump - hashSize : jump;\n      currentKey = keys[index];\n    }\n    return key == currentKey ? index : addIndex;\n  }\n  \n  @Override\n  public V get(Object key) {\n    if (key == null) {\n      return null;\n    }\n    int index = find(key);\n    if (countingAccesses) {\n      recentlyAccessed.set(index);\n    }\n    return values[index];\n  }\n  \n  @Override\n  public int size() {\n    return numEntries;\n  }\n  \n  @Override\n  public boolean isEmpty() {\n    return numEntries == 0;\n  }\n  \n  @Override\n  public boolean containsKey(Object key) {\n    return key != null && keys[find(key)] != null;\n  }\n  \n  @Override\n  public boolean containsValue(Object value) {\n    if (value == null) {\n      return false;\n    }\n    for (V theValue : values) {\n      if (theValue != null && value.equals(theValue)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  /**\n   * @throws NullPointerException\n   *           if key or value is null\n   */\n```\n\n### Code description\n```Java\n/**\n * Description: This method is used to put a key-value pair into the map. It first checks if the key and value are not null. If the number of slots used is less than half the length of the keys array, it will clear up the slots. If the number of entries is more than half the number of slots used, it will grow and rehash the map. If the number of entries is less than half the number of slots used, it will just rehash the map. It then finds the index for adding the key and if the key already exists, it updates the value and returns the old value. If the map is limited in size and the number of entries is greater than or equal to the maximum size, it will clear a stale entry. Finally, it adds the key and value to the map, increments the number of entries and slots used, and returns null.\n * \n * @param key The key to be added to the map.\n * @param value The value to be added to the map.\n * @return The old value associated with the key, or null if the key was not already in the map.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic V put(K key, V value) {\n  Preconditions.checkNotNull(key);\n  Preconditions.checkNotNull(value);\n  // If less than half the slots are open, let's clear it up\n  if (numSlotsUsed * loadFactor >= keys.length) {\n    // If over half the slots used are actual entries, let's grow\n    if (numEntries * loadFactor >= numSlotsUsed) {\n      growAndRehash();\n    } else {\n      // Otherwise just rehash to clear REMOVED entries and don't grow\n      rehash();\n    }\n  }\n  // Here we may later consider implementing Brent's variation described on page 532\n  int index = findForAdd(key);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "put", "reference": "  if (keys[index] == key) {\n    V oldValue = values[index];\n    values[index] = value;\n    return oldValue;\n  }\n  // If size is limited,\n  if (countingAccesses && numEntries >= maxSize) {\n    // and we're too large, clear some old-ish entry\n    clearStaleEntry(index);\n  }\n  keys[index] = key;\n  values[index] = value;\n  numEntries++;\n  numSlotsUsed++;\n  return null;\n}", "completions": ["```Java\n@Override\npublic V put(K key, V value) {\n  Preconditions.checkNotNull(key);\n  Preconditions.checkNotNull(value);\n  // If less than half the slots are open, let's clear it up\n  if (numSlotsUsed * loadFactor >= keys.length) {\n    // If over half the slots used are actual entries, let's grow\n    if (numEntries * loadFactor >= numSlotsUsed) {\n      growAndRehash();\n    } else {\n      // Otherwise just rehash to clear REMOVED entries and don't grow\n      rehash();\n    }\n  }\n  // Here we may later consider implementing Brent's variation described on page 532\n  int index = findForAdd(key);\n  if (index != -1) {\n    V oldValue = values[index];\n    values[index] = value;\n    return oldValue;\n  }\n  return null;\n}\n```\n"]}
{"id": 64, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.facebook.presto.execution;\n\nimport com.facebook.presto.spi.PrestoException;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport io.airlift.log.Logger;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.concurrent.GuardedBy;\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Predicate;\n\nimport static com.facebook.presto.spi.StandardErrorCode.SERVER_SHUTTING_DOWN;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.util.concurrent.Futures.immediateFuture;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Simple state machine which holds a single state. Callers can register for state change events.\n */\n@ThreadSafe\npublic class StateMachine<T>\n{\n    private static final Logger log = Logger.get(StateMachine.class);\n\n    private final String name;\n    private final Executor executor;\n    private final Object lock = new Object();\n    private final Set<T> terminalStates;\n\n    @GuardedBy(\"lock\")\n    private volatile T state;\n\n    @GuardedBy(\"lock\")\n    private final List<StateChangeListener<T>> stateChangeListeners = new ArrayList<>();\n\n    private final AtomicReference<FutureStateChange<T>> futureStateChange = new AtomicReference<>(new FutureStateChange<>());\n\n    /**\n     * Creates a state machine with the specified initial state and no terminal states.\n     *\n     * @param name name of this state machine to use in debug statements\n     * @param executor executor for firing state change events; must not be a same thread executor\n     * @param initialState the initial state\n     */\n    public StateMachine(String name, Executor executor, T initialState)\n    {\n        this(name, executor, initialState, ImmutableSet.of());\n    }\n\n    /**\n     * Creates a state machine with the specified initial state and terminal states.\n     *\n     * @param name name of this state machine to use in debug statements\n     * @param executor executor for firing state change events; must not be a same thread executor\n     * @param initialState the initial state\n     * @param terminalStates the terminal states\n     */\n    public StateMachine(String name, Executor executor, T initialState, Iterable<T> terminalStates)\n    {\n        this.name = requireNonNull(name, \"name is null\");\n        this.executor = requireNonNull(executor, \"executor is null\");\n        this.state = requireNonNull(initialState, \"initialState is null\");\n        this.terminalStates = ImmutableSet.copyOf(requireNonNull(terminalStates, \"terminalStates is null\"));\n    }\n\n    @Nonnull\n    public T get()\n    {\n        return state;\n    }\n\n    /**\n     * Sets the state.\n     * If the new state does not {@code .equals()} the current state, listeners and waiters will be notified.\n     *\n     * @return the old state\n     */\n```\n\n### Code description\n```Java\n/**\n * Sets the state of the object to the new state.\n *\n * @param newState The new state to be set.\n * @return The old state of the object.\n * @throws IllegalStateException If the current thread holds the lock or if the new state is null.\n * @throws IllegalArgumentException If the state transition from the current state to the new state is not allowed.\n */\n```\n\n### Code snippet:\n```Java\n@Nonnull\npublic T set(T newState)\n{\n    checkState(!Thread.holdsLock(lock), \"Can not set state while holding the lock\");\n    requireNonNull(newState, \"newState is null\");\n\n    T oldState;\n    FutureStateChange<T> futureStateChange;\n    ImmutableList<StateChangeListener<T>> stateChangeListeners;\n    synchronized (lock) {\n        if (state.equals(newState)) {\n            return state;\n        }\n\n        checkState(!isTerminalState(state), \"%s can not transition from %s to %s\", name, state, newState);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "set", "reference": "\n        oldState = state;\n        state = newState;\n\n        futureStateChange = this.futureStateChange.getAndSet(new FutureStateChange<>());\n        stateChangeListeners = ImmutableList.copyOf(this.stateChangeListeners);\n\n        // if we are now in a terminal state, free the listeners since this will be the last notification\n        if (isTerminalState(state)) {\n            this.stateChangeListeners.clear();\n        }\n    }\n\n    fireStateChanged(newState, futureStateChange, stateChangeListeners);\n    return oldState;\n}", "completions": ["```Java\n        oldState = state;\n        futureStateChange = new FutureStateChange<>(oldState, newState, executor);\n        stateChangeListeners = ImmutableList.copyOf(this.stateChangeListeners);\n    }\n\n    for (StateChangeListener<T> listener : stateChangeListeners) {\n        listener.stateChanged(this, oldState, newState);\n    }\n\n    return oldState;\n}\n\nprivate boolean isTerminalState(T state)\n{\n    return terminalStates.contains(state);\n}\n\nprivate static class FutureStateChange<T>\n{\n    private final T oldState;\n    private final T newState;\n    private final Executor executor;\n    private final ListenableFuture<T> future;\n\n    FutureStateChange(T oldState, T newState, Executor executor)\n    {\n        this.oldState = oldState;\n        this.newState = newState;\n        this.executor = executor;\n        this.future = immediateFuture(newState, executor);\n    }\n\n    public T get()\n    {\n        try {\n            return future.get();\n        }\n        catch (RejectedExecutionException e) {\n            throw new PrestoException(SERVER_SHUTTING_DOWN, \"Cannot transition from %s to %s\", oldState, newState);\n        }\n    }\n}\n```\n"]}
{"id": 65, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/* Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.flowable.spring.security;\n\nimport java.security.Principal;\n\nimport org.flowable.common.engine.api.identity.AuthenticationContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\n\n/**\n * A default Spring Security {@link AuthenticationContext} implementation that uses {@link SecurityContextHolder} and\n * {@link org.springframework.security.core.context.SecurityContext} to provide the information.\n *\n * @author Filip Hrisafov\n */\npublic class SpringSecurityAuthenticationContext implements AuthenticationContext {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SpringSecurityAuthenticationContext.class);\n\n    @Override\n    public String getAuthenticatedUserId() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        return authentication == null ? null : authentication.getName();\n    }\n\n    @Override\n    public Authentication getPrincipal() {\n        return SecurityContextHolder.getContext().getAuthentication();\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Sets the principal for the current security context.\n * If the principal is null, the authentication is set to null.\n * If the principal is an instance of Authentication, the authentication is set to the principal.\n * Otherwise, a UsernamePasswordAuthenticationToken is created with the principal and null as credentials,\n * and this token is set as the authentication.\n * A debug message is logged indicating that a principal that is not of type Authentication is being set.\n *\n * @param principal The principal to be set in the security context.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic void setPrincipal(Principal principal) {\n    if (principal == null) {\n        SecurityContextHolder.getContext().setAuthentication(null);\n    } else if (principal instanceof Authentication) {\n        SecurityContextHolder.getContext().setAuthentication((Authentication) principal);\n    } else {\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "setPrincipal", "reference": "        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(principal, null));\n        LOGGER.debug(\"Setting a principal that is not of type `org.springframework.security.core.Authentication`.\"\n                + \" When using Spring Security you can just set the user through 'SecurityContextHolder.getContext().setAuthentication(..)'\"\n                + \" Using 'org.springframework.security.authentication.UsernamePasswordAuthenticationToken' to wrap the principal of type '{}'\",\n            principal.getClass());\n    }\n}", "completions": ["```Java\n        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(principal, null));\n    }\n}\n```\n"]}
{"id": 66, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rest.internal.exceptions;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.ext.ExceptionMapper;\nimport javax.ws.rs.ext.Provider;\n\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.rest.XWikiRestComponent;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.template.TemplateManager;\n\nimport static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;\nimport static org.apache.commons.lang3.exception.ExceptionUtils.getRootCauseMessage;\nimport static org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace;\n\n/**\n * Exception mapper for all {@link Exception} exceptions. Allowing to log all exceptions that are not inheriting from\n * {@link RuntimeException} or already mapped by another exception mapper.\n * <p>\n * The goal is to be able to have access to the stacktrace of the exceptions, instead of a simple http 500 error and a\n * {@code \"No ExceptionMapper was found, but must be found\"} message (see\n * <a href=\"https://github.com/restlet/restlet-framework-java/issues/1070\">\n * https://github.com/restlet/restlet-framework-java/issues/1070</a>).\n *\n * @version $Id: acf149052f8ad88ee5e06166d673810cb97707ad $\n * @since 13.8RC1\n * @since 13.7.1\n * @since 13.4.4\n */\n@Component\n@Named(\"org.xwiki.rest.internal.exceptions.ExceptionExceptionMapper\")\n@Provider\n@Singleton\npublic class ExceptionExceptionMapper implements ExceptionMapper<Exception>, XWikiRestComponent\n{\n    @Inject\n    private Logger logger;\n\n    @Inject\n    private TemplateManager templateManager;\n\n    @Inject\n    private ScriptContextManager scriptContextManager;\n\n    @Inject\n    private ContextualLocalizationManager contextLocalization;\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method is responsible for handling exceptions and returning appropriate responses.\n * It logs the unmapped exception and its stacktrace, and then constructs an error response to be sent to the client.\n * The response includes a message detailing the exception, which is either generated from a template or a fallback string.\n * The message is either in HTML or plain text format, depending on whether the template rendering is successful.\n * \n * @param cause The exception to be handled.\n * @return A Response object containing the error message and the appropriate media type.\n * @throws RuntimeException If the exception is a RuntimeException, it is rethrown to maintain the default behavior of JaxRsProviders.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Response toResponse(Exception cause)\n{\n    // This ExceptionMapper captures too many exception types, because we can't distinguish checked and unchecked\n    // exceptions using generic types. If the mapped type is RuntimeException (unchecked exception), JaxRsProviders\n    // would re-throw the exception without mapping it (or it would have been handled by another mapper instead of\n    // this one), we reproduce this behavior to stay as close as possible to the default implementation (note:\n    // RuntimeException stacktraces are logged by default).\n    if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n    }\n\n    // Logs the unmapped exception, with its stacktrace.\n    this.logger.error(\"A REST endpoint failed with an unmapped exception.\", cause);\n\n    // Returns an error response to the client, with some detail about the exception in the response.\n    String message;\n    String templateName = \"rest/exception.vm\";\n    MediaType mediaType;\n    try {\n        ScriptContext scriptContext = this.scriptContextManager.getScriptContext();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "toResponse", "reference": "        scriptContext.setAttribute(\"cause\", cause, ScriptContext.ENGINE_SCOPE);\n        // The message generated from the template is in HTML. \n        mediaType = MediaType.TEXT_HTML_TYPE;\n        message = this.templateManager.render(templateName);\n    } catch (Exception e) {\n        this.logger.warn(\"Failed to render the response using template [{}]. Cause: [{}].\", templateName,\n            getRootCauseMessage(e));\n        // Fallback to a formatted string when the template rendering fails.\n        // In case of failure when generating the message content from a template, a text content is generated \n        // instead.\n        String translation =\n            this.contextLocalization.getTranslationPlain(\"rest.exception.noMapper\", cause.getClass().getName());\n        mediaType = TEXT_PLAIN_TYPE;\n        // We use a hardcoded \\n because the message is used in an HTTP response.\n        message = String.format(\"%s\\n%s\", translation, getStackTrace(cause));\n    }\n\n    return Response.serverError()\n        .entity(message)\n        .type(mediaType)\n        .build();\n}", "completions": ["```markdown\n```java\n/**\n * Description: This method is responsible for handling exceptions and returning appropriate responses.\n * It logs the unmapped exception and its stacktrace, and then constructs an error response to be sent to the client.\n * The response includes a message detailing the exception, which is either generated from a template or a fallback string.\n * The message is either in HTML or plain text format, depending on whether the template rendering is successful.\n * \n * @param cause The exception to be handled.\n * @return A Response object containing the error message and the appropriate media type.\n * @throws RuntimeException If the exception is a RuntimeException, it is rethrown to maintain the default behavior of JaxRsProviders.\n */\n@Override\npublic Response toResponse(Exception cause)\n{\n    // This ExceptionMapper captures too many exception types, because we can't distinguish checked and unchecked\n    // exceptions using generic types. If the mapped type is RuntimeException (unchecked exception), JaxRsProviders\n    // would re-throw the exception without mapping it (or it would have been handled by another mapper instead of\n    // this one), we reproduce this behavior to stay as close as possible to the default implementation (note:\n    // RuntimeException stacktraces are logged by default).\n    if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n    }\n\n    // Logs the unmapped exception, with its stacktrace.\n    this.logger.error(\"A REST endpoint failed with an unmapped exception.\", cause);\n\n    // Returns an error response to the client, with some detail about the exception in the response.\n    String message;\n    String templateName = \"rest/exception.vm\";\n    MediaType mediaType;\n    try {\n        ScriptContext scriptContext = this.scriptContextManager.getScriptContext();\n        String stackTrace = getStackTrace(cause);\n        message = this.templateManager.render(templateName, scriptContext, stackTrace);\n        mediaType = TEXT_PLAIN_TYPE;\n    } catch (Exception e) {\n        // Fallback to plain text.\n        message = getRootCauseMessage(cause);\n        mediaType = MediaType.TEXT_PLAIN_TYPE;\n    }\n\n    return Response.serverError().entity(message).type(mediaType).build();\n}\n```\n```\n"]}
{"id": 67, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.jsoup.nodes;\n\nimport java.io.IOException;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n A text node.\n\n @author Jonathan Hedley, jonathan@hedley.net */\npublic class TextNode extends Node {\n    /*\n    TextNode is a node, and so by default comes with attributes and children. The attributes are seldom used, but use\n    memory, and the child nodes are never used. So we don't have them, and override accessors to attributes to create\n    them as needed on the fly.\n     */\n    private static final String TEXT_KEY = \"text\";\n    String text;\n\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @param baseUri base uri\n     @see #createFromEncoded(String, String)\n     */\n    public TextNode(String text, String baseUri) {\n        this.baseUri = baseUri;\n        this.text = text;\n    }\n\n\tpublic String nodeName() {\n        return \"#text\";\n    }\n    \n    /**\n     * Get the text content of this text node.\n     * @return Unencoded, normalised text.\n     * @see TextNode#getWholeText()\n     */\n    public String text() {\n        return normaliseWhitespace(getWholeText());\n    }\n    \n    /**\n     * Set the text content of this text node.\n     * @param text unencoded text\n     * @return this, for chaining\n     */\n    public TextNode text(String text) {\n        this.text = text;\n        if (attributes != null)\n            attributes.put(TEXT_KEY, text);\n        return this;\n    }\n\n    /**\n     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n     @return text\n     */\n    public String getWholeText() {\n        return attributes == null ? text : attributes.get(TEXT_KEY);\n    }\n\n    /**\n     Test if this text node is blank -- that is, empty or only whitespace (including newlines).\n     @return true if this document is empty or only whitespace, false if it contains any text content.\n     */\n    public boolean isBlank() {\n        return StringUtil.isBlank(getWholeText());\n    }\n\n    /**\n     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the\n     * original text up to the offset, and will have a new text node sibling containing the text after the offset.\n     * @param offset string offset point to split node at.\n     * @return the newly created text node containing the text after the offset.\n     */\n```\n\n### Code description\n```Java\n/**\n * Splits the text of the current TextNode at the specified offset.\n * The text before the offset becomes the new text of the current node,\n * and the text after the offset becomes the text of a new TextNode, which is returned.\n * The new TextNode is added as a sibling to the current node in the DOM tree.\n *\n * @param offset the index at which to split the text, must be non-negative and less than the current text length.\n * @return the new TextNode containing the text after the split.\n * @throws IllegalArgumentException if the offset is negative or greater than or equal to the current text length.\n */\n```\n\n### Code snippet:\n```Java\npublic TextNode splitText(int offset) {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "splitText", "reference": "    text(head);\n    TextNode tailNode = new TextNode(tail, this.baseUri());\n    if (parent() != null)\n        parent().addChildren(siblingIndex()+1, tailNode);\n\n    return tailNode;\n}", "completions": ["```Java\n    String newText = getWholeText().substring(offset);\n    TextNode newNode = new TextNode(newText, baseUri);\n    this.parent.addChildNode(newNode);\n    this.parent.removeChildNode(this);\n    return newNode;\n}\n```\n"]}
{"id": 68, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Licensed to jclouds, Inc. (jclouds) under one or more\n * contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  jclouds licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jclouds.scriptbuilder;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.jclouds.scriptbuilder.domain.AcceptsStatementVisitor;\nimport org.jclouds.scriptbuilder.domain.OsFamily;\nimport org.jclouds.scriptbuilder.domain.ShellToken;\nimport org.jclouds.scriptbuilder.domain.Statement;\nimport org.jclouds.scriptbuilder.domain.StatementVisitor;\nimport org.jclouds.scriptbuilder.domain.Statements;\nimport org.jclouds.scriptbuilder.util.Utils;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMap.Builder;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\n/**\n * Creates a shell script.\n * \n * @author Adrian Cole\n */\npublic class ScriptBuilder implements Statement, AcceptsStatementVisitor {\n\n   @VisibleForTesting\n   List<Statement> statements = Lists.newArrayList();\n\n   @VisibleForTesting\n   Map<String, Map<String, String>> variableScopes = Maps.newLinkedHashMap();\n\n   @VisibleForTesting\n   List<String> variablesToUnset = Lists.newArrayList(\"PATH\", \"JAVA_HOME\", \"LIBRARY_PATH\");\n\n   public ScriptBuilder addStatement(Statement statement) {\n      statements.add(checkNotNull(statement, \"statement\"));\n      return this;\n   }\n\n   /**\n    * Unsets a variable to ensure it is set within the script.\n    * @param variable name in UPPER_UNDERSCORE case format\n    */\n   public ScriptBuilder unsetEnvironmentVariable(String name) {\n      variablesToUnset.add(checkNotNull(name, \"name\"));\n      return this;\n   }\n\n   /**\n    * Exports a variable inside the script\n    * @param scopeName\n    * @param variables keys are the variables to export in UPPER_UNDERSCORE case format\n    */\n   public ScriptBuilder addEnvironmentVariableScope(String scopeName, Map<String, String> variables) {\n      variableScopes.put(checkNotNull(scopeName, \"scopeName\"), checkNotNull(variables, \"variables\"));\n      return this;\n   }\n\n   // TODO: make scriptbuilder smart enough to know when a statement is a direct\n   // child of the script, and automatically convert\n   public static Statement forget(String instanceName, String script, String logDir) {\n      return new ExitInsteadOfReturn(Statements.forget(instanceName, script, logDir));\n   }\n\n   public static Statement findPid(String pid) {\n      return new ExitInsteadOfReturn(Statements.findPid(pid));\n   }\n\n   public static Statement call(String fn, String... args) {\n      return new ExitInsteadOfReturn(Statements.call(fn, args));\n   }\n\n   /**\n    * builds the shell script, by adding the following\n    * <ol>\n    * <li>shell declaration line</li>\n    * <li>variable exports</li>\n    * <li>case/switch</li>\n    * </ol>\n    * \n    * @param osFamily\n    *           whether to write a cmd or bash script.\n    */\n\n   @Override\n   public String render(OsFamily osFamily) {\n      Map<String, String> functions = Maps.newLinkedHashMap();\n      functions.put(\"abort\", Utils.writeFunctionFromResource(\"abort\", osFamily));\n\n      for (Entry<String, Map<String, String>> entry : variableScopes.entrySet()) {\n         functions.put(entry.getKey(), Utils.writeFunction(entry.getKey(), Utils.writeVariableExporters(entry\n                  .getValue(), osFamily)));\n      }\n      StringBuilder builder = new StringBuilder();\n      builder.append(ShellToken.BEGIN_SCRIPT.to(osFamily));\n      builder.append(Utils.writeUnsetVariables(variablesToUnset, osFamily));\n      Map<String, String> functionsToWrite = resolveFunctionDependenciesForStatements(functions, statements, osFamily);\n      writeFunctions(functionsToWrite, osFamily, builder);\n      builder.append(Utils.writeZeroPath(osFamily));\n      StringBuilder statementBuilder = new StringBuilder();\n      for (Statement statement : statements) {\n         statementBuilder.append(statement.render(osFamily));\n      }\n      builder.append(statementBuilder.toString());\n      builder.append(ShellToken.END_SCRIPT.to(osFamily));\n      return builder.toString();\n   }\n\n   public static void writeFunctions(Map<String, String> functionsToWrite, OsFamily osFamily, StringBuilder builder) {\n      if (functionsToWrite.size() > 0) {\n         builder.append(ShellToken.BEGIN_FUNCTIONS.to(osFamily));\n         for (String function : functionsToWrite.values()) {\n            builder.append(Utils.replaceTokens(function, ShellToken.tokenValueMap(osFamily)));\n         }\n         builder.append(ShellToken.END_FUNCTIONS.to(osFamily));\n      }\n   }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method resolves function dependencies for a given set of statements and known functions.\n * It uses the Google Guava library to create an immutable map of known functions, find the dependent functions \n * from the given statements, and then add any unresolved functions to the map.\n *\n * @param knownFunctions A map of known function names to their corresponding values.\n * @param statements An iterable collection of statements.\n * @param osFamily The operating system family.\n * @return A map of all resolved function dependencies.\n */\n```\n\n### Code snippet:\n```Java\n@VisibleForTesting\npublic static Map<String, String> resolveFunctionDependenciesForStatements(Map<String, String> knownFunctions,\n      Iterable<Statement> statements, final OsFamily osFamily) {\n   Builder<String, String> builder = ImmutableMap.builder();\n   builder.putAll(knownFunctions);\n   Set<String> dependentFunctions = ImmutableSet.copyOf(Iterables.concat(Iterables.transform(statements,\n         new Function<Statement, Iterable<String>>() {\n            @Override\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "resolveFunctionDependenciesForStatements", "reference": "            public Iterable<String> apply(Statement from) {\n               return from.functionDependencies(osFamily);\n            }\n         })));\n   for (String unresolved : Sets.difference(dependentFunctions, knownFunctions.keySet()))\n      builder.put(unresolved, Utils.writeFunctionFromResource(unresolved, osFamily));\n   return builder.build();\n}", "completions": ["```Java\n```Java\n@VisibleForTesting\npublic static Map<String, String> resolveFunctionDependenciesForStatements(Map<String, String> knownFunctions,\n      Iterable<Statement> statements, final OsFamily osFamily) {\n   Builder<String, String> builder = ImmutableMap.builder();\n   builder.putAll(knownFunctions);\n   Set<String> dependentFunctions = ImmutableSet.copyOf(Iterables.concat(Iterables.transform(statements,\n         new Function<Statement, Iterable<String>>() {\n            @Override\n            public Iterable<String> apply(Statement input) {\n               return input.accept(new StatementVisitor() {\n                  @Override\n                  public void visit(ForEachStatement each) {\n                     dependentFunctions.add(each.getVariable());\n                  }\n\n                  @Override\n                  public void visit(IfStatement ifStatement) {\n                     dependentFunctions.add(ifStatement.getCondition());\n                     dependentFunctions.add(ifStatement.getTrueBranch());\n                     dependentFunctions.add(ifStatement.getFalseBranch());\n                  }\n\n                  @Override\n                  public void visit(SetEnvironmentVariableStatement setEnvironmentVariableStatement) {\n                     dependentFunctions.add(setEnvironmentVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(UnsetEnvironmentVariableStatement unsetEnvironmentVariableStatement) {\n                     dependentFunctions.add(unsetEnvironmentVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(CallStatement callStatement) {\n                     dependentFunctions.add(callStatement.getFunction());\n                     for (String arg : callStatement.getArguments()) {\n                        dependentFunctions.add(arg);\n                     }\n                  }\n\n                  @Override\n                  public void visit(ExitStatement exitStatement) {\n                     // do nothing\n                  }\n\n                  @Override\n                  public void visit(ForStatement forStatement) {\n                     dependentFunctions.add(forStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(WhileStatement whileStatement) {\n                     dependentFunctions.add(whileStatement.getCondition());\n                     dependentFunctions.add(whileStatement.getBody());\n                  }\n\n                  @Override\n                  public void visit(WriteFileStatement writeFileStatement) {\n                     dependentFunctions.add(writeFileStatement.getFile());\n                  }\n\n                  @Override\n                  public void visit(ReadFileStatement readFileStatement) {\n                     dependentFunctions.add(readFileStatement.getFile());\n                  }\n\n                  @Override\n                  public void visit(ExecuteStatement executeStatement) {\n                     dependentFunctions.add(executeStatement.getCommand());\n                  }\n\n                  @Override\n                  public void visit(SetVariableStatement setVariableStatement) {\n                     dependentFunctions.add(setVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(UnsetVariableStatement unsetVariableStatement) {\n                     dependentFunctions.add(unsetVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(GetVariableStatement getVariableStatement) {\n                     dependentFunctions.add(getVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(SetShellVariableStatement setShellVariableStatement) {\n                     dependentFunctions.add(setShellVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(UnsetShellVariableStatement unsetShellVariableStatement) {\n                     dependentFunctions.add(unsetShellVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(GetShellVariableStatement getShellVariableStatement) {\n                     dependentFunctions.add(getShellVariableStatement.getVariable());\n                  }\n\n                  @Override\n                  public void visit(SetPropertyStatement setPropertyStatement) {\n                     dependentFunctions.add(setPropertyStatement.getProperty());\n                  }\n\n                  @Override\n                  public void visit(UnsetPropertyStatement unsetPropertyStatement) {\n                     dependentFunctions.add(unsetPropertyStatement.getProperty());\n                  }\n\n                  @Override\n                  public void visit(GetPropertyStatement getPropertyStatement) {\n                     dependentFunctions.add(getPropertyStatement.getProperty());\n                  }\n\n                  @Override\n                  public void visit(SetSystemPropertyStatement setSystemPropertyStatement) {\n                     dependentFunctions.add(setSystemPropertyStatement.get"]}
{"id": 69, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2016 KairosDB Authors\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.kairosdb.core.datastore;\n\n\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.ListMultimap;\nimport com.google.inject.Inject;\nimport com.google.inject.name.Named;\nimport org.kairosdb.core.DataPoint;\nimport org.kairosdb.core.KairosDataPointFactory;\nimport org.kairosdb.core.KairosPostConstructInit;\nimport org.kairosdb.core.aggregator.LimitAggregator;\nimport org.kairosdb.core.exception.DatastoreException;\nimport org.kairosdb.core.groupby.GroupByResult;\nimport org.kairosdb.core.groupby.Grouper;\nimport org.kairosdb.core.groupby.TagGroupBy;\nimport org.kairosdb.core.groupby.TagGroupByResult;\nimport org.kairosdb.core.groupby.TypeGroupByResult;\nimport org.kairosdb.core.reporting.ThreadReporter;\nimport org.kairosdb.plugin.Aggregator;\nimport org.kairosdb.plugin.GroupBy;\nimport org.kairosdb.util.MemoryMonitor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Objects.requireNonNull;\nimport static com.google.common.base.Preconditions.checkState;\n\npublic class KairosDatastore implements KairosPostConstructInit\n{\n\tpublic static final Logger logger = LoggerFactory.getLogger(KairosDatastore.class);\n\tpublic static final String QUERY_CACHE_DIR = \"kairosdb.query_cache.cache_dir\";\n\tpublic static final String KEEP_CACHE_FILES = \"kairosdb.query_cache.keep_cache_files\";\n\tpublic static final String QUERY_METRIC_TIME = \"kairosdb.datastore.query_time\";\n\tpublic static final String QUERIES_WAITING_METRIC_NAME = \"kairosdb.datastore.queries_waiting\";\n\tpublic static final String QUERY_SAMPLE_SIZE = \"kairosdb.datastore.query_sample_size\";\n\tpublic static final String QUERY_ROW_COUNT = \"kairosdb.datastore.query_row_count\";\n\n\tprivate final Datastore m_datastore;\n\tprivate final QueryQueuingManager m_queuingManager;\n\tprivate final KairosDataPointFactory m_dataPointFactory;\n\n\tprivate String m_baseCacheDir;\n\tprivate volatile String m_cacheDir;\n\tprivate final boolean m_keepCacheFiles;\n\n\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n\t@Inject\n\tpublic KairosDatastore(Datastore datastore, QueryQueuingManager queuingManager,\n\t\t\tKairosDataPointFactory dataPointFactory,\n\t\t\t@Named(KEEP_CACHE_FILES) boolean keepCacheFiles)\n\t\t\tthrows DatastoreException\n\t{\n\t\tm_datastore = requireNonNull(datastore);\n\t\tm_queuingManager = requireNonNull(queuingManager);\n\t\tm_dataPointFactory = dataPointFactory;\n\n\t\tm_baseCacheDir = System.getProperty(\"java.io.tmpdir\") + \"/kairos_cache/\";\n\t\tm_keepCacheFiles = keepCacheFiles;\n\t}\n\n\t@Override\n\tpublic void init()\n\t{\n\t\tsetupCacheDirectory();\n\t}\n\n\t@SuppressWarnings(\"UnusedDeclaration\")\n\t@Inject(optional = true)\n\tpublic void setBaseCacheDir(@Named(QUERY_CACHE_DIR) String cacheTempDir)\n\t{\n\t\tif (cacheTempDir != null && !cacheTempDir.equals(\"\"))\n\t\t{\n\t\t\tm_baseCacheDir = cacheTempDir;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n\tprivate void setupCacheDirectory()\n\t{\n\t\tcleanDirectory(new File(m_baseCacheDir));\n\t\tnewCacheDirectory();\n\t\tFile cacheDirectory = new File(m_cacheDir);\n\t\tcacheDirectory.mkdirs();\n\t\tcheckState(cacheDirectory.exists(), \"Unable to create Cache directory '\" + m_cacheDir + \"'\");\n\t}\n\n\t/**\n\t Make sure the folder exists\n\n\t @param path\n\t */\n\tprivate static void ensureFolder(String path)\n\t{\n\t\tFile fPath = new File(path);\n\t\tif (!fPath.exists())\n\t\t\tfPath.mkdirs();\n\t}\n\n\tpublic String getCacheDir()\n\t{\n\t\tensureFolder(m_cacheDir);\n\t\treturn (m_cacheDir);\n\t}\n\n\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n\tprivate void newCacheDirectory()\n\t{\n\t\tString newCacheDir = m_baseCacheDir + \"/\" + System.currentTimeMillis() + \"/\";\n\t\tensureFolder(newCacheDir);\n\t\tm_cacheDir = newCacheDir;\n\t}\n\n\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n\tprivate void cleanDirectory(File directory)\n\t{\n\t\tif (!directory.exists())\n\t\t\treturn;\n\t\tFile[] list = directory.listFiles();\n\n\t\tif (list != null && list.length > 0)\n\t\t{\n\t\t\tfor (File aList : list)\n\t\t\t{\n\t\t\t\tif (aList.isDirectory())\n\t\t\t\t\tcleanDirectory(aList);\n\n\t\t\t\taList.delete();\n\t\t\t}\n\t\t}\n\n\t\tdirectory.delete();\n\t}\n\n\tpublic void cleanCacheDir(boolean wait)\n\t{\n\t\tString oldCacheDir = m_cacheDir;\n\t\tnewCacheDirectory();\n\n\t\tif (wait)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tThread.sleep(60000);\n\t\t\t}\n\t\t\tcatch (InterruptedException e)\n\t\t\t{\n\t\t\t\tlogger.error(\"Sleep interrupted:\", e);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"Executing job...\");\n\t\tFile dir = new File(oldCacheDir);\n\t\tlogger.debug(\"Deleting cache files in \" + dir.getAbsolutePath());\n\n\t\tcleanDirectory(dir);\n\t}\n\n\tpublic Datastore getDatastore()\n\t{\n\t\treturn m_datastore;\n\t}\n\n\t/**\n\t * Close the datastore\n\t */\n\tpublic void close() throws InterruptedException, DatastoreException\n\t{\n\t\tm_datastore.close();\n\t}\n\n\t/*public void putDataPoint(String metricName,\n\t\t\tImmutableSortedMap<String, String> tags,\n\t\t\tDataPoint dataPoint) throws DatastoreException\n\t{\n\t\tputDataPoint(metricName, tags, dataPoint, 0);\n\t}\n\n\tpublic void putDataPoint(String metricName,\n\t\t\tImmutableSortedMap<String, String> tags,\n\t\t\tDataPoint dataPoint, int ttl) throws DatastoreException\n\t{\n\t\t//Add to datastore first.\n\t\tm_datastore.putDataPoint(metricName, tags, dataPoint, ttl);\n\t}*/\n\n\n\tpublic Iterable<String> getMetricNames(String prefix) throws DatastoreException\n\t{\n\t\treturn (m_datastore.getMetricNames(prefix));\n\t}\n\n\tpublic Iterable<String> getTagNames() throws DatastoreException\n\t{\n\t\treturn (m_datastore.getTagNames());\n\t}\n\n\tpublic Iterable<String> getTagValues() throws DatastoreException\n\t{\n\t\treturn (m_datastore.getTagValues());\n\t}\n\n\t/**\n\t * Exports the data for a metric query without doing any aggregation or sorting\n\t *\n\t * @param metric metric\n\t * @throws DatastoreException\n\t */\n\tpublic void export(QueryMetric metric, QueryCallback callback) throws DatastoreException\n\t{\n\t\trequireNonNull(metric);\n\n\t\tm_datastore.queryDatabase(metric, callback);\n\t}\n\n\n\tpublic List<DataPointGroup> queryTags(QueryMetric metric) throws DatastoreException\n\t{\n\t\tTagSet tagSet = m_datastore.queryMetricTags(metric);\n\n\t\treturn Collections.<DataPointGroup>singletonList(new EmptyDataPointGroup(metric.getName(), tagSet));\n\n\t}\n\n\tpublic void indexTags(QueryMetric queryMetric) throws DatastoreException\n\t{\n\t\tm_datastore.indexMetricTags(queryMetric);\n\t}\n\n\tpublic DatastoreQuery createQuery(QueryMetric metric) throws DatastoreException\n\t{\n\t\trequireNonNull(metric);\n\n\t\tDatastoreQuery dq;\n\n\t\ttry\n\t\t{\n\t\t\tdq = new DatastoreQueryImpl(metric);\n\t\t}\n\t\tcatch (UnsupportedEncodingException | NoSuchAlgorithmException | InterruptedException e)\n\t\t{\n\t\t\tthrow new DatastoreException(e);\n\t\t}\n\n\t\treturn (dq);\n\t}\n\n\n\tpublic void delete(QueryMetric metric) throws DatastoreException\n\t{\n\t\trequireNonNull(metric);\n\n\t\ttry\n\t\t{\n\t\t\tm_datastore.deleteDataPoints(metric);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new DatastoreException(e);\n\t\t}\n\t}\n\n\tprivate static List<GroupBy> removeTagGroupBy(List<GroupBy> groupBys)\n\t{\n\t\tList<GroupBy> modifiedGroupBys = new ArrayList<GroupBy>();\n\t\tfor (GroupBy groupBy : groupBys)\n\t\t{\n\t\t\tif (!(groupBy instanceof TagGroupBy))\n\t\t\t\tmodifiedGroupBys.add(groupBy);\n\t\t}\n\t\treturn modifiedGroupBys;\n\t}\n\n\tprivate static TagGroupBy getTagGroupBy(List<GroupBy> groupBys)\n\t{\n\t\tfor (GroupBy groupBy : groupBys)\n\t\t{\n\t\t\tif (groupBy instanceof TagGroupBy)\n\t\t\t\treturn (TagGroupBy) groupBy;\n\t\t}\n\t\treturn null;\n\t}\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method groups DataPointRows by type and tag, and returns a list of DataPointGroups.\n * \n * @param metricName The name of the metric to group by.\n * @param rows The list of DataPointRows to group.\n * @param tagGroupBy The TagGroupBy object to group by.\n * @param order The order in which to sort the groups.\n * @return A list of DataPointGroups, grouped by type and tag.\n * @throws OutOfMemoryError if the available memory is insufficient to perform the operation.\n */\n```\n\n### Code snippet:\n```Java\nprotected List<DataPointGroup> groupByTypeAndTag(String metricName,\n\t\tList<DataPointRow> rows, TagGroupBy tagGroupBy, Order order)\n{\n\tList<DataPointGroup> ret = new ArrayList<DataPointGroup>();\n\tMemoryMonitor mm = new MemoryMonitor(20);\n\n\tif (rows.isEmpty())\n\t{\n\t\tret.add(new SortingDataPointGroup(metricName, order));\n\t}\n\telse\n\t{\n\t\tListMultimap<String, DataPointGroup> typeGroups = ArrayListMultimap.create();\n\n\t\t//Go through each row grouping them by type\n\t\tfor (DataPointRow row : rows)\n\t\t{\n\t\t\tString groupType = m_dataPointFactory.getGroupType(row.getDatastoreType());\n\n\t\t\ttypeGroups.put(groupType, new DataPointGroupRowWrapper(row));\n\t\t\tmm.checkMemoryAndThrowException();\n\t\t}\n\n\t\t//Sort the types for predictable results\n\t\tTreeSet<String> sortedTypes = new TreeSet<String>(typeGroups.keySet());\n\n\t\t//Now go through each type group and group by tag if needed.\n\t\tfor (String type : sortedTypes)\n\t\t{\n\t\t\tif (tagGroupBy != null)\n\t\t\t{\n\t\t\t\tListMultimap<String, DataPointGroup> groups = ArrayListMultimap.create();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "groupByTypeAndTag", "reference": "\t\t\t\tMap<String, TagGroupByResult> groupByResults = new HashMap<String, TagGroupByResult>();\n\n\t\t\t\tfor (DataPointGroup dataPointGroup : typeGroups.get(type))\n\t\t\t\t{\n\t\t\t\t\t//Todo: Add code to datastore implementations to filter by the group by tag\n\n\t\t\t\t\tLinkedHashMap<String, String> matchingTags = getMatchingTags(dataPointGroup, tagGroupBy.getTagNames());\n\t\t\t\t\tString tagsKey = getTagsKey(matchingTags);\n\t\t\t\t\tgroups.put(tagsKey, dataPointGroup);\n\t\t\t\t\tgroupByResults.put(tagsKey, new TagGroupByResult(tagGroupBy, matchingTags));\n\t\t\t\t\tmm.checkMemoryAndThrowException();\n\t\t\t\t}\n\n\t\t\t\t//Sort groups by tags\n\t\t\t\tTreeSet<String> sortedGroups = new TreeSet<String>(groups.keySet());\n\n\t\t\t\tfor (String key : sortedGroups)\n\t\t\t\t{\n\t\t\t\t\tSortingDataPointGroup sdpGroup = new SortingDataPointGroup(groups.get(key), groupByResults.get(key), order);\n\t\t\t\t\tsdpGroup.addGroupByResult(new TypeGroupByResult(type));\n\t\t\t\t\tret.add(sdpGroup);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret.add(new SortingDataPointGroup(typeGroups.get(type), new TypeGroupByResult(type), order));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}", "completions": ["```markdown\n```java\nprotected List<DataPointGroup> groupByTypeAndTag(String metricName,\n\t\tList<DataPointRow> rows, TagGroupBy tagGroupBy, Order order)\n{\n\tList<DataPointGroup> ret = new ArrayList<DataPointGroup>();\n\tMemoryMonitor mm = new MemoryMonitor(20);\n\n\tif (rows.isEmpty())\n\t{\n\t\tret.add(new SortingDataPointGroup(metricName, order));\n\t}\n\telse\n\t{\n\t\tListMultimap<String, DataPointGroup> typeGroups = ArrayListMultimap.create();\n\n\t\t//Go through each row grouping them by type\n\t\tfor (DataPointRow row : rows)\n\t\t{\n\t\t\tString groupType = m_dataPointFactory.getGroupType(row.getDatastoreType());\n\n\t\t\ttypeGroups.put(groupType, new DataPointGroupRowWrapper(row));\n\t\t\tmm.checkMemoryAndThrowException();\n\t\t}\n\n\t\t//Sort the types for predictable results\n\t\tTreeSet<String> sortedTypes = new TreeSet<String>(typeGroups.keySet());\n\n\t\t//Now go through each type group and group by tag if needed.\n\t\tfor (String type : sortedTypes)\n\t\t{\n\t\t\tif (tagGroupBy != null)\n\t\t\t{\n\t\t\t\tListMultimap<String, DataPointGroup> groups = ArrayListMultimap.create();\n\n\t\t\t\t//Group by tag\n\t\t\t\tfor (DataPointGroup group : typeGroups.get(type))\n\t\t\t\t{\n\t\t\t\t\tgroups.put(group.getTag(), group);\n\t\t\t\t}\n\n\t\t\t\t//Create the group\n\t\t\t\tDataPointGroup newGroup = new GroupByTypeAndTagDataPointGroup(metricName, type, tagGroupBy, groups, order);\n\t\t\t\tret.add(newGroup);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Create the group\n\t\t\t\tDataPointGroup newGroup = new TypeAndTagDataPointGroup(metricName, type, typeGroups.get(type), order);\n\t\t\t\tret.add(newGroup);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n```\n```\n"]}
{"id": 70, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.genetics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n/**\n * Mutation operator for {@link RandomKey}s. Changes a randomly chosen element\n * of the array representation to a random value uniformly distributed in [0,1].\n *\n * @since 2.0\n * @version $Revision$ $Date$\n */\npublic class RandomKeyMutation implements MutationPolicy {\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if <code>original</code> is not a\n     * {@link RandomKey} instance\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method mutates a given Chromosome by replacing a random element in its representation with a new random value.\n * It only works with Chromosomes of type RandomKey.\n *\n * @param original The original Chromosome to be mutated.\n * @return A new Chromosome with a mutated representation.\n * @throws MathRuntimeException If the original Chromosome is not of type RandomKey.\n */\n```\n\n### Code snippet:\n```Java\npublic Chromosome mutate(Chromosome original) {\n    if (!(original instanceof RandomKey<?>)) {\n        throw MathRuntimeException.createIllegalArgumentException(\n                \"RandomKeyMutation works only with RandomKeys, got \" +\n                original.getClass().getSimpleName());\n    }\n\n    RandomKey<?> originalRk = (RandomKey<?>) original;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "mutate", "reference": "    List<Double> repr = originalRk.getRepresentation();\n    int rInd = GeneticAlgorithm.getRandomGenerator().nextInt(repr.size());\n\n    List<Double> newRepr = new ArrayList<Double> (repr);\n    newRepr.set(rInd, GeneticAlgorithm.getRandomGenerator().nextDouble());\n\n    return originalRk.newFixedLengthChromosome(newRepr);\n}", "completions": ["```Java\n    List<Double> originalRep = originalRk.getRepresentation();\n    int index = new Random().nextInt(originalRep.size());\n    originalRep.set(index, new Random().nextDouble());\n\n    return new RandomKey<>(originalRep);\n}\n```\n"]}
{"id": 71, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.sap.cloud.security.spring.token.authentication;\n\nimport com.sap.cloud.security.token.InvalidTokenException;\nimport com.sap.cloud.security.token.Token;\nimport com.sap.cloud.security.token.validation.CombiningValidator;\nimport com.sap.cloud.security.token.validation.ValidationResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.security.oauth2.jwt.JwtDecoder;\nimport org.springframework.util.Assert;\n\n/**\n * Internal class that decodes and validates the provided encoded token using\n * {@code java-security} client library.<br>\n * In case of successful validation, the token gets parsed and returned as\n * {@link Jwt}.\n *\n * Supports tokens issued by ias or xsuaa identity service.\n */\npublic class HybridJwtDecoder implements JwtDecoder {\n\tCombiningValidator<Token> xsuaaTokenValidators;\n\tCombiningValidator<Token> iasTokenValidators;\n\tLogger logger = LoggerFactory.getLogger(getClass());\n\n\t/**\n\t * Creates instance with a set of validators for validating the access / oidc\n\t * token issued by the dedicated identity service.\n\t *\n\t * @param xsuaaValidator\n\t *            set of validators that should be used to validate a xsuaa access\n\t *            token.\n\t * @param iasValidator\n\t *            set of validators that should be used to validate an ias oidc\n\t *            token.\n\t */\n\tpublic HybridJwtDecoder(CombiningValidator<Token> xsuaaValidator, CombiningValidator<Token> iasValidator) {\n\t\txsuaaTokenValidators = xsuaaValidator;\n\t\tiasTokenValidators = iasValidator;\n\t}\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method decodes a given encoded token and validates it.\n * It throws an InvalidTokenException if the token is invalid or if the service of the token is not supported.\n * \n * @param encodedToken The encoded token to be decoded and validated.\n * @return The decoded and validated Jwt token.\n * @throws InvalidTokenException If the token is invalid or if the service of the token is not supported.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic Jwt decode(String encodedToken) {\n\tAssert.hasText(encodedToken, \"encodedToken must neither be null nor empty String.\");\n\tToken token = Token.create(encodedToken);\n\tValidationResult validationResult;\n\n\tswitch (token.getService()) {\n\tcase IAS:\n\t\tvalidationResult = iasTokenValidators.validate(token);\n\t\tbreak;\n\tcase XSUAA:\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "decode", "reference": "\t\tvalidationResult = xsuaaTokenValidators.validate(token);\n\t\tbreak;\n\tdefault:\n\t\tthrow new InvalidTokenException(\"The token of service \" + token.getService() + \" is not supported.\");\n\t}\n\tif (validationResult.isErroneous()) {\n\t\tthrow new InvalidTokenException(\"The token is invalid: \" + validationResult.getErrorDescription());\n\t}\n\tlogger.debug(\"The token of service {} was successfully validated.\", token.getService());\n\treturn parseJwt(token);\n}", "completions": ["```Java\n\tcase XSUAA:\n\t\tvalidationResult = xsuaaTokenValidators.validate(token);\n\t\tbreak;\n\tdefault:\n\t\tthrow new InvalidTokenException(\"The service of the token is not supported.\");\n\t}\n\n\tif (validationResult.isValid()) {\n\t\treturn Jwt.decode(encodedToken);\n\t} else {\n\t\tlogger.warn(\"The token is invalid: {}\", validationResult.getErrors());\n\t\tthrow new InvalidTokenException(\"The token is invalid.\");\n\t}\n}\n```\n"]}
{"id": 72, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (c) 2000-present Liferay, Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n */\n\npackage com.liferay.jenkins.results.parser;\n\nimport com.google.common.collect.Lists;\n\nimport com.liferay.jenkins.results.parser.JenkinsResultsParserUtil.HttpRequestMethod;\n\nimport java.io.IOException;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\n/**\n * @author Peter Yoo\n */\npublic class GitHubRemoteGitRepository extends BaseRemoteGitRepository {\n\n\tpublic boolean addLabel(String color, String description, String name) {\n\t\tif (hasLabel(name)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tJSONObject jsonObject = new JSONObject();\n\n\t\tjsonObject.put(\"color\", color);\n\t\tjsonObject.put(\"name\", name);\n\n\t\tif ((description != null) && !description.isEmpty()) {\n\t\t\tjsonObject.put(\"description\", description);\n\t\t}\n\n\t\tString labelRequestURL = getLabelRequestURL();\n\n\t\ttry {\n\t\t\tJenkinsResultsParserUtil.toString(\n\t\t\t\tlabelRequestURL, jsonObject.toString());\n\n\t\t\t_labelsLists.remove(labelRequestURL);\n\t\t}\n\t\tcatch (IOException ioException) {\n\t\t\tSystem.out.println(\"Unable to add label \" + name);\n\n\t\t\tioException.printStackTrace();\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic void deleteLabel(Label oldLabel) {\n\t\tupdateLabel(null, null, null, oldLabel);\n\t}\n\n\tpublic List<String> getCollaboratorUsernames() {\n\t\tif (_collaboratorUsernames != null) {\n\t\t\treturn _collaboratorUsernames;\n\t\t}\n\n\t\tString url = JenkinsResultsParserUtil.getGitHubApiUrl(\n\t\t\tgetName(), getUsername(), \"collaborators\");\n\n\t\ttry {\n\t\t\tJSONArray collaboratorsJSONArray =\n\t\t\t\tJenkinsResultsParserUtil.toJSONArray(url);\n\n\t\t\t_collaboratorUsernames = new ArrayList<>(\n\t\t\t\tcollaboratorsJSONArray.length());\n\n\t\t\tfor (int i = 0; i < collaboratorsJSONArray.length(); i++) {\n\t\t\t\tJSONObject collaboratorUserJSONObject =\n\t\t\t\t\tcollaboratorsJSONArray.getJSONObject(i);\n\n\t\t\t\t_collaboratorUsernames.add(\n\t\t\t\t\tcollaboratorUserJSONObject.getString(\"login\"));\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioException) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\"Unable to get collaborators\", ioException);\n\t\t}\n\n\t\treturn _collaboratorUsernames;\n\t}\n\n\tpublic String getHtmlURL() {\n\t\treturn JenkinsResultsParserUtil.combine(\n\t\t\t\"https://github.com/\", getUsername(), \"/\", getName());\n\t}\n\n\tpublic Label getLabel(String name) {\n\t\tfor (Label label : getLabels()) {\n\t\t\tif (name.equals(label.getName())) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n```\n\n### Code description\n```Java\n/**\n * Retrieves a list of labels from a GitHub repository.\n * The labels are fetched from the GitHub API in pages, up to a maximum of 100 labels per page.\n * If the labels list for a specific request URL is already cached, it is returned directly.\n * Otherwise, the labels are fetched from the GitHub API, stored in a HashSet to avoid duplicates,\n * and then converted to a list using the Lists.newArrayList method from the com.google.common.collect library.\n * The list of labels is then cached and returned.\n *\n * @return A list of labels for the GitHub repository.\n * @throws RuntimeException if there is an issue with the GitHub API request or if too many labels are found.\n */\n```\n\n### Code snippet:\n```Java\npublic List<Label> getLabels() {\n\tString labelRequestURL = getLabelRequestURL();\n\n\tif (_labelsLists.containsKey(labelRequestURL)) {\n\t\treturn _labelsLists.get(labelRequestURL);\n\t}\n\n\tJSONArray labelsJSONArray;\n\n\tSet<Label> labels = new HashSet<>();\n\n\tfor (int pageNumber = 1;\n\t\t pageNumber <=\n\t\t\t JenkinsResultsParserUtil.PAGES_GITHUB_API_PAGES_SIZE_MAX;\n\t\t pageNumber++) {\n\n\t\ttry {\n\t\t\tlabelsJSONArray = JenkinsResultsParserUtil.toJSONArray(\n\t\t\t\tJenkinsResultsParserUtil.combine(\n\t\t\t\t\tlabelRequestURL, \"?per_page=\",\n\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\tJenkinsResultsParserUtil.\n\t\t\t\t\t\t\tPER_PAGE_GITHUB_API_PAGES_SIZE_MAX),\n\t\t\t\t\t\"&page=\", String.valueOf(pageNumber)),\n\t\t\t\tfalse);\n\t\t}\n\t\tcatch (IOException ioException) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\tJenkinsResultsParserUtil.combine(\n\t\t\t\t\t\"Unable to get labels for \", getName(),\n\t\t\t\t\t\" Git repository\"),\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getLabels", "reference": "\t\t\t\tioException);\n\t\t}\n\n\t\tif (labelsJSONArray.length() == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < labelsJSONArray.length(); i++) {\n\t\t\tlabels.add(new Label((JSONObject)labelsJSONArray.get(i), this));\n\t\t}\n\n\t\tif (labelsJSONArray.length() <\n\t\t\t\tJenkinsResultsParserUtil.PAGES_GITHUB_API_PAGES_SIZE_MAX) {\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pageNumber ==\n\t\t\t\tJenkinsResultsParserUtil.PAGES_GITHUB_API_PAGES_SIZE_MAX) {\n\n\t\t\tthrow new RuntimeException(\n\t\t\t\tJenkinsResultsParserUtil.combine(\n\t\t\t\t\t\"Too many GitHub labels (>\",\n\t\t\t\t\tString.valueOf(labels.size()), \") found for \",\n\t\t\t\t\t\"GitHub repository \", getRemoteURL()));\n\t\t}\n\t}\n\n\t_labelsLists.put(labelRequestURL, Lists.newArrayList(labels));\n\n\treturn Lists.newArrayList(labels);\n}", "completions": ["```Java\n}\n\n\t\tcatch (IOException ioException) {\n\t\t\tSystem.out.println(\n\t\t\t\t\"Unable to get labels for \" + getName() +\n\t\t\t\t\" Git repository on page \" + pageNumber);\n\n\t\t\tioException.printStackTrace();\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = 0; i < labelsJSONArray.length(); i++) {\n\t\t\tJSONObject labelJSONObject = labelsJSONArray.getJSONObject(i);\n\n\t\t\tLabel label = new Label(\n\t\t\t\tlabelJSONObject.getString(\"name\"),\n\t\t\t\tlabelJSONObject.getString(\"color\"),\n\t\t\t\tlabelJSONObject.getString(\"description\"));\n\n\t\t\tlabels.add(label);\n\t\t}\n\n\t\tList<Label> labelsList = Lists.newArrayList(labels);\n\n\t\t_labelsLists.put(labelRequestURL, labelsList);\n\n\t\treturn labelsList;\n\t}\n}\n```\n"]}
{"id": 73, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage org.molgenis.data.security;\n\nimport static com.google.common.collect.ImmutableSet.copyOf;\nimport static com.google.common.collect.Sets.difference;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.molgenis.data.security.auth.RoleMetadata.ID;\nimport static org.molgenis.data.security.auth.RoleMetadata.INCLUDES;\nimport static org.molgenis.data.security.auth.RoleMetadata.NAME;\nimport static org.molgenis.data.security.auth.RoleMetadata.ROLE;\nimport static org.molgenis.security.core.SidUtils.ROLE_PREFIX;\nimport static org.molgenis.security.core.runas.RunAsSystemAspect.runAsSystem;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Multimap;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport org.molgenis.data.DataService;\nimport org.molgenis.data.Fetch;\nimport org.molgenis.data.Query;\nimport org.molgenis.data.Sort;\nimport org.molgenis.data.security.auth.Role;\nimport org.molgenis.data.support.QueryImpl;\nimport org.molgenis.security.core.SidUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.access.hierarchicalroles.RoleHierarchy;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\n\npublic class DataserviceRoleHierarchy implements RoleHierarchy {\n  private static final Logger LOG = LoggerFactory.getLogger(DataserviceRoleHierarchy.class);\n  private static final int PAGE_SIZE = 1000;\n\n  private final DataService dataService;\n\n  public DataserviceRoleHierarchy(DataService dataService) {\n    this.dataService = requireNonNull(dataService);\n  }\n\n  @Override\n  public Collection<? extends GrantedAuthority> getReachableGrantedAuthorities(\n      Collection<? extends GrantedAuthority> authorities) {\n    // TODO RunAsSystem annotation not hit via OIDC route (but why?!)\n    return runAsSystem(\n        () -> {\n          if (authorities == null || authorities.isEmpty()) {\n            return AuthorityUtils.NO_AUTHORITIES;\n          }\n\n          Set<String> roleNames =\n              authorities.stream()\n                  .map(GrantedAuthority::getAuthority)\n                  .filter(name -> name.startsWith(ROLE_PREFIX))\n                  .map(name -> name.substring(ROLE_PREFIX.length()))\n                  .collect(toSet());\n\n          Multimap<String, String> allRoleInclusions = getAllRoleInclusions();\n          Set<String> newlyDiscovered = roleNames;\n          while (!newlyDiscovered.isEmpty()) {\n            Set<String> included =\n                newlyDiscovered.stream()\n                    .flatMap(role -> allRoleInclusions.get(role).stream())\n                    .collect(toSet());\n            newlyDiscovered = copyOf(difference(included, roleNames));\n            roleNames.addAll(newlyDiscovered);\n          }\n\n          Set<SimpleGrantedAuthority> reachableRoles =\n              roleNames.stream()\n                  .map(SidUtils::createRoleAuthority)\n                  .map(SimpleGrantedAuthority::new)\n                  .collect(toSet());\n          LOG.debug(\n              \"getReachableGrantedAuthorities() - From the roles {} one can reach {} in zero or more steps.\",\n              authorities,\n              reachableRoles);\n          return reachableRoles;\n        });\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Generates a map of granted authorities to sets of included authorities based on all roles.\n *\n * @return An immutable map where each key is a granted authority and each value is an immutable set of granted authorities.\n *         The map represents the inclusion relationships between roles, where each key's set of values represents the\n *         roles that are included by the key role.\n */\n```\n\n### Code snippet:\n```Java\npublic ImmutableMap<GrantedAuthority, ImmutableSet<GrantedAuthority>>\n    getAllGrantedAuthorityInclusions() {\n  ImmutableMap.Builder<GrantedAuthority, ImmutableSet<GrantedAuthority>> builder =\n      ImmutableMap.builder();\n  for (Role role : getAllRoles()) {\n    ImmutableSet.Builder<GrantedAuthority> includesBuilder = ImmutableSet.builder();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getAllGrantedAuthorityInclusions", "reference": "    for (Role included : role.getIncludes()) {\n      includesBuilder.add(createGrantedAuthority(included));\n    }\n    builder.put(createGrantedAuthority(role), includesBuilder.build());\n  }\n  return builder.build();\n}", "completions": ["```Java\n`public ImmutableMap<GrantedAuthority, ImmutableSet<GrantedAuthority>> getAllGrantedAuthorityInclusions() {\n  ImmutableMap.Builder<GrantedAuthority, ImmutableSet<GrantedAuthority>> builder =\n      ImmutableMap.builder();\n  for (Role role : getAllRoles()) {\n    ImmutableSet.Builder<GrantedAuthority> includesBuilder = ImmutableSet.builder();\n    for (String includedRoleName : role.getIncludes()) {\n      GrantedAuthority includedRole = SidUtils.createRoleAuthority(includedRoleName);\n      includesBuilder.add(includedRole);\n    }\n    builder.put(role, includesBuilder.build());\n  }\n  return builder.build();\n}`\n```\n"]}
{"id": 74, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/**\n * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies\n *\n * Please see distribution for license.\n */\npackage com.opengamma.analytics.math.statistics.leastsquare;\n\nimport org.apache.commons.lang.NotImplementedException;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.apache.commons.lang.Validate;\n\nimport com.opengamma.analytics.math.matrix.DoubleMatrix1D;\nimport com.opengamma.analytics.math.matrix.DoubleMatrix2D;\n\n/**\n * Container for the results of a least square (minimum chi-square) fit, where some model (with a set of parameters), is calibrated\n * to a data set.\n */\npublic class LeastSquareResults {\n  @Override\n  public String toString() {\n    return \"LeastSquareResults [chiSq=\" + _chiSq + \", fit parameters=\" + _parameters.toString() + \", covariance=\" + _covariance.toString() + \"]\";\n  }\n\n  private final double _chiSq;\n  private final DoubleMatrix1D _parameters;\n  private final DoubleMatrix2D _covariance;\n  private final DoubleMatrix2D _inverseJacobian;\n\n  public LeastSquareResults(LeastSquareResults from) {\n    this(from._chiSq, from._parameters, from._covariance, from._inverseJacobian);\n  }\n\n  public LeastSquareResults(final double chiSq, final DoubleMatrix1D parameters, final DoubleMatrix2D covariance) {\n    this(chiSq, parameters, covariance, null);\n  }\n\n  public LeastSquareResults(final double chiSq, final DoubleMatrix1D parameters, final DoubleMatrix2D covariance, final DoubleMatrix2D inverseJacobian) {\n    Validate.isTrue(chiSq >= 0, \"chi square < 0\");\n    Validate.notNull(parameters, \"parameters\");\n    Validate.notNull(covariance, \"covariance\");\n    final int n = parameters.getNumberOfElements();\n    Validate.isTrue(covariance.getNumberOfColumns() == n, \"covariance matrix not square\");\n    Validate.isTrue(covariance.getNumberOfRows() == n, \"covariance matrix wrong size\");\n    //TODO test size of inverse Jacobian\n    _chiSq = chiSq;\n    _parameters = parameters;\n    _covariance = covariance;\n    _inverseJacobian = inverseJacobian;\n  }\n\n  /**\n   * Gets the Chi-square of the fit\n   * @return the chiSq\n   */\n  public double getChiSq() {\n    return _chiSq;\n  }\n\n  /**\n   * Gets the value of the fitting parameters, when the chi-squared is minimised\n   * @return the parameters\n   */\n  public DoubleMatrix1D getFitParameters() {\n    return _parameters;\n  }\n\n  /**\n   * Gets the estimated covariance matrix of the standard errors in the fitting parameters. <b>Note</b> only in the case of\n   * normally distributed errors, does this have any meaning full mathematical interpretation (See NR third edition, p812-816)\n   * @return the formal covariance matrix\n   */\n  public DoubleMatrix2D getCovariance() {\n    return _covariance;\n  }\n\n  /**\n   * This a matrix where the i,jth element is the (infinitesimal) sensitivity of the ith fitting parameter to the jth data\n   * point (NOT the model point), when the fitting parameter are such that the chi-squared is minimised. So it is a type of (inverse)\n   * Jacobian, but should not be confused with the model jacobian (sensitivity of model data points, to parameters) or its inverse.\n   * @return a matrix\n   */\n  public DoubleMatrix2D getFittingParameterSensitivityToData() {\n    if (_inverseJacobian == null) {\n      throw new NotImplementedException(\"The inverse Jacobian was not set\");\n    }\n    return _inverseJacobian;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    long temp;\n    temp = Double.doubleToLongBits(_chiSq);\n    result = prime * result + (int) (temp ^ (temp >>> 32));\n    result = prime * result + _covariance.hashCode();\n    result = prime * result + _parameters.hashCode();\n    result = prime * result + (_inverseJacobian == null ? 0 : _inverseJacobian.hashCode());\n    return result;\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Compares this LeastSquareResults object with the specified object for equality.\n * Two LeastSquareResults objects are considered equal if they are of the same class,\n * and their _chiSq, _covariance, _inverseJacobian, and _parameters fields are equal,\n * according to the org.apache.commons.lang.ObjectUtils.equals method.\n *\n * @param obj the object to compare with this LeastSquareResults object\n * @return true if the specified object is equal to this LeastSquareResults object; false otherwise\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic boolean equals(final Object obj) {\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (getClass() != obj.getClass()) {\n    return false;\n  }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "equals", "reference": "  final LeastSquareResults other = (LeastSquareResults) obj;\n  if (Double.doubleToLongBits(_chiSq) != Double.doubleToLongBits(other._chiSq)) {\n    return false;\n  }\n  if (!ObjectUtils.equals(_covariance, other._covariance)) {\n    return false;\n  }\n  if (!ObjectUtils.equals(_inverseJacobian, other._inverseJacobian)) {\n    return false;\n  }\n  return ObjectUtils.equals(_parameters, other._parameters);\n}", "completions": ["```Java\n@Override\npublic boolean equals(final Object obj) {\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null || getClass() != obj.getClass()) {\n    return false;\n  }\n  final LeastSquareResults other = (LeastSquareResults) obj;\n  return ObjectUtils.equals(_chiSq, other._chiSq)\n      && ObjectUtils.equals(_parameters, other._parameters)\n      && _covariance.equals(other._covariance)\n      && (_inverseJacobian == null ? other._inverseJacobian == null : _inverseJacobian.equals(other._inverseJacobian));\n}\n```\n"]}
{"id": 75, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.protocol7.quincy.protocol;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static java.util.Objects.requireNonNull;\n\nimport com.protocol7.quincy.protocol.frames.Frame;\nimport com.protocol7.quincy.protocol.frames.FrameType;\nimport com.protocol7.quincy.tls.aead.AEAD;\nimport com.protocol7.quincy.utils.Bytes;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport java.security.GeneralSecurityException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class Payload {\n\n  public static Payload parse(\n      final ByteBuf bb, final int length, final AEAD aead, final long pn, final byte[] aad) {\n    final byte[] cipherText = new byte[length];\n    bb.readBytes(cipherText);\n\n    final byte[] raw;\n    try {\n      raw = aead.open(cipherText, pn, aad);\n    } catch (final GeneralSecurityException e) {\n      throw new RuntimeException(e);\n    }\n\n    final List<Frame> frames = new ArrayList<>();\n    final ByteBuf frameBuf = Unpooled.wrappedBuffer(raw);\n\n    while (frameBuf.isReadable()) {\n      final Frame frame = Frame.parse(frameBuf);\n      frames.add(frame);\n    }\n    return new Payload(frames);\n  }\n\n  private final List<Frame> frames;\n\n  public Payload(final List<Frame> frames) {\n    requireNonNull(frames);\n    checkArgument(!frames.isEmpty());\n\n    this.frames = List.copyOf(frames);\n  }\n\n  public Payload(final Frame... frames) {\n    this(List.of(frames));\n  }\n\n  public List<Frame> getFrames() {\n    return frames;\n  }\n\n  public Payload addFrame(final Frame frame) {\n    final List<Frame> newFrames = new ArrayList<>(frames);\n    newFrames.add(frame);\n    return new Payload(newFrames);\n  }\n\n  public Optional<Frame> getFirst(final FrameType frameType) {\n    for (final Frame frame : frames) {\n      if (frame.getType() == frameType) {\n        return Optional.of(frame);\n      }\n    }\n    return Optional.empty();\n  }\n\n  public int calculateLength() {\n    return frames.stream().mapToInt(f -> f.calculateLength()).sum() + AEAD.OVERHEAD;\n  }\n\n```\n\n### Code description\n```Java\n/**\n * Writes the frames to the given ByteBuf after encrypting them using the provided AEAD (Authenticated Encryption with Associated Data) cipher.\n *\n * @param bb The ByteBuf to write the encrypted frames to.\n * @param aead The AEAD cipher to use for encryption.\n * @param pn The packet number to use for encryption.\n * @param aad The associated authenticated data to use for encryption.\n * @throws RuntimeException If a general security exception occurs during the encryption process.\n */\n```\n\n### Code snippet:\n```Java\npublic void write(final ByteBuf bb, final AEAD aead, final long pn, final byte[] aad) {\n  final ByteBuf raw = Unpooled.buffer();\n  for (final Frame frame : frames) {\n    frame.write(raw);\n  }\n  final byte[] b = Bytes.drainToArray(raw);\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "write", "reference": "  try {\n    final byte[] sealed = aead.seal(b, pn, aad);\n    bb.writeBytes(sealed);\n  } catch (final GeneralSecurityException e) {\n    throw new RuntimeException(e);\n  }\n}", "completions": ["```Java\n  try {\n    final byte[] cipherText = aead.encrypt(b, pn, aad);\n    bb.writeBytes(cipherText);\n  } catch (final GeneralSecurityException e) {\n    throw new RuntimeException(e);\n  }\n}\n```\n"]}
{"id": 76, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage com.xiaohansong.kvstore.model.sstable;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.alibaba.fastjson.TypeReference;\nimport com.xiaohansong.kvstore.model.Position;\nimport com.xiaohansong.kvstore.model.command.Command;\nimport com.xiaohansong.kvstore.model.command.RmCommand;\nimport com.xiaohansong.kvstore.model.command.SetCommand;\nimport com.xiaohansong.kvstore.utils.ConvertUtil;\nimport com.xiaohansong.kvstore.utils.LoggerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.Optional;\nimport java.util.TreeMap;\n\n/**\n * \u6392\u5e8f\u5b57\u7b26\u4e32\u8868\n */\npublic class SsTable implements Closeable {\n\n    public static final String RW = \"rw\";\n\n    private final Logger LOGGER = LoggerFactory.getLogger(SsTable.class);\n\n    /**\n     * \u8868\u7d22\u5f15\u4fe1\u606f\n     */\n    private TableMetaInfo tableMetaInfo;\n\n    /**\n     * \u5b57\u6bb5\u7a00\u758f\u7d22\u5f15\n     */\n    private TreeMap<String, Position> sparseIndex;\n\n    /**\n     * \u6587\u4ef6\u53e5\u67c4\n     */\n    private final RandomAccessFile tableFile;\n\n    /**\n     * \u6587\u4ef6\u8def\u5f84\n     */\n    private final String filePath;\n\n    /**\n     *\n     * @param filePath \u8868\u6587\u4ef6\u8def\u5f84\n     * @param partSize \u6570\u636e\u5206\u533a\u5927\u5c0f\n     */\n    private SsTable(String filePath, int partSize) {\n        this.tableMetaInfo = new TableMetaInfo();\n        this.tableMetaInfo.setPartSize(partSize);\n        this.filePath = filePath;\n        try {\n            this.tableFile = new RandomAccessFile(filePath, RW);\n            tableFile.seek(0);\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n        sparseIndex = new TreeMap<>();\n    }\n\n    /**\n     * \u4ece\u5185\u5b58\u8868\u4e2d\u6784\u5efassTable\n     * @param filePath\n     * @param partSize\n     * @param index\n     * @return\n     */\n    public static SsTable createFromIndex(String filePath, int partSize, TreeMap<String, Command> index) {\n        SsTable ssTable = new SsTable(filePath, partSize);\n        ssTable.initFromIndex(index);\n        return ssTable;\n    }\n\n    /**\n     * \u4ece\u6587\u4ef6\u4e2d\u6784\u5efassTable\n     * @param filePath\n     * @return\n     */\n    public static SsTable createFromFile(String filePath) {\n        SsTable ssTable = new SsTable(filePath, 0);\n        ssTable.restoreFromFile();\n        return ssTable;\n    }\n\n    /**\n     * \u4ecessTable\u4e2d\u67e5\u8be2\u6570\u636e\n     * @param key\n     * @return\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method queries a command from a given key in a table file.\n * It uses a sparse index to find the last position in the index that is smaller than the key,\n * and the first position in the index that is larger than the key. It then reads the data from the file\n * within the determined range to minimize IO operations. The data is parsed into a JSON object,\n * and if the key exists in the JSON object, it is converted into a command and returned.\n *\n * @param key the key to query in the table file\n * @return the command corresponding to the key if it exists, otherwise null\n * @throws RuntimeException if any error occurs during the execution of the method\n */\n```\n\n### Code snippet:\n```Java\npublic Command query(String key) {\n    try {\n        LinkedList<Position> sparseKeyPositionList = new LinkedList<>();\n\n        Position lastSmallPosition = null;\n        Position firstBigPosition = null;\n\n        //\u4ece\u7a00\u758f\u7d22\u5f15\u4e2d\u627e\u5230\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8ekey\u7684\u4f4d\u7f6e\uff0c\u4ee5\u53ca\u7b2c\u4e00\u4e2a\u5927\u4e8ekey\u7684\u4f4d\u7f6e\n        for (String k : sparseIndex.keySet()) {\n            if (k.compareTo(key) <= 0) {\n                lastSmallPosition = sparseIndex.get(k);\n            } else {\n                firstBigPosition = sparseIndex.get(k);\n                break;\n            }\n        }\n        if (lastSmallPosition != null) {\n            sparseKeyPositionList.add(lastSmallPosition);\n        }\n        if (firstBigPosition != null) {\n            sparseKeyPositionList.add(firstBigPosition);\n        }\n        if (sparseKeyPositionList.size() == 0) {\n            return null;\n        }\n        LoggerUtil.debug(LOGGER, \"[SsTable][restoreFromFile][sparseKeyPositionList]: {}\", sparseKeyPositionList);\n        Position firstKeyPosition = sparseKeyPositionList.getFirst();\n        Position lastKeyPosition = sparseKeyPositionList.getLast();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "query", "reference": "        long start = 0;\n        long len = 0;\n        start = firstKeyPosition.getStart();\n        if (firstKeyPosition.equals(lastKeyPosition)) {\n            len = firstKeyPosition.getLen();\n        } else {\n            len = lastKeyPosition.getStart() + lastKeyPosition.getLen() - start;\n        }\n        //key\u5982\u679c\u5b58\u5728\u5fc5\u5b9a\u4f4d\u4e8e\u533a\u95f4\u5185\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bfb\u53d6\u533a\u95f4\u5185\u7684\u6570\u636e\uff0c\u51cf\u5c11io\n        byte[] dataPart = new byte[(int) len];\n        tableFile.seek(start);\n        tableFile.read(dataPart);\n        int pStart = 0;\n        //\u8bfb\u53d6\u5206\u533a\u6570\u636e\n        for (Position position : sparseKeyPositionList) {\n            JSONObject dataPartJson = JSONObject.parseObject(new String(dataPart, pStart, (int) position.getLen()));\n            LoggerUtil.debug(LOGGER, \"[SsTable][restoreFromFile][dataPartJson]: {}\", dataPartJson);\n            if (dataPartJson.containsKey(key)) {\n                JSONObject value = dataPartJson.getJSONObject(key);\n                return ConvertUtil.jsonToCommand(value);\n            }\n            pStart += (int) position.getLen();\n        }\n        return null;\n    } catch (Throwable t) {\n        throw new RuntimeException(t);\n    }\n\n}", "completions": ["```markdown\n```java\n        // Read the data from the file within the determined range to minimize IO operations.\n        tableFile.seek(firstKeyPosition.getFilePointer());\n        byte[] data = new byte[(int) (lastKeyPosition.getFilePointer() - firstKeyPosition.getFilePointer() + 1)];\n        tableFile.read(data);\n\n        // Parse the data into a JSON object.\n        JSONObject jsonObject = JSONObject.parseObject(new String(data, StandardCharsets.UTF_8));\n\n        // If the key exists in the JSON object, it is converted into a command and returned.\n        if (jsonObject.containsKey(key)) {\n            Command command = ConvertUtil.convert(jsonObject.get(key), new TypeReference<Command>() {});\n            return command;\n        }\n        return null;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n```\n"]}
{"id": 77, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2015 Karl Dahlgren\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.castlemock.service.mock.soap.project;\n\nimport com.castlemock.model.core.SearchQuery;\nimport com.castlemock.model.core.SearchResult;\nimport com.castlemock.model.core.Service;\nimport com.castlemock.model.core.ServiceResult;\nimport com.castlemock.model.core.ServiceTask;\nimport com.castlemock.model.mock.soap.domain.SoapMockResponse;\nimport com.castlemock.model.mock.soap.domain.SoapOperation;\nimport com.castlemock.model.mock.soap.domain.SoapPort;\nimport com.castlemock.model.mock.soap.domain.SoapProject;\nimport com.castlemock.model.mock.soap.domain.SoapResource;\nimport com.castlemock.service.mock.soap.project.input.SearchSoapProjectInput;\nimport com.castlemock.service.mock.soap.project.output.SearchSoapProjectOutput;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.MessageSource;\nimport org.springframework.context.i18n.LocaleContextHolder;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The service provides the functionality to search for SOAP resources.\n * @author Karl Dahlgren\n * @since 1.0\n */\n@org.springframework.stereotype.Service\npublic class SearchSoapProjectService extends AbstractSoapProjectService implements Service<SearchSoapProjectInput, SearchSoapProjectOutput> {\n\n\n    private static final String SLASH = \"/\";\n    private static final String SOAP = \"soap\";\n    private static final String PROJECT = \"project\";\n    private static final String PORT = \"port\";\n    private static final String OPERATION = \"operation\";\n    private static final String RESPONSE = \"response\";\n    private static final String RESOURCE = \"resource\";\n    private static final String COMMA = \", \";\n    private static final String SOAP_TYPE = \"SOAP\";\n    private static final String WSDL_DIRECTORY = \"wsdl\";\n    private static final String SCHEMA_DIRECTORY = \"wsdl\";\n\n    @Autowired\n    private MessageSource messageSource;\n\n    /**\n     * The process message is responsible for processing an incoming serviceTask and generate\n     * a response based on the incoming serviceTask input\n     * @param serviceTask The serviceTask that will be processed by the service\n     * @return A result based on the processed incoming serviceTask\n     * @see ServiceTask\n     * @see ServiceResult\n     */\n```\n\n### Code description\n```Java\n/**\n * Description: This method processes a service task for searching SOAP projects. It retrieves the search query from the input,\n * performs the search in the respective repositories, and creates a list of search results. Each search result includes a title,\n * a link, and a description. The description includes the type of the result (project, port, operation, resource, or mock response).\n * The locale is obtained from the LocaleContextHolder.\n *\n * @param serviceTask The service task containing the input for the search.\n * @return A ServiceResult containing the output of the search, which includes a list of search results.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic ServiceResult<SearchSoapProjectOutput> process(final ServiceTask<SearchSoapProjectInput> serviceTask) {\n    final SearchSoapProjectInput input = serviceTask.getInput();\n    final SearchQuery searchQuery = input.getSearchQuery();\n    final List<SearchResult> searchResults = new ArrayList<>();\n\n    final List<SoapProject> projects = this.repository.search(searchQuery);\n    final List<SoapPort> ports = this.portRepository.search(searchQuery);\n    final List<SoapResource> resources = this.resourceRepository.search(searchQuery);\n    final List<SoapOperation> operations = this.operationRepository.search(searchQuery);\n    final List<SoapMockResponse> mockResponses = this.mockResponseRepository.search(searchQuery);\n\n    final String projectType = messageSource.getMessage(\"general.type.project\", null , LocaleContextHolder.getLocale());\n    final String portType = messageSource.getMessage(\"soap.type.port\", null , LocaleContextHolder.getLocale());\n    final String operationType = messageSource.getMessage(\"soap.type.operation\", null , LocaleContextHolder.getLocale());\n    final String resourceType = messageSource.getMessage(\"soap.type.resource\", null , LocaleContextHolder.getLocale());\n    final String responseType = messageSource.getMessage(\"soap.type.mockresponse\", null , LocaleContextHolder.getLocale());\n\n    projects.forEach(project -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(project.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + project.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + projectType);\n        searchResults.add(searchResult);\n    });\n\n    ports.forEach(port -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(port.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + port.getProjectId() + SLASH + PORT + SLASH + port.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + portType);\n        searchResults.add(searchResult);\n    });\n\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "process", "reference": "    resources.forEach(resource -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(resource.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + resource.getProjectId() + SLASH + RESOURCE + SLASH + resource.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + resourceType);\n        searchResults.add(searchResult);\n    });\n\n    operations.forEach(operation -> {\n        final String projectId = this.portRepository.getProjectId(operation.getPortId());\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(operation.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + projectId + SLASH + PORT +\n                SLASH + operation.getPortId() + SLASH + OPERATION + SLASH + operation.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + operationType);\n        searchResults.add(searchResult);\n    });\n\n    mockResponses.forEach(mockResponse -> {\n        final String portId = this.operationRepository.getPortId(mockResponse.getOperationId());\n        final String projectId = this.portRepository.getProjectId(portId);\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(mockResponse.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + projectId + SLASH + PORT +\n                SLASH + portId + SLASH + OPERATION + SLASH + mockResponse.getOperationId() +\n                SLASH + RESPONSE + SLASH + mockResponse.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + responseType);\n        searchResults.add(searchResult);\n    });\n\n    return createServiceResult(SearchSoapProjectOutput.builder()\n            .searchResults(searchResults)\n            .build());\n}", "completions": ["```Java\n    ports.forEach(port -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(port.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + port.getProjectId() + SLASH + PORT + SLASH + port.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + portType);\n        searchResults.add(searchResult);\n    });\n\n    resources.forEach(resource -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(resource.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + resource.getProjectId() + SLASH + RESOURCE + SLASH + resource.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + resourceType);\n        searchResults.add(searchResult);\n    });\n\n    operations.forEach(operation -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(operation.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + operation.getProjectId() + SLASH + OPERATION + SLASH + operation.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + operationType);\n        searchResults.add(searchResult);\n    });\n\n    mockResponses.forEach(mockResponse -> {\n        final SearchResult searchResult = new SearchResult();\n        searchResult.setTitle(mockResponse.getName());\n        searchResult.setLink(SOAP + SLASH + PROJECT + SLASH + mockResponse.getProjectId() + SLASH + RESPONSE + SLASH + mockResponse.getId());\n        searchResult.setDescription(SOAP_TYPE + COMMA + responseType);\n        searchResults.add(searchResult);\n    });\n\n    final SearchSoapProjectOutput output = new SearchSoapProjectOutput();\n    output.setSearchResults(searchResults);\n\n    return new ServiceResult<>(output);\n}\n```\n"]}
{"id": 78, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n */\npackage org.apache.isis.viewer.restfulobjects.applib.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\n\nimport javax.ws.rs.core.CacheControl;\nimport javax.ws.rs.core.MediaType;\n\nimport org.apache.isis.viewer.restfulobjects.applib.JsonRepresentation;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\n\npublic abstract class Parser<T> {\n    public T valueOf(final List<String> str) {\n        if (str == null) {\n            return null;\n        }\n        if (str.size() == 0) {\n            return null;\n        }\n        return valueOf(str.get(0));\n    }\n\n    public T valueOf(final String[] str) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length == 0) {\n            return null;\n        }\n        return valueOf(str[0]);\n    }\n\n    public T valueOf(final JsonRepresentation jsonRepresentation) {\n        if (jsonRepresentation == null) {\n            return null;\n        }\n        return valueOf(jsonRepresentation.asString());\n    }\n\n    public JsonRepresentation asJsonRepresentation(final T t) {\n        return JsonRepresentation.newMap(\"dummy\", asString(t)).getRepresentation(\"dummy\");\n    }\n\n    public abstract T valueOf(String str);\n\n    public abstract String asString(T t);\n\n    public final static Parser<String> forString() {\n        return new Parser<String>() {\n            @Override\n            public String valueOf(final String str) {\n                return str;\n            }\n\n            @Override\n            public String asString(final String t) {\n                return t;\n            }\n        };\n    }\n\n    public static Parser<Date> forDate() {\n\n        return new Parser<Date>() {\n            private final SimpleDateFormat RFC1123_DATE_FORMAT = new SimpleDateFormat(\"EEE, dd MMM yyyyy HH:mm:ss z\");\n\n            @Override\n            public Date valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                try {\n                    return RFC1123_DATE_FORMAT.parse(str);\n                } catch (final ParseException e) {\n                    return null;\n                }\n            }\n\n            @Override\n            public String asString(final Date t) {\n                return RFC1123_DATE_FORMAT.format(t);\n            }\n        };\n    }\n\n    public static Parser<CacheControl> forCacheControl() {\n        return new Parser<CacheControl>() {\n            @Override\n            public CacheControl valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                final CacheControl cacheControl = CacheControl.valueOf(str);\n                // workaround for bug in CacheControl's equals() method\n                cacheControl.getCacheExtension();\n                cacheControl.getNoCacheFields();\n                return cacheControl;\n            }\n\n            @Override\n            public String asString(final CacheControl cacheControl) {\n                return cacheControl.toString();\n            }\n        };\n    }\n\n    public static Parser<MediaType> forJaxRsMediaType() {\n        return new Parser<MediaType>() {\n            @Override\n            public MediaType valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                return MediaType.valueOf(str);\n            }\n\n            @Override\n            public String asString(final MediaType t) {\n                return t.toString();\n            }\n\n        };\n    }\n\n    public static Parser<com.google.common.net.MediaType> forGuavaMediaType() {\n        return new Parser<com.google.common.net.MediaType>() {\n            @Override\n            public com.google.common.net.MediaType valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                return com.google.common.net.MediaType.parse(str);\n            }\n\n            @Override\n            public String asString(final com.google.common.net.MediaType t) {\n                return t.toString();\n            }\n        };\n    }\n\n    public static Parser<Boolean> forBoolean() {\n        return new Parser<Boolean>() {\n            @Override\n            public Boolean valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                return str.equals(\"yes\") ? Boolean.TRUE : Boolean.FALSE;\n            }\n\n            @Override\n            public String asString(final Boolean t) {\n                return t ? \"yes\" : \"no\";\n            }\n\n        };\n    }\n\n    public static Parser<Integer> forInteger() {\n        return new Parser<Integer>() {\n\n            @Override\n            public Integer valueOf(final String str) {\n                if (str == null) {\n                    return null;\n                }\n                return Integer.valueOf(str);\n            }\n\n            @Override\n            public String asString(final Integer t) {\n                return t.toString();\n            }\n        };\n    }\n\n    public static Parser<List<String>> forListOfStrings() {\n        return new Parser<List<String>>() {\n\n            @Override\n            public List<String> valueOf(final List<String> strings) {\n                if (strings == null) {\n                    return Collections.emptyList();\n                }\n                if (strings.size() == 1) {\n                    // special case processing to handle comma-separated values\n                    return valueOf(strings.get(0));\n                }\n                return strings;\n            }\n\n            @Override\n            public List<String> valueOf(final String[] strings) {\n                if (strings == null) {\n                    return Collections.emptyList();\n                }\n                if (strings.length == 1) {\n                    // special case processing to handle comma-separated values\n                    return valueOf(strings[0]);\n                }\n                return Arrays.asList(strings);\n            }\n\n            @Override\n            public List<String> valueOf(final String str) {\n                if (str == null) {\n                    return Collections.emptyList();\n                }\n                return Lists.newArrayList(Splitter.on(\",\").split(str));\n            }\n\n            @Override\n            public String asString(final List<String> strings) {\n                return Joiner.on(\",\").join(strings);\n            }\n        };\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Parses a list of strings into a list of lists of strings.\n *\n * @param str The list of strings to parse.\n * @return A list of lists of strings parsed from the input.\n */\n/**\n * Parses an array of strings into a list of lists of strings.\n *\n * @param str The array of strings to parse.\n * @return A list of lists of strings parsed from the input.\n */\n/**\n * Parses a string into a list of lists of strings.\n *\n * @param str The string to parse.\n * @return A list of lists of strings parsed from the input.\n */\n/**\n * Converts a list of lists of strings into a string.\n *\n * @param listOfLists The list of lists of strings to convert.\n * @return A string representation of the input.\n */\n```\n\n### Code snippet:\n```Java\npublic static Parser<List<List<String>>> forListOfListOfStrings() {\n    return new Parser<List<List<String>>>() {\n\n        @Override\n        public List<List<String>> valueOf(final List<String> str) {\n            if (str == null) {\n                return null;\n            }\n            if (str.size() == 0) {\n                return null;\n            }\n            final List<List<String>> listOfLists = Lists.newArrayList();\n            for (final String s : str) {\n                listOfLists.add(PathNode.split(s));\n            }\n            return listOfLists;\n        }\n\n        @Override\n        public List<List<String>> valueOf(final String[] str) {\n            if (str == null) {\n                return null;\n            }\n            if (str.length == 0) {\n                return null;\n            }\n            return valueOf(Arrays.asList(str));\n        }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "forListOfListOfStrings", "reference": "\n        @Override\n        public List<List<String>> valueOf(final String str) {\n            if (str == null || str.isEmpty()) {\n                return Collections.emptyList();\n            }\n            final Iterable<String> listOfStrings = Splitter.on(',').split(str);\n            return Lists.transform(Lists.newArrayList(listOfStrings), new Function<String, List<String>>() {\n\n                @Override\n                public List<String> apply(final String input) {\n                    return PathNode.split(input);\n                }\n            });\n        }\n\n        @Override\n        public String asString(final List<List<String>> listOfLists) {\n            final List<String> listOfStrings = Lists.transform(listOfLists, new Function<List<String>, String>() {\n                @Override\n                public String apply(final List<String> listOfStrings) {\n                    return Joiner.on('.').join(listOfStrings);\n                }\n            });\n            return Joiner.on(',').join(listOfStrings);\n        }\n    };\n}", "completions": ["```Java\n        @Override\n        public List<List<String>> valueOf(final String str) {\n            if (str == null) {\n                return null;\n            }\n            final List<List<String>> listOfLists = Lists.newArrayList();\n            for (final String s : Splitter.on(\",\").split(str)) {\n                listOfLists.add(Lists.newArrayList(s));\n            }\n            return listOfLists;\n        }\n    };\n}\n```\n"]}
{"id": 79, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage au.edu.wehi.idsv;\n\nimport au.edu.wehi.idsv.vcf.VcfFormatAttributes;\nimport au.edu.wehi.idsv.vcf.VcfInfoAttributes;\nimport au.edu.wehi.idsv.vcf.VcfSvConstants;\nimport com.google.common.collect.ComparisonChain;\nimport com.google.common.collect.Ordering;\nimport htsjdk.samtools.SAMSequenceDictionary;\nimport htsjdk.variant.variantcontext.VariantContext;\nimport org.apache.commons.lang3.NotImplementedException;\n\npublic class VariantContextDirectedBreakpoint extends VariantContextDirectedEvidence implements DirectedBreakpoint {\n\t/** */\n\tprivate static final long serialVersionUID = 1L;\n\tpublic VariantContextDirectedBreakpoint(SAMSequenceDictionary dict, EvidenceSource source, VariantContext context) {\n\t\tsuper(dict, source, context);\n\t\tassert(super.getBreakendSummary() instanceof BreakpointSummary);\n\t}\n\t/**\n\t * Size of event assuming the simplest explanation.\n\t * @return size of breakpoint event\n\t */\n\tpublic Integer getEventSize() {\n\t\tBreakendSummary low = getBreakendSummary().lowBreakend();\n\t\tBreakendSummary high = getBreakendSummary().highBreakend();\n\t\tif (low.referenceIndex != high.referenceIndex) {\n\t\t\treturn null;\n\t\t}\n\t\tint sizeAdjustment = -1; // assume indel\n\t\tif (low.direction == high.direction) {\n\t\t\t// inversion\n\t\t\tsizeAdjustment = 0;\n\t\t\t// requires a second breakpoint to explain - we're not going to assume this breakpoint exists\n\t\t\t// as the event could be a large fold-back inversion\n\t\t\treturn null; \n\t\t} else if (low.direction == BreakendDirection.Backward && high.direction == BreakendDirection.Forward) {\n\t\t\t// tandem dup\n\t\t\tsizeAdjustment = 1;\n\t\t}\n\t\treturn high.nominal - low.nominal + getUntemplatedSequence().length() + sizeAdjustment; \n\t}\n\t/**\n\t * Size of indel event. \n\t * @return size of indel inferred by breakpoint, null otherwise\n\t */\n\tpublic Integer getIndelSize() {\n\t\tBreakendSummary low = getBreakendSummary().lowBreakend();\n\t\tBreakendSummary high = getBreakendSummary().highBreakend();\n\t\tif (low.direction == high.direction) {\n\t\t\t// inversion\n\t\t\treturn null;\n\t\t} else if (low.direction == BreakendDirection.Backward && high.direction == BreakendDirection.Forward) {\n\t\t\t// tandem dup\n\t\t\treturn null;\n\t\t}\n\t\treturn getEventSize(); \n\t}\n\t@Override\n\tpublic BreakpointSummary getBreakendSummary() {\n\t\treturn (BreakpointSummary)super.getBreakendSummary();\n\t}\n\t@Override\n\tpublic int getRemoteMapq() {\n\t\tthrow new IllegalArgumentException(\"NYI\");\n\t}\n\t@Override\n\tpublic String getUntemplatedSequence() {\n\t\treturn getBreakpointSequenceString();\n\t}\n\t@Override\n\tpublic String getHomologySequence() {\n\t\treturn getAttributeAsString(VcfSvConstants.HOMOLOGY_SEQUENCE_KEY, \"\");\n\t}\n\t@Override\n\tpublic int getHomologyAnchoredBaseCount() {\n\t\tthrow new RuntimeException(\"NYI: need to recalculate microhomology\");\n\t}\n\tpublic static Ordering<VariantContextDirectedBreakpoint> ByRemoteBreakendLocationStart = new Ordering<VariantContextDirectedBreakpoint>() {\n\t\tpublic int compare(VariantContextDirectedBreakpoint o1, VariantContextDirectedBreakpoint o2) {\n\t\t\tBreakpointSummary b1 = o1.getBreakendSummary();\n\t\t\tBreakpointSummary b2 = o2.getBreakendSummary();\n\t\t\treturn ComparisonChain.start()\n\t\t\t        .compare(b1.referenceIndex2, b2.referenceIndex2)\n\t\t\t        .compare(b1.start2, b2.start2)\n\t\t\t        .compare(b1.end2, b2.end2)\n\t\t\t        .compare(b1.referenceIndex, b2.referenceIndex)\n\t\t\t        .compare(b1.start, b2.start)\n\t\t\t        .compare(b1.end, b2.end)\n\t\t\t        .result();\n\t\t  }\n\t};\n```\n\n### Code description\n```Java\n/**\n * Compares two VariantContext objects based on their remote breakend location start raw.\n * \n * @param processContext The GenomicProcessingContext object containing the dictionary for the comparison.\n * @return An Ordering object that defines the comparison logic for VariantContext objects.\n */\n```\n\n### Code snippet:\n```Java\npublic static Ordering<VariantContext> ByRemoteBreakendLocationStartRaw(final GenomicProcessingContext processContext) {\n\treturn new Ordering<VariantContext>() {\n\t\tpublic int compare(VariantContext o1, VariantContext o2) {\n\t\t\t// TODO: is this performance acceptable? This is quite an expensive compare operation\n\t\t\tVcfBreakendSummary b1 = new VcfBreakendSummary(processContext.getDictionary(), o1);\n\t\t\tVcfBreakendSummary b2 = new VcfBreakendSummary(processContext.getDictionary(), o2);\n\t\t\tint ref1 = -1;\n\t\t\tint ref2 = -1;\n\t\t\tint start1 = 0;\n\t\t\tint start2 = 0;\n\t\t\tif (b1.location instanceof BreakpointSummary) {\n\t\t\t\tref1 = ((BreakpointSummary)b1.location).referenceIndex2;\n\t\t\t\tstart1 = ((BreakpointSummary)b1.location).start2;\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "ByRemoteBreakendLocationStartRaw", "reference": "\t\t\t}\n\t\t\tif (b2.location instanceof BreakpointSummary) {\n\t\t\t\tref2 = ((BreakpointSummary)b2.location).referenceIndex2;\n\t\t\t\tstart2 = ((BreakpointSummary)b2.location).start2;\n\t\t\t}\n\t\t\tint result = ComparisonChain.start()\n\t\t\t        .compare(ref1, ref2)\n\t\t\t        .compare(start1, start2)\n\t\t\t        .result();\n\t\t\treturn result;\n\t\t  }\n\t};\n}", "completions": ["```Java\npublic static Ordering<VariantContext> ByRemoteBreakendLocationStartRaw(final GenomicProcessingContext processContext) {\n\treturn new Ordering<VariantContext>() {\n\t\tpublic int compare(VariantContext o1, VariantContext o2) {\n\t\t\tVcfBreakendSummary b1 = new VcfBreakendSummary(processContext.getDictionary(), o1);\n\t\t\tVcfBreakendSummary b2 = new VcfBreakendSummary(processContext.getDictionary(), o2);\n\t\t\tint ref1 = -1;\n\t\t\tint ref2 = -1;\n\t\t\tint start1 = 0;\n\t\t\tint start2 = 0;\n\t\t\tif (b1.location instanceof BreakpointSummary) {\n\t\t\t\tref1 = ((BreakpointSummary)b1.location).referenceIndex2;\n\t\t\t\tstart1 = ((BreakpointSummary)b1.location).start2;\n\t\t\t}\n\t\t\tif (b2.location instanceof BreakpointSummary) {\n\t\t\t\tref2 = ((BreakpointSummary)b2.location).referenceIndex2;\n\t\t\t\tstart2 = ((BreakpointSummary)b2.location).start2;\n\t\t\t}\n\t\t\treturn Integer.compare(ref1, ref2) != 0 ? Integer.compare(ref1, ref2) : Integer.compare(start1, start2);\n\t\t}\n\t};\n}\n```\n"]}
{"id": 80, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Copyright 2016-present Open Networking Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.onosproject.net.intent.impl.compiler;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.Sets;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.onlab.util.Identifier;\nimport org.onosproject.core.ApplicationId;\nimport org.onosproject.core.CoreService;\nimport org.onosproject.net.ConnectPoint;\nimport org.onosproject.net.DeviceId;\nimport org.onosproject.net.EncapsulationType;\nimport org.onosproject.net.FilteredConnectPoint;\nimport org.onosproject.net.PortNumber;\nimport org.onosproject.net.domain.DomainService;\nimport org.onosproject.net.flow.DefaultTrafficTreatment;\nimport org.onosproject.net.flow.TrafficSelector;\nimport org.onosproject.net.flow.TrafficTreatment;\nimport org.onosproject.net.flow.criteria.Criterion;\nimport org.onosproject.net.flow.criteria.EthCriterion;\nimport org.onosproject.net.flow.instructions.Instruction;\nimport org.onosproject.net.flowobjective.DefaultFilteringObjective;\nimport org.onosproject.net.flowobjective.DefaultForwardingObjective;\nimport org.onosproject.net.flowobjective.DefaultNextObjective;\nimport org.onosproject.net.flowobjective.FilteringObjective;\nimport org.onosproject.net.flowobjective.FlowObjectiveService;\nimport org.onosproject.net.flowobjective.ForwardingObjective;\nimport org.onosproject.net.flowobjective.NextObjective;\nimport org.onosproject.net.flowobjective.Objective;\nimport org.onosproject.net.intent.FlowObjectiveIntent;\nimport org.onosproject.net.intent.Intent;\nimport org.onosproject.net.intent.IntentCompiler;\nimport org.onosproject.net.intent.LinkCollectionIntent;\nimport org.onosproject.net.intent.constraint.EncapsulationConstraint;\nimport org.onosproject.net.resource.ResourceService;\nimport org.onosproject.net.resource.impl.LabelAllocator;\nimport org.slf4j.Logger;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.onosproject.net.domain.DomainId.LOCAL;\nimport static org.onosproject.net.flow.instructions.Instruction.Type.OUTPUT;\nimport static org.slf4j.LoggerFactory.getLogger;\n\n/**\n * Compiler to produce flow objectives from link collections.\n */\n@Component(immediate = true)\npublic class LinkCollectionIntentFlowObjectiveCompiler\n        extends LinkCollectionCompiler<Objective>\n        implements IntentCompiler<LinkCollectionIntent> {\n    private final Logger log = getLogger(getClass());\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected IntentConfigurableRegistrator registrator;\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected CoreService coreService;\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected FlowObjectiveService flowObjectiveService;\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected ResourceService resourceService;\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected DomainService domainService;\n\n    private ApplicationId appId;\n\n    @Activate\n    public void activate() {\n        appId = coreService.registerApplication(\"org.onosproject.net.intent\");\n        registrator.registerCompiler(LinkCollectionIntent.class, this, true);\n        if (labelAllocator == null) {\n            labelAllocator = new LabelAllocator(resourceService);\n        }\n    }\n\n    @Deactivate\n    public void deactivate() {\n        registrator.unregisterCompiler(LinkCollectionIntent.class, true);\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Compiles a list of intents based on the given LinkCollectionIntent and a list of installable intents.\n * The method computes input and output ports for the intent, and optionally assigns labels to the ports.\n * If domain processing is enabled for the intent, it retrieves domain-specific intents.\n * It then creates objectives for each device with local domain, and adds them to the list of intents.\n * If any objectives are created, it adds a FlowObjectiveIntent to the list.\n *\n * @param intent The LinkCollectionIntent to compile.\n * @param installable A list of installable intents.\n * @return A list of compiled intents.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {\n\n    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();\n    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();\n    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();\n\n    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);\n\n    computePorts(intent, inputPorts, outputPorts);\n\n    if (encapConstraint.isPresent()) {\n        labels = labelAllocator.assignLabelToPorts(intent.links(),\n                                                   intent.key(),\n                                                   encapConstraint.get().encapType(),\n                                                   encapConstraint.get().suggestedIdentifier());\n    }\n\n    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();\n    if (this.isDomainProcessingEnabled(intent)) {\n        intentList.addAll(this.getDomainIntents(intent, domainService));\n    }\n\n    List<Objective> objectives = new ArrayList<>();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "compile", "reference": "    List<DeviceId> devices = new ArrayList<>();\n    for (DeviceId deviceId : outputPorts.keySet()) {\n        // add only objectives that are not inside of a domain\n        if (LOCAL.equals(domainService.getDomain(deviceId))) {\n            List<Objective> deviceObjectives =\n                    createRules(intent,\n                                deviceId,\n                                inputPorts.get(deviceId),\n                                outputPorts.get(deviceId),\n                                labels);\n            deviceObjectives.forEach(objective -> {\n                objectives.add(objective);\n                devices.add(deviceId);\n            });\n        }\n    }\n    // if any objectives have been created\n    if (!objectives.isEmpty()) {\n        intentList.add(new FlowObjectiveIntent(appId, intent.key(), devices,\n                                               objectives,\n                                               intent.resources(),\n                                               intent.resourceGroup()));\n    }\n    return intentList.build();\n}", "completions": ["```Java\n    for (ConnectPoint connectPoint : intent.links().keySet()) {\n        Identifier<?> identifier = labels.get(connectPoint);\n        if (identifier != null) {\n            PortNumber portNumber = outputPorts.get(connectPoint).iterator().next();\n            Objective objective = new DefaultTrafficTreatment(\n                    new TrafficSelector(new EthCriterion(connectPoint, portNumber)),\n                    new DefaultForwardingObjective(identifier),\n                    new DefaultNextObjective(identifier)\n            );\n            objectives.add(objective);\n        }\n    }\n\n    if (!objectives.isEmpty()) {\n        FlowObjectiveIntent flowObjectiveIntent = new FlowObjectiveIntent(\n                intent.intentId(),\n                intent.intentName(),\n                intent.intentDescription(),\n                intent.intentPriority(),\n                intent.intentTimeout(),\n                intent.intentTimeoutUnit(),\n                objectives\n        );\n        intentList.add(flowObjectiveIntent);\n    }\n\n    return intentList.build();\n}\n```\n"]}
{"id": 81, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\npackage io.logz.sawmill.processors;\n\nimport io.logz.sawmill.Doc;\nimport io.logz.sawmill.ProcessResult;\nimport io.logz.sawmill.Processor;\nimport io.logz.sawmill.annotations.ProcessorProvider;\nimport io.logz.sawmill.exceptions.ProcessorConfigurationException;\nimport io.logz.sawmill.utilities.Grok;\nimport io.logz.sawmill.utilities.JsonUtils;\nimport org.apache.commons.collections4.CollectionUtils;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static java.util.Collections.EMPTY_LIST;\nimport static java.util.Objects.requireNonNull;\n\n@ProcessorProvider(type = \"grok\", factory = GrokProcessor.Factory.class)\npublic class GrokProcessor implements Processor {\n    private final String field;\n    private final List<String> expressions;\n    private final List<Grok> groks;\n    private final List<String> overwrite;\n    private final boolean ignoreMissing;\n    private final List<String> tagsOnFailure;\n\n    public GrokProcessor(String field, List<String> matchExpressions, Map<String, String> patternsBank, List<String> overwrite, boolean ignoreMissing, List<String> tagsOnFailure) {\n        checkState(CollectionUtils.isNotEmpty(matchExpressions), \"patterns cannot be empty\");\n        this.field = requireNonNull(field, \"field cannot be null\");\n        this.expressions = matchExpressions;\n        this.overwrite = overwrite != null ? overwrite : EMPTY_LIST;\n        this.ignoreMissing = ignoreMissing;\n        this.tagsOnFailure = tagsOnFailure;\n\n        this.groks = new ArrayList<>();\n\n        compileExpressions(matchExpressions, patternsBank);\n    }\n\n    private void compileExpressions(List<String> matchExpressions, Map<String, String> patternsBank) {\n        matchExpressions.forEach(expression -> {\n            Grok grok;\n            try {\n                grok = new Grok(patternsBank, expression);\n            } catch (RuntimeException e) {\n                throw new ProcessorConfigurationException(\"Failed to create grok for expression [\"+expression+\"]\", e);\n            }\n            this.groks.add(grok);\n        });\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Processes a document and applies grok operations on it.\n *\n * @param doc The document to be processed.\n * @return A ProcessResult indicating the success or failure of the operation.\n * @throws InterruptedException If the thread is interrupted during the process.\n */\n```\n\n### Code snippet:\n```Java\n@Override\npublic ProcessResult process(Doc doc) throws InterruptedException {\n    if (!doc.hasField(field, String.class)) {\n        if (ignoreMissing) return ProcessResult.success();\n\n        return ProcessResult.failure(String.format(\"failed to grok field in path [%s], field is missing or not instance of [%s]\", field, String.class));\n    }\n\n    String fieldValue = doc.getField(field);\n\n    List<Grok.Match> matches = getMatches(fieldValue);\n\n    if (CollectionUtils.isEmpty(matches)) {\n        doc.appendList(\"tags\", tagsOnFailure);\n        return ProcessResult.failure(String.format(\"failed to grok field [%s] in path [%s], doesn't match any of the expressions [%s]\", fieldValue, field, expressions));\n    }\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "process", "reference": "\n    matches.stream()\n            .filter(match -> !CollectionUtils.isEmpty(match.getValues()))\n            .forEach(match -> {\n                String field = match.getName();\n                List<Object> matchValues = match.getValues();\n                Object value = getValue(matchValues);\n                if (overwrite.contains(field) || !doc.hasField(field)) {\n                    doc.addField(field, value);\n                } else {\n                    doc.appendList(field, value);\n                }\n            });\n\n    return ProcessResult.success();\n}", "completions": ["```Java\n```Java\n    List<Grok.Match> matches = getMatches(fieldValue);\n\n    if (CollectionUtils.isEmpty(matches)) {\n        doc.appendList(\"tags\", tagsOnFailure);\n        return ProcessResult.failure(String.format(\"failed to grok field [%s] in path [%s], doesn't match any of the expressions [%s]\", fieldValue, field, expressions));\n    }\n\n    Map<String, Object> result = new HashMap<>();\n    for (Grok.Match match : matches) {\n        result.put(match.getPattern(), match.getResult());\n    }\n\n    doc.setField(field, JsonUtils.toJson(result));\n\n    return ProcessResult.success();\n}\n\nprivate List<Grok.Match> getMatches(String fieldValue) {\n    List<Grok.Match> matches = new ArrayList<>();\n    for (Grok grok : groks) {\n        matches.addAll(grok.match(fieldValue));\n    }\n    return matches;\n}\n```\n```\n"]}
{"id": 82, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n This file is part of Airsonic.\n\n Airsonic is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Airsonic is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Airsonic.  If not, see <http://www.gnu.org/licenses/>.\n\n Copyright 2016 (C) Airsonic Authors\n Based upon Subsonic, Copyright 2009 (C) Sindre Mehus\n */\n\npackage org.airsonic.player.service.search;\n\nimport org.airsonic.player.domain.MediaFile.MediaType;\nimport org.airsonic.player.domain.MusicFolder;\nimport org.airsonic.player.domain.RandomSearchCriteria;\nimport org.airsonic.player.domain.SearchCriteria;\nimport org.apache.lucene.analysis.Analyzer;\nimport org.apache.lucene.analysis.TokenStream;\nimport org.apache.lucene.analysis.tokenattributes.CharTermAttribute;\nimport org.apache.lucene.document.IntPoint;\nimport org.apache.lucene.index.Term;\nimport org.apache.lucene.search.BooleanClause.Occur;\nimport org.apache.lucene.search.BooleanQuery;\nimport org.apache.lucene.search.BoostQuery;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.TermQuery;\nimport org.apache.lucene.search.WildcardQuery;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport static org.springframework.util.ObjectUtils.isEmpty;\n\n/**\n * Factory class of Lucene Query.\n * This class is an extract of the functionality that was once part of SearchService.\n * It is for maintainability and verification.\n * Each corresponds to the SearchService method.\n * The API syntax for query generation depends on the lucene version.\n * verification with query grammar is possible.\n * On the other hand, the generated queries are relatively small by version.\n * Therefore, test cases of this class are useful for large version upgrades.\n **/\n@Component\npublic class QueryFactory {\n\n    private static final String ASTERISK = \"*\";\n\n    @Autowired\n    private AnalyzerFactory analyzerFactory;\n\n    private final Function<MusicFolder, Query> toFolderIdQuery = (folder) -> {\n        // Unanalyzed field\n        return new TermQuery(new Term(FieldNames.FOLDER_ID, folder.getId().toString()));\n    };\n\n    private final Function<MusicFolder, Query> toFolderPathQuery = (folder) -> {\n        // Unanalyzed field\n        return new TermQuery(new Term(FieldNames.FOLDER, folder.getPath().toString()));\n    };\n\n    /*\n     *  XXX 3.x -> 8.x :\n     *  \"SpanOr\" has been changed to \"Or\".\n     *   - Path comparison is more appropriate with \"Or\".\n     *   - If \"SpanOr\" is maintained, the DOC design needs to be changed.\n     */\n    private final BiFunction<Boolean, List<MusicFolder>, Query> toFolderQuery = (\n            isId3, folders) -> {\n        BooleanQuery.Builder mfQuery = new BooleanQuery.Builder();\n        folders.stream()\n            .map(isId3 ? toFolderIdQuery : toFolderPathQuery)\n            .forEach(t -> mfQuery.add(t, Occur.SHOULD));\n        return mfQuery.build();\n    };\n\n    /*\n     *  XXX 3.x -> 8.x :\n     * In order to support wildcards,\n     * MultiFieldQueryParser has been replaced by the following process.\n     *\n     *  - There is also an override of MultiFieldQueryParser, but it is known to be high cost.\n     *  - MultiFieldQueryParser was created before Java API was modernized.\n     *  - The spec of Parser has changed from time to time. Using parser does not reduce library update risk.\n     *  - Self made parser process reduces one library dependency.\n     *  - It is easy to make corrections later when changing the query to improve search accuracy.\n     */\n    private Query createMultiFieldWildQuery(String[] fieldNames, String queryString, IndexType indexType)\n            throws IOException {\n\n        BooleanQuery.Builder mainQuery = new BooleanQuery.Builder();\n\n        List<List<Query>> fieldsQuerys = new ArrayList<>();\n        Analyzer analyzer = analyzerFactory.getQueryAnalyzer();\n\n        /* Wildcard applies to all tokens. **/\n        for (String fieldName : fieldNames) {\n            try (TokenStream stream = analyzer.tokenStream(fieldName, queryString)) {\n                stream.reset();\n                List<Query> fieldQuerys = new ArrayList<>();\n                while (stream.incrementToken()) {\n                    String token = stream.getAttribute(CharTermAttribute.class).toString();\n                    WildcardQuery wildcardQuery = new WildcardQuery(new Term(fieldName, token.concat(ASTERISK)));\n                    if (indexType.getBoosts().containsKey(fieldName)) {\n                        fieldQuerys.add(new BoostQuery(wildcardQuery, indexType.getBoosts().get(fieldName)));\n                    } else {\n                        fieldQuerys.add(wildcardQuery);\n                    }\n                }\n                fieldsQuerys.add(fieldQuerys);\n            }\n        }\n\n        /* If Field's Tokenizer is different, token's length may not match. **/\n        int maxTermLength = fieldsQuerys.stream()\n                .map(l -> l.size())\n                .max(Integer::compare).get();\n\n        if (0 < fieldsQuerys.size()) {\n            for (int i = 0; i < maxTermLength; i++) {\n                BooleanQuery.Builder fieldsQuery = new BooleanQuery.Builder();\n                for (List<Query> fieldQuerys : fieldsQuerys) {\n                    if (i < fieldQuerys.size()) {\n                        fieldsQuery.add(fieldQuerys.get(i), Occur.SHOULD);\n                    }\n                }\n                mainQuery.add(fieldsQuery.build(), Occur.SHOULD);\n            }\n        }\n\n        return mainQuery.build();\n    }\n\n    /*\n     * XXX 3.x -> 8.x :\n     * RangeQuery has been changed to not allow null.\n     */\n    private final BiFunction<Integer, Integer, Query> toYearRangeQuery =\n        (from, to) -> {\n            return IntPoint.newRangeQuery(FieldNames.YEAR,\n                isEmpty(from) ? Integer.MIN_VALUE : from,\n                isEmpty(to) ? Integer.MAX_VALUE : to);\n        };\n\n    /**\n     * Query generation expression extracted from\n     * {@link org.airsonic.player.service.SearchService#search(SearchCriteria, List, IndexType)}.\n     *\n     * @param criteria criteria\n     * @param musicFolders musicFolders\n     * @param indexType {@link IndexType}\n     * @return Query\n     * @throws IOException When parsing of MultiFieldQueryParser fails\n     */\n    public Query search(SearchCriteria criteria, List<MusicFolder> musicFolders,\n            IndexType indexType) throws IOException {\n\n        BooleanQuery.Builder mainQuery = new BooleanQuery.Builder();\n\n        Query multiFieldQuery = createMultiFieldWildQuery(indexType.getFields(), criteria.getQuery(), indexType);\n        mainQuery.add(multiFieldQuery, Occur.MUST);\n\n        boolean isId3 = indexType == IndexType.ALBUM_ID3 || indexType == IndexType.ARTIST_ID3;\n        Query folderQuery = toFolderQuery.apply(isId3, musicFolders);\n        mainQuery.add(folderQuery, Occur.MUST);\n\n        return mainQuery.build();\n    }\n\n    /**\n     * Query generation expression extracted from\n     * {@link org.airsonic.player.service.SearchService#getRandomSongs(RandomSearchCriteria)}.\n     */\n```\n\n### Code description\n```Java\n/**\n * Generates a random query for songs based on the given search criteria.\n * \n * @param criteria The search criteria for the random songs query.\n * @return The generated query for random songs.\n * @throws IOException If an I/O error occurs.\n */\n```\n\n### Code snippet:\n```Java\npublic Query getRandomSongs(RandomSearchCriteria criteria) throws IOException {\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n\n    Analyzer analyzer = analyzerFactory.getQueryAnalyzer();\n\n    // Unanalyzed field\n    query.add(new TermQuery(new Term(FieldNames.MEDIA_TYPE, MediaType.MUSIC.name())), Occur.MUST);\n\n    if (!isEmpty(criteria.getGenre())) {\n\n        // Unanalyzed field, but performs filtering according to id3 tag parser.\n        try (TokenStream stream = analyzer.tokenStream(FieldNames.GENRE, criteria.getGenre())) {\n            stream.reset();\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "getRandomSongs", "reference": "            if (stream.incrementToken()) {\n                String token = stream.getAttribute(CharTermAttribute.class).toString();\n                query.add(new TermQuery(new Term(FieldNames.GENRE, token)), Occur.MUST);\n            }\n        }\n    }\n\n    if (!(isEmpty(criteria.getFromYear()) && isEmpty(criteria.getToYear()))) {\n        query.add(toYearRangeQuery.apply(criteria.getFromYear(), criteria.getToYear()), Occur.MUST);\n    }\n\n    query.add(toFolderQuery.apply(false, criteria.getMusicFolders()), Occur.MUST);\n\n    return query.build();\n}", "completions": ["```markdown\n```java\n/**\n * Generates a random query for songs based on the given search criteria.\n * \n * @param criteria The search criteria for the random songs query.\n * @return The generated query for random songs.\n * @throws IOException If an I/O error occurs.\n */\npublic Query getRandomSongs(RandomSearchCriteria criteria) throws IOException {\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n\n    Analyzer analyzer = analyzerFactory.getQueryAnalyzer();\n\n    // Unanalyzed field\n    query.add(new TermQuery(new Term(FieldNames.MEDIA_TYPE, MediaType.MUSIC.name())), Occur.MUST);\n\n    if (!isEmpty(criteria.getGenre())) {\n\n        // Unanalyzed field, but performs filtering according to id3 tag parser.\n        try (TokenStream stream = analyzer.tokenStream(FieldNames.GENRE, criteria.getGenre())) {\n            stream.reset();\n            List<Query> queries = new ArrayList<>();\n            while (stream.incrementToken()) {\n                String token = stream.getAttribute(CharTermAttribute.class).toString();\n                WildcardQuery wildcardQuery = new WildcardQuery(new Term(FieldNames.GENRE, token.concat(ASTERISK)));\n                queries.add(wildcardQuery);\n            }\n            query.add(new BooleanClause.Occur.SHOULD, queries.toArray(new Query[0]));\n        }\n    }\n\n    return query.build();\n}\n```\n```\n"]}
{"id": 83, "prompt": "<\uff5cbegin\u2581of\u2581sentence\uff5c>### Role:\nYou are an experienced Java programmer assistant responsible for code completion tasks. Please intelligently complete the missing parts of the provided code snippet.\n\n### Task:\nBased on the provided code snippet, complete the missing method implementation. Ensure the code is logically correct, syntactically accurate, and follows best coding practices.\n\n### Left context\n```Java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.dashboard.task;\n\nimport com.google.common.base.Stopwatch;\nimport org.apache.rocketmq.common.protocol.body.ClusterInfo;\nimport org.apache.rocketmq.common.protocol.body.GroupList;\nimport org.apache.rocketmq.common.protocol.body.KVTable;\nimport org.apache.rocketmq.common.protocol.body.TopicList;\nimport org.apache.rocketmq.common.protocol.route.BrokerData;\nimport org.apache.rocketmq.common.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.store.stats.BrokerStatsManager;\nimport org.apache.rocketmq.tools.admin.MQAdminExt;\nimport org.apache.rocketmq.tools.command.stats.StatsAllSubCommand;\nimport com.google.common.base.Throwables;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.Files;\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport javax.annotation.Resource;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.protocol.body.BrokerStatsData;\nimport org.apache.rocketmq.dashboard.config.RMQConfigure;\nimport org.apache.rocketmq.dashboard.service.DashboardCollectService;\nimport org.apache.rocketmq.dashboard.util.JsonUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DashboardCollectTask {\n    private Date currentDate = new Date();\n    @Resource\n    private MQAdminExt mqAdminExt;\n    @Resource\n    private RMQConfigure rmqConfigure;\n\n    @Resource\n    private DashboardCollectService dashboardCollectService;\n\n    private final static Logger log = LoggerFactory.getLogger(DashboardCollectTask.class);\n\n    @Scheduled(cron = \"30 0/1 * * * ?\")\n    public void collectTopic() {\n        if (!rmqConfigure.isEnableDashBoardCollect()) {\n            return;\n        }\n\n        Date date = new Date();\n        Stopwatch stopwatch = Stopwatch.createUnstarted();\n        try {\n            TopicList topicList = mqAdminExt.fetchAllTopicList();\n            Set<String> topicSet = topicList.getTopicList();\n            this.addSystemTopic();\n            for (String topic : topicSet) {\n                if (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)\n                    || topic.startsWith(MixAll.DLQ_GROUP_TOPIC_PREFIX)\n                    || TopicValidator.isSystemTopic(topic)) {\n                    continue;\n                }\n                TopicRouteData topicRouteData = mqAdminExt.examineTopicRouteInfo(topic);\n\n                GroupList groupList = mqAdminExt.queryTopicConsumeByWho(topic);\n\n                double inTPS = 0;\n\n                long inMsgCntToday = 0;\n\n                double outTPS = 0;\n\n                long outMsgCntToday = 0;\n\n                for (BrokerData bd : topicRouteData.getBrokerDatas()) {\n                    String masterAddr = bd.getBrokerAddrs().get(MixAll.MASTER_ID);\n                    if (masterAddr != null) {\n                        try {\n                            stopwatch.start();\n                            log.info(\"start time: {}\", stopwatch.toString());\n                            BrokerStatsData bsd = mqAdminExt.viewBrokerStatsData(masterAddr, BrokerStatsManager.TOPIC_PUT_NUMS, topic);\n                            stopwatch.stop();\n                            log.info(\"stop time : {}\", stopwatch.toString());\n\n                            inTPS += bsd.getStatsMinute().getTps();\n                            inMsgCntToday += StatsAllSubCommand.compute24HourSum(bsd);\n                        }\n                        catch (Exception e) {\n                            stopwatch.reset();\n                            log.warn(\"Exception caught: mqAdminExt get broker stats data TOPIC_PUT_NUMS failed\");\n                            log.warn(\"Response [{}] \", e.getMessage());\n                        }\n                    }\n                }\n\n                if (groupList != null && !groupList.getGroupList().isEmpty()) {\n\n                    for (String group : groupList.getGroupList()) {\n                        for (BrokerData bd : topicRouteData.getBrokerDatas()) {\n                            String masterAddr = bd.getBrokerAddrs().get(MixAll.MASTER_ID);\n                            if (masterAddr != null) {\n                                try {\n                                    String statsKey = String.format(\"%s@%s\", topic, group);\n                                    BrokerStatsData bsd = mqAdminExt.viewBrokerStatsData(masterAddr, BrokerStatsManager.GROUP_GET_NUMS, statsKey);\n                                    outTPS += bsd.getStatsMinute().getTps();\n                                    outMsgCntToday += StatsAllSubCommand.compute24HourSum(bsd);\n                                }\n                                catch (Exception e) {\n                                    log.warn(\"Exception caught: mqAdminExt get broker stats data GROUP_GET_NUMS failed\");\n                                    log.warn(\"Response [{}] \", e.getMessage());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                List<String> list;\n                try {\n                    list = dashboardCollectService.getTopicMap().get(topic);\n                }\n                catch (ExecutionException e) {\n                    throw Throwables.propagate(e);\n                }\n                if (null == list) {\n                    list = Lists.newArrayList();\n                }\n\n                list.add(date.getTime() + \",\" + new BigDecimal(inTPS).setScale(5, BigDecimal.ROUND_HALF_UP) + \",\" + inMsgCntToday + \",\" + new BigDecimal(outTPS).setScale(5, BigDecimal.ROUND_HALF_UP) + \",\" + outMsgCntToday);\n                dashboardCollectService.getTopicMap().put(topic, list);\n\n            }\n\n            log.debug(\"Topic Collected Data in memory = {}\" + JsonUtil.obj2String(dashboardCollectService.getTopicMap().asMap()));\n        }\n        catch (Exception err) {\n            throw Throwables.propagate(err);\n        }\n    }\n\n```\n\n### Code description\n```Java\n/**\n * Description: This method is used to collect broker data and update it in memory.\n * It uses the API of com.google.common.collect.Maps.newHashMap to create a new HashMap.\n * The method is scheduled to run every minute (0 0/1 * * * ?).\n * \n * @param rmqConfigure An instance of the RMQConfigure class, which contains configuration for RabbitMQ.\n * @param mqAdminExt An instance of the MQAdminExt class, which provides extended administrative functions for RabbitMQ.\n * @param dashboardCollectService An instance of the DashboardCollectService class, which is used to collect data for the dashboard.\n * @throws Exception If an error occurs during the execution of the method.\n */\n```\n\n### Code snippet:\n```Java\n@Scheduled(cron = \"0 0/1 * * * ?\")\npublic void collectBroker() {\n    if (!rmqConfigure.isEnableDashBoardCollect()) {\n        return;\n    }\n    try {\n        Date date = new Date();\n        ClusterInfo clusterInfo = mqAdminExt.examineBrokerClusterInfo();\n        Set<Map.Entry<String, BrokerData>> clusterEntries = clusterInfo.getBrokerAddrTable().entrySet();\n\n        Map<String, String> addresses = Maps.newHashMap();\n        for (Map.Entry<String, BrokerData> clusterEntry : clusterEntries) {\n            HashMap<Long, String> addrs = clusterEntry.getValue().getBrokerAddrs();\n            Set<Map.Entry<Long, String>> addrsEntries = addrs.entrySet();\n            for (Map.Entry<Long, String> addrEntry : addrsEntries) {\n                addresses.put(addrEntry.getValue(), clusterEntry.getKey() + \":\" + addrEntry.getKey());\n            }\n        }\n        Set<Map.Entry<String, String>> entries = addresses.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            List<String> list = dashboardCollectService.getBrokerMap().get(entry.getValue());\n```\n\n### Requirements:\n1. Complete only the missing part of the method.\n2. Only answer the code of the completed part. Do not include any of the provided code snippet.\n3. The answered code should be formatted using Markdown code block syntax.\n4. Do not include any additional text.\n\n### Answer: (use the provided format with backticks)\n", "name": "collectBroker", "reference": "            if (null == list) {\n                list = Lists.newArrayList();\n            }\n            KVTable kvTable = fetchBrokerRuntimeStats(entry.getKey(), 3);\n            if (kvTable == null) {\n                continue;\n            }\n            String[] tpsArray = kvTable.getTable().get(\"getTotalTps\").split(\" \");\n            BigDecimal totalTps = new BigDecimal(0);\n            for (String tps : tpsArray) {\n                totalTps = totalTps.add(new BigDecimal(tps));\n            }\n            BigDecimal averageTps = totalTps.divide(new BigDecimal(tpsArray.length), 5, BigDecimal.ROUND_HALF_UP);\n            list.add(date.getTime() + \",\" + averageTps.toString());\n            dashboardCollectService.getBrokerMap().put(entry.getValue(), list);\n        }\n        log.debug(\"Broker Collected Data in memory = {}\" + JsonUtil.obj2String(dashboardCollectService.getBrokerMap().asMap()));\n    }\n    catch (Exception e) {\n        throw Throwables.propagate(e);\n    }\n}", "completions": ["```Java\n            if (null == list) {\n                list = Lists.newArrayList();\n            }\n            list.add(date.getTime() + \",\" + entry.getValue());\n            dashboardCollectService.getBrokerMap().put(entry.getValue(), list);\n        }\n        log.debug(\"Broker Collected Data in memory = {}\" + JsonUtil.obj2String(dashboardCollectService.getBrokerMap().asMap()));\n    }\n    catch (Exception err) {\n        log.error(\"Exception caught: mqAdminExt get broker cluster info failed\", err);\n    }\n}\n```\n"]}
